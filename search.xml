<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>全排列问题</title>
    <url>/posts/5519175/</url>
    <content><![CDATA[<p><strong>排列 (Permutation)</strong> 是将相异对象或符号根据确定的顺序重排。每个顺序都称作一个排列。</p>
<p>从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个<strong>排列</strong>。当m=n时所有的排列情况叫<strong>全排列</strong>。</p>
<p>全排列问题常出现在<strong>串（string）</strong> 相关的问题中。</p>
<p>例题：</p>
<ul>
<li><a class="link"   href="https://leetcode.cn/problems/permutations/" >46. 全排列 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/" >剑指Offer 38. 字符串的排列 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<span id="more"></span>
<h3 id="1-递归DFS-剪枝解法">1. 递归DFS+剪枝解法</h3>
<h4 id="最佳子结构设计">最佳子结构设计</h4>
<p>长度为n的串的全排列问题可以分为以下的子问题结构：</p>
<ul>
<li>a = 长度为n-1的串有多少种排列</li>
<li>b = 插入的元素有多少种可能</li>
</ul>
<p>最后的结果显然为 a+b</p>
<p>那么<strong>如何得到长度为n-1的串的排列数</strong>呢？</p>
<p>我们先固定一种串的排列方式，通过字符交换的方式，依次固定第i个字符，直到固定第n个字符时即为一种排列方式。</p>
<p>遍历途中对于固定的第i个字符，剩下的 (n-i) 个字符，则是需要<strong>递归</strong>处理的子问题。</p>
<p>但是，这种方法<strong>对于含有重复元素的集合会产生重复串</strong>（不适用重复元素）。</p>
<p>按照上述的最佳子结构关系，以串 <code>1234</code> 为例构建递归如下图所示，边界情况为<strong>子串长度=1</strong>：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202304191331027.jpeg"
                      alt=""
                ></p>
<h4 id="剪枝">剪枝</h4>
<p>我们不妨思考一下，<strong>为什么会产生重复串</strong>呢？</p>
<p>因为在交换的时候，对于固定位<code>chs[i]</code>，后面若有两个重复字符，就会与之交换两次，虽然当时是不重复的，但在后续的交换中就会产生重复串。</p>
<p>如串<code>abccd</code>，在固定<code>a</code>时会与<code>c</code>交换两次，生成两个串<code>cbacd</code>和<code>cbcad</code>。虽然此时这是不重复的，但我们在DFS树中更深入一点，在<code>cbacd</code>这个分支里，固定位到<code>a</code>时，也会因交换产生<code>cbcad</code>这个串，这样就产生了重复。</p>
<p>因此，如果我们在分支的上游就排除了相同字符交换产生的分支（<strong>剪枝</strong>），不仅可以避免重复，还可以避免大量重复计算。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202304222208325.png"
                      style="zoom:50%;" 
                >
<p>具体的实现，我们可以通过一个<strong>HashSet</strong>（其内的元素不允许重复，具有集合的特征，详见容器篇）来记录当前交换过程内所有已经交换过的字符来实现剪枝。</p>
<h4 id="代码">代码</h4>
<p>C#题解如下：</p>
<div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Permutation</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> List&lt;<span class="built_in">string</span>&gt; Result = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T[] <span class="title">Swap</span>&lt;<span class="title">T</span>&gt;(<span class="params">T[] source, <span class="built_in">int</span> i1, <span class="built_in">int</span> i2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">var</span> t = source[i2];</span><br><span class="line">      source[i2] = source[i1];</span><br><span class="line">      source[i1] = t;</span><br><span class="line">      <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">string</span>[] <span class="title">Recursively</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">var</span> candidate = str.ToCharArray();</span><br><span class="line">      Recursively(candidate, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">var</span> res = Result.ToArray();</span><br><span class="line">      Result.Clear();</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Recursively</span>(<span class="params"><span class="built_in">char</span>[] charSet, <span class="built_in">int</span> start</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (start == charSet.Length - <span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">var</span> str = <span class="keyword">new</span> String(charSet);</span><br><span class="line">        Console.WriteLine(str);</span><br><span class="line">        Result.Add(str);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> <span class="keyword">set</span> = <span class="keyword">new</span> HashSet&lt;<span class="built_in">char</span>&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">int</span> i = start; i &lt; charSet.Length; i++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == start || charSet[i] != charSet[start])</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">set</span>.Contains(charSet[i])) <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">set</span>.Add(charSet[i]);</span><br><span class="line">          Swap(charSet, start, i);</span><br><span class="line">          Recursively(charSet, start + <span class="number">1</span>);</span><br><span class="line">          Swap(charSet, start, i); <span class="comment">// 还原变化</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="字典序排列">字典序排列</h3>
<h4 id="下一个排列数">下一个排列数</h4>
<p>一个（数字）序列的<strong>字典序</strong>是这些数字（如 {1, 2, 3, 4}）组成的串大小（如1234）按升序排列的顺序，<strong>下一个排列</strong>就是对应串 (如<code>12354</code>) 在字典序中的下一个序列 (如<code>12435</code>)。</p>
<p>为了得到下一个更大的最小序列数（比当前大，但增加的幅度尽量小），我们构造如下算法要求：</p>
<ul>
<li>为了<strong>比当前大</strong>，我们需要将<strong>后面的大数（低位大数）与前面的小数交换（高位小数）</strong></li>
<li>为了增大的尽量小，我们要满足以下要求：
<ul>
<li>交换的位越靠右越好（位数越低增加得越少）</li>
<li>将右边最小的大数用于交换</li>
<li>交换后还要保证右边的序列是最小的（逆序排列）</li>
</ul>
</li>
</ul>
<p>最后，我们构造算法如下：</p>
<ol>
<li><strong>从后向前</strong> 查找第一个 <strong>相邻升序</strong> 的元素对 <code>(i,j)</code>，满足 <code>A[i] &lt; A[j]</code>。此时 <code>[j,end)</code> 必然是降序</li>
<li>在 <code>[j,end)</code> <strong>从后向前</strong> 查找第一个满足 <code>A[i] &lt; A[k]</code> 的 <code>k</code>。<code>A[i]</code>、<code>A[k]</code> 分别就是上文所说的「小数」、「大数」</li>
<li>将 <code>A[i]</code> 与 <code>A[k]</code> 交换</li>
<li>可以断定这时 <code>[j,end)</code> 必然是降序，逆置 <code>[j,end)</code>，使其升序</li>
<li>如果在步骤 1 找不到符合的相邻元素对，说明当前 <code>[begin,end)</code> 为一个降序顺序，则直接跳到步骤 4【最大序列跳回最小序列】</li>
</ol>
<p>C# 实现为：</p>
<div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NextPermutation</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = nums.Length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &lt; nums[i]) <span class="comment">// 找到第一个升序对</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">int</span> j = nums.Length - <span class="number">1</span>; j &gt;= i; j--)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &gt; nums[i - <span class="number">1</span>]) <span class="comment">// 找到最小交换位置</span></span><br><span class="line">        &#123;</span><br><span class="line">          Swap(nums, j, i - <span class="number">1</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">int</span> left = i, right = nums.Length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) <span class="comment">// 逆序排列</span></span><br><span class="line">  &#123;</span><br><span class="line">    Swap(nums, left, right);</span><br><span class="line">    left++;</span><br><span class="line">    right--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="解决字符串排列问题">解决字符串排列问题</h4>
<p>直接把串化为字符数组，然后对这个数组排序，得到<strong>初始字典序</strong>，反复求下一个排列直到最大排序。</p>
<ol>
<li>先输出初始序列：1234</li>
<li><strong>从右向左</strong>找到第一个<strong>非递增</strong>的数（比前一个数小的数）：3</li>
<li>交换这个数与前一个数，并一路移动到右边序列末尾，输出序列：1243  （<a class="link"   href="https://leetcode.cn/problems/next-permutation/" >31. 下一个全排列数  <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）</li>
<li>循环直到找不到更大的排列数</li>
</ol>
<p>这个方法的优势在于：没有递归栈，省去了反复函数调用的开销。</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>全排列</tag>
        <tag>递归</tag>
        <tag>动态规划</tag>
        <tag>字典序</tag>
      </tags>
  </entry>
  <entry>
    <title>关于刷题环境的看法与选择</title>
    <url>/posts/1890791615/</url>
    <content><![CDATA[<p>今天在准备机试，拿起很久没刷的算法题 <s>（上次刷题还是大一刷洛谷）</s> ，除了考虑刷哪一套题单，要考虑的就是<strong>使用什么语言、什么环境</strong>来刷。</p>
<blockquote>
<p>2023年5月更新：</p>
<p>刷了一个多月题后我的感受发生了变化，其实用什么语言不重要，相反的，<strong>如果你想要快速上手一门语言的基本特性，你就用它来刷题就对了。</strong></p>
</blockquote>
<h2 id="刷题环境的选择标准">刷题环境的选择标准</h2>
<p>由于线上环境与本地环境有较大区别，而<strong>面向机试的刷题练习应该尽量做到与线上环境保持一致</strong> ，因此我提出了对<strong>本地环境</strong>的以下几点基本要求：</p>
<ul>
<li>尽量使用 <strong>文本编辑器+单文件（脚本）</strong> 的方式而 <strong>非IDE+项目</strong> 的模式，方便管理多道题目</li>
<li>编译运行过程尽量简单，且<strong>支持单步调试</strong></li>
<li><strong>语法简单</strong>易上手 <s>（刷题就不要想<code>borrow</code>的事情了）</s> ，有完善的轮子 <s>（谁也不想用C手搓堆吧）</s></li>
<li><s>语言运行速度不拖后腿</s>，这点其实不太重要，因为大多只看复杂度而不看绝对时间</li>
<li>环境本身不应提供过多辅助功能（如Copilot），有些在线环境甚至不提供代码提示</li>
</ul>
<p>基于上述的基本标准，我们再进一步地细化一些标准，<strong>优先级从上到下递减</strong>：</p>
<ol>
<li>完善的轮子，如容器库、基础数据类操作方法等</li>
<li>单文件结构体系（或脚本语言），不依赖项目（刷题几乎不存在项目复用的需求，除非极少数题目共享数据结构需要多文件模块化）</li>
<li>函数为一等公民，而不必用类去包裹</li>
<li>简便的调试，清晰的异常处理信息</li>
<li><s>性能够用，贴近底层，有更多优化空间（不打榜的话其实没有需求）</s></li>
</ol>
<h2 id="刷题环境的推荐">刷题环境的推荐</h2>
<p>根据我们上面提出的规则，根据满足的规则多少，我们将按优先级先后排列主流刷题环境，并依次叙述如何快速配置（均搭配Windows下的<strong>VS Code</strong>编辑器）：</p>
<ol>
<li><strong>C++ 11</strong>: 满足1、2、3、5（4部分符合）</li>
<li><strong>JS</strong>: 满足1、2、3、4（不包含TS，TS配置太麻烦了，不能开箱即用）</li>
<li><strong>Python</strong>：满足1、2、3、4~~（其实个人感觉Python比JS更好，但由于我讨厌Python的缩进所以放到后面）~~</li>
<li>C# Script：满足1、2、3（部分4，且性能有些一言难尽）</li>
<li>Java：满足1、4~~（如果不是后端需求大我真的都不想推荐）~~</li>
</ol>
<blockquote>
<p>VS Code 中的相关插件就不再推荐，自己搜索<strong>官方插件</strong>安装即可。</p>
</blockquote>
<h3 id="C-11">C++ 11</h3>
<p>先抛开C++贴近底层的性能优势不谈（单纯刷题的话并无太大优势），由于C语言几乎是科班必修，C++完全可以当成C+STL来用，对初学者而言上手难度极低。</p>
<p>与此同时，在使用C++、看别人题解的同时也可以学习一些比较现代的C++语法（亲测洛谷、力扣和牛客都支持C++11），如<code>auto</code>迭代器、<code>lambda</code>表达式等。除此之外，C++的上限还很高，换句话说就是C++允许你去抠每个细节的性能，如果你觉得官方库的性能不尽人意你甚至可以自己写来超过官方库（如果你够牛的话，比如超过不开O2的STL）。</p>
<p>除此之外，C++还是CSP的官方赛事语言~~（不喜欢Java的同学们有福啦）~~，虽然只允许你使用 Dev-CPP 作为环境。</p>
<h4 id="环境配置（WSL2）">环境配置（WSL2）</h4>
<p>做C++开发的话，个人还是推荐在Linux环境下，WSL2 Ubuntu就是不错的选择。一方面可以避免Windows下C++安装配环境变量很麻烦或者被迫用 msbuild 的情况，一方面还可以练一练 Linux 小技巧，一石二鸟，何乐而不为呢？</p>
<p>首先<a class="link"   href="https://learn.microsoft.com/en-us/windows/wsl/install" >安装WSL2 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>（这部分略），安装完成后安装C/C++套件：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential gdb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装完成后检查</span></span><br><span class="line">g++ -v</span><br><span class="line">gdb -v</span><br></pre></td></tr></table></figure></div>
<p>如果成功打印了版本说明安装成功！</p>
<p>接着配置 VS Code 中的 WSL 开发环境，包括 <code>launch.json</code> 和 <code>tasks.json</code> 两部分，详见：<a class="link"   href="https://blog.csdn.net/long9827/article/details/113732380" >使用vs code和wsl搭建C/C++开发环境_wsl c++ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。（偷懒了，以后会补充的）</p>
<h4 id="环境配置（Windows）">环境配置（Windows）</h4>
<p>如果你是一个坚定的 Windows 党，你也可以选择手动在 Windows 上配置 <em>mingw-w64</em> 套件来安装 g++<s>（总之就是不推荐在VS以外使用MSBuild）</s></p>
<p>具体步骤如下：</p>
<ol>
<li>在<a class="link"   href="https://www.mingw-w64.org/downloads/" >mingw-w64官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>找到一个Windows的预编译包（一般是x86-64），我个人用的是<a class="link"   href="https://github.com/mstorsjo/llvm-mingw/releases" >llvm-mingw (github.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>（如果你上不去或者下载不了，建议先把梯子搞定了，而不要去找网盘或者镜像源，<strong>学会使用国际互联网是在中国搞开发的第一步</strong>）</li>
<li>下载，解压，放到你喜欢的目录下面，比如我的目录是 <code>c:/mingw</code>，注意看里面应该有一个 <code>bin/</code> 目录，而里面就有 gcc.exe 和 g++.exe 等等</li>
<li>把解压的目录添加到<strong>环境变量</strong></li>
<li>添加完了在终端里试试 <code>g++ -v</code>，如果显示了版本就说明安装成功。</li>
</ol>
<p>后续配置VSCode的过程和上面几乎相同。</p>
<h4 id="C-的弊端">C++的弊端</h4>
<ul>
<li>C++的语法非常的不优雅，相对于C#和Java来说，一堆<code>::</code>和下划线实在不是很好看</li>
<li>C++的字符串处理不太行，很多功能如<code>split</code>等都需要手写</li>
<li>C++的报错信息很不友好，堆分配对象的Debug体验也很不好（指针就只给你显示它自己解引用的值）</li>
<li>VSCode配置相比JS和Python这样的脚本语言来说麻烦很多</li>
</ul>
<blockquote>
<p>但是没办法，你就是得会、得用C++。</p>
</blockquote>
<h3 id="JS">JS</h3>
<p>虽然我个人秉承着<strong>能用TS就不用JS</strong>的理念，但这也只是工程上。刷题的时候强调的就是一个<strong>开箱即用</strong>，而TS还要转译、配置无疑太过麻烦了，而且引入类型系统对刷题这个代码量其实没有太多的好处。</p>
<p>JS是<strong>动态类型</strong>的、<strong>解释型</strong>的<strong>脚本语言</strong>，语法和Java很像，而且也可以直接编写顶层函数，也可以使用ES6后的现代语法和容器等等，而且它的<strong>配置相比C++来说简单太多</strong>，VS Code这种本就为前端而生的编辑器对JS和Node的支持可以说是开箱即用。</p>
<p>之前我还在担心JS的动态类型和奇怪特性会影响刷题，但现在看来完全是我多想了，用JS刷题对于前端er和Java开发者都是很爽的（特别是对C不熟悉的人）。</p>
<h4 id="配置过程">配置过程</h4>
<ol>
<li>安装 Node.JS （16或18都可以），过程比较简单，下一步即可</li>
<li>运行 <code>node --version</code> 检查安装情况</li>
<li>直接在 VS Code 里开写，调试配置会自动生成（Run Code也可以直接运行）</li>
</ol>
<h3 id="Python">Python</h3>
<p>Python 作为数据科学常用的语言，也是动态的、解释型的，其实个人感觉刷题体验和JS应该是不相上下的。与JS不同的是，cpython的底层让Python更多作为其他语言的“前端”存在（如C++写的众多机器学习、科学计算库），像胶水一样黏合不同的语言，降低使用门槛。</p>
<p>但是刷题过程中几乎不用到这些第三方库，Python的生态优势就消散了不少，不过即使Python本身性能较弱，但面对刷题这样的“轻量级需求”还是绰绰有余的。</p>
<p>个人而言，Python令我最膈应的地方还是<strong>缩进语法</strong>了，我真的很难想象一个正经语言会用空白符作为有用的语义分割。</p>
<p>最后，我的评价是：该用还得用，如果你本来就对Python很熟，用就对了！</p>
<h4 id="配置过程-2">配置过程</h4>
<ol>
<li>安装 Python（Python的版本管理是很麻烦的，但是刷题不管）</li>
<li>检查环境变量，终端运行 <code>python</code></li>
<li>直接在 VS Code 里开写，调试配置会自动生成（Run Code也可以直接运行）</li>
</ol>
<h3 id="C-Script">C# Script</h3>
<p>这里不再推荐传统C#项目，而是C# Script，什么是C# Script可以看看我的<a class="link"   href="https://chlorinec.top/posts/3021583790/" >这篇文章 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。毕竟 C# Script（下文简称CSX）就是利用了顶层语句和隐式引用语法糖+REPL解释环境的C#环境，也就是说里面<strong>完完全全就是C#的语法和环境</strong>，只是变成了<strong>脚本语言</strong>的形式。</p>
<p>它最大的优势就是<strong>C#完备的轮子（各种容器、数据处理和LinQ）</strong>，还有C#大量的语法糖降低了编写复杂度（如<code>var</code>类型、隐式元组等），而这一切又以脚本的形式呈现出来（感觉就像 Python++），还支持单步调试。</p>
<p>它也有几点缺点，而且这些缺点还不小，所以排名才这么靠后：</p>
<ul>
<li>性能问题：REPL环境天生性能更差，在线平台C#的性能表现也不尽人意，但是过关肯定没问题</li>
<li>大部分刷题环境不支持CSX，需要手动转换成类语法比较麻烦</li>
</ul>
<p>具体配置的话还是参考我的另一篇文章：<a class="link"   href="https://chlorinec.top/posts/3021583790/" >初探 C# Script - ChlorineC’s Blog <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Java">Java</h3>
<p><s>个人感觉Java最大的槽点是擦除式泛型，但是这对刷题几乎没有影响。</s></p>
<p>Java 个人感觉最大的问题和 C# 这样的强OOP语言一样，是与项目深度绑定，但 C# Script 已经出了，所以现在只有 Java 一枝独秀了（谁让JS和Java不算是一门语言呢）。</p>
<p>如果你用着IDEA的话，那就直接用Java也没啥问题，否则个人感觉用VS Code去配Java还是有点麻烦的，具体配置过程这里就不再赘述。</p>
<p>至于老生常谈的GC和JVM调优这些问题，一方面对刷题根本没有影响，一方面新版本的JDK已经基本解决了这些问题（zGC和Native AOT）。</p>
<p>我本来以为Java和.NET性能应该是半斤八两的，毕竟个人体验下来在本地环境里.NET7其实会略快于Java11，但是<strong>刷题的实际成绩中Java大幅领先C# 10倍左右</strong>，时间复杂度直逼C++。</p>
<h2 id="Benchmark">Benchmark</h2>
<p>这里以搜索二维矩阵为例，以<strong>全部二分法</strong>在<strong>LeetCode</strong>的评测结果作为Benchmark测试各平台性能。</p>
<p>在线平台：<strong>LeetCode 2023/04/12</strong></p>
<p>解题代码如下（以C#为例）：</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SearchMatrix</span>(<span class="params"><span class="built_in">int</span>[][] matrix, <span class="built_in">int</span> target</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.Length == <span class="number">0</span> || matrix[<span class="number">0</span>].Length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">int</span> begin, mid, end;</span><br><span class="line">        begin = mid = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> dim1 = matrix.Length, dim2 = matrix[<span class="number">0</span>].Length;</span><br><span class="line">        end = dim1 * dim2 <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">            mid = (begin + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[mid/dim2][mid%dim2] &lt; target) begin = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix[begin/dim2][begin%dim2] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>最终相同代码在不同语言下得到的成绩如下：</p>
<p>【图坏了】</p>
<p>可以看到：</p>
<ul>
<li>C++发挥稳定，内存占用一如既往的独一档，但Java执行用时和其在一个水平上令人亮眼</li>
<li>C#和Java作为带Runtime和GC的语言，<strong>内存占用</strong>在一个量级上</li>
<li>C#不知道什么原因大幅落后于Java</li>
<li>Python表现令人意外（也可能是C#令人太意外了），处于中规中矩的水平</li>
</ul>
<h2 id="个人的其他困惑">个人的其他困惑</h2>
<p>关于在线平台个人最大的不满还是<strong>运行环境的不透明性</strong>，你不能直观地知道当前运行环境的SDK版本，也不知道相关配置（有没有开启特定优化）。</p>
<p>其次是在线编译器的<strong>代码提示不完整</strong>，<strong>编译和Debug体验也不好</strong>，与本地环境脱节比较严重。</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>开发环境</tag>
        <tag>c/c++</tag>
        <tag>java</tag>
        <tag>python</tag>
        <tag>js</tag>
        <tag>ts</tag>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Table布局实现EDM设计</title>
    <url>/posts/3247330139/</url>
    <content><![CDATA[<p>在实习的时候被安排了EDM编写，个人也是第一次接触这个领域。本来以为就是简单的HTML编写，后来发现EDM-HTML有它独特的地方，如邮件客户端奇特的渲染引擎限制，和普通HTML5网页不同的布局设计等。这里记录我在编写EDM时的一些想法。</p>
<span id="more"></span>
<h2 id="简述EDM">简述EDM</h2>
<p><strong>EDM（Electronic Direct Mail marketing）</strong> 指的是电子直邮营销，是一种通过电子邮件向特定受众发送商业信息的营销方式。EDM营销可以包括广告、促销、新闻、事件邀请等多种形式的电子邮件。通过EDM，企业可以向目标受众发送具有针对性的信息，提高品牌知名度和销售转化率。同时，EDM营销也可以进行数据分析，了解邮件打开率、点击率和转化率等关键指标，为企业决策提供重要的参考。</p>
<p>因为我所在的部门是国际事业部，国外的营销策略和国内有很大不同，像国内可能更注重IM平台的宣发（如微信、QQ等），而国外则使用邮箱更多一些。举个例子，现在打开你的邮箱，给你发广告的肯定都是一些国外的公司像Twitter、Steam这种，而国内的基本都不会发广告邮件。</p>
<p>因此，做国外的推广和宣发工作，EDM编写就是非常关键的一环。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://images.unsplash.com/photo-1522542550221-31fd19575a2d?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1470&amp;q=80"
                      alt=""
                ></p>
<h3 id="EDM编写的特点">EDM编写的特点</h3>
<p>由于EDM-HTML的宿主环境是各邮件客户端而不仅仅是浏览器（虽然也有网页邮箱这样的存在），因此EDM最突出的问题就是<strong>兼容性问题</strong>。如果你发的广告到客户的手机上无法正常显示，那别说推广产品了，对企业的印象分直接跌落谷底。</p>
<p>与公司同事交流后，我总结了EDM编写需要遵守以下规则：</p>
<ul>
<li>使用<code>&lt;table&gt;</code>和<code>table-layout</code>进行页面布局，而不是常用的<code>flex</code>和<code>grid</code>布局</li>
<li>不应使用类选择器，而应使用<strong>内联样式</strong>（这和传统Web开发完全背道而驰）</li>
<li>不支持绝对定位（如<code>top</code>、<code>left</code>等属性）</li>
<li>由于设计稿的需求比较细化，移动端和桌面端应使用独立的代码（使用<strong>媒体查询</strong>和<code>display: none</code>切换），而不是共用一套响应式代码</li>
</ul>
<h2 id="table-标签"><code>&lt;table&gt;</code> 标签</h2>
<p><code>&lt;table&gt;</code>表示表格数据, 即在一个由包含数据的行和列组成的二维表格中呈现的信息。最正统的用法肯定是展示一个数据表格，但由于<code>&lt;td&gt;</code>和<code>&lt;th&gt;</code>接收任何流式内容的特点，在EDM一般作为<code>flex</code>和<code>grid</code>的替代品存在。</p>
<blockquote>
<p><em>之前都没怎么接触过<code>&lt;table&gt;</code>这个语义化的表格标签，遇到类似的情况都是直接使用<code>grid</code>布局解决。</em></p>
</blockquote>
<h3 id="允许的内容">允许的内容</h3>
<p>下面这些语义化标签实际上都是<strong>可选的</strong>，表格中可以直接<code>&lt;tr&gt;</code>起手，用<code>&lt;td&gt;</code>定义元素即可。</p>
<ul>
<li><code>&lt;caption&gt;</code>标签展示一个表格的<strong>标题</strong>，常作为第一个元素出现，同时显示在最前面，但这并不是硬性规定的，因此<strong>可以出现在任何位置</strong>，且可以被CSS样式化。</li>
<li><code>&lt;colgroup&gt;</code>标签用于定义表格中的列（簇）。
<ul>
<li>子节点接收<code>&lt;col&gt;</code>标签来具体定义列簇
<ul>
<li><code>span</code>属性用于指定一个列簇有几列，从左到右计数，默认值为<code>1</code></li>
<li><code>class</code>属性为列簇的所有元素附上指定的类选择器</li>
</ul>
</li>
<li>注意这个标签仅用于表格元素而非CSS（虽然可以给class）</li>
</ul>
</li>
<li><code>&lt;thead&gt;</code>标签定义了一组定义表格的列头的行，接收&gt;=0个<code>&lt;tr&gt;</code>元素</li>
<li><code>&lt;tbody&gt;</code>标签封装了一系列表格的行（<code>&lt;tr&gt;</code>），是表格的主要组成部分</li>
<li><code>&lt;tfoot&gt;</code>标签元素封装了一系列表格的行</li>
</ul>
<h3 id="tr-标签及其内容"><code>&lt;tr&gt;</code>标签及其内容</h3>
<p><code>&lt;tr&gt;</code>标签是表格的灵魂，它定义了表格一行的内容，接收<code>&lt;td&gt;</code>和<code>&lt;th&gt;</code>作为子节点内容，二者可以同时出现。</p>
<p>注意：<code>&lt;td&gt;</code>和<code>&lt;th&gt;</code>可以<strong>接受任何流式内容</strong>，这也是可以它可以作为EDM布局的基础所在。</p>
<ul>
<li><code>&lt;th&gt;</code>标签定义表格内的表头单元格，由<code>scope</code>和<code>headers</code>属性精准定义
<ul>
<li><code>headers</code>属性：包含了一个空间分隔的字符串的列表，每个与其他<code>&lt;th&gt;</code>元素相关联的<code>id</code> 属性一一对应。</li>
<li><code>scope</code>属性：定义了该表头关联的单元格
<ul>
<li><code>row</code>: 表头关联一行中所有的单元格。</li>
<li><code>col</code>: 表头关联一列中所有的单元格。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="支持的属性（HTML-Attribute）">支持的属性（HTML Attribute）</h4>
<ul>
<li><code>align</code>：指定每个单元格内<strong>水平对齐方式</strong>，支持<code>left</code>, <code>center</code>, <code>right</code>, <code>justify</code>（两侧对齐）</li>
<li><code>bgcolor</code>：指定单元格背景颜色</li>
<li><code>valign</code>：指定每个单元格内<strong>垂直对齐方式</strong>，支持<code>baseline</code>, <code>middle</code>, <code>top</code></li>
</ul>
<h3 id="使用CSS自定义Table布局">使用CSS自定义Table布局</h3>
<h4 id="table-layout">table-layout</h4>
<div class="note info"><p>此部分内容还在编辑中</p>
</div>
<h4 id="媒体查询（-media）">媒体查询（@media）</h4>
<div class="note info"><p>此部分内容还在编辑中</p>
</div>
<h2 id="EDM编写过程中存在的问题">EDM编写过程中存在的问题</h2>
<p>EDM虽然也算是HTML编写的一个分支，但是其编写体验可谓是天差地别。前端对于我来说最大的特点就是“所见即所得”的开发感受，但在EDM编写中这种感受被另一种强大的挫败感完全盖过了。</p>
<p>经过思考后，我感觉所谓的挫败感来源主要在于以下几方面：</p>
<ul>
<li>项目的<strong>可读性</strong>和<strong>可维护性差</strong></li>
<li><strong>非响应式设计</strong>，对桌面端（big-screen）和移动端（mobile）需要分别写两份代码</li>
<li>未知的<strong>兼容性问题</strong>，很难找到问题所在</li>
</ul>
<p>因此，我根据上述问题从以下几个角度分析，并<strong>尝试提出我自己的EDM框架作为解决方案</strong>。</p>
<h3 id="代码可读性">代码可读性</h3>
<p>关于EDM我最大的槽点就是代码可读性了，我第一次打开EDM的时候我直接惊掉下巴，居然还有这么原始的方式。作为实际投入生产的HTML自然不必在意可读性，只要稳定就好，但在编写过程中还是尽量应该保持简洁的工程化属性（就像框架项目源码和webpack最终打包结果一样）。</p>
<ul>
<li><strong>代码风格不统一</strong>：可能公司里大部分EDM都是由实习生完成的，导致整个组件的风格很不统一，能明显看出是从两个人写的组件里摘到了一起：如同一个<code>padding</code>属性，在A组件里可能放在<code>&lt;td&gt;</code>标签里，而在B组件里就跑到了里面的<code>&lt;span&gt;</code>或<code>&lt;img&gt;</code>标签里。</li>
<li><strong>内联样式导致代码膨胀</strong>：一个简单的EDM页面由于每个元素的内联样式和移动端+桌面端两套代码，代码行数<strong>快速膨胀至几千行</strong>，任何人看到几千行HTML的时候都是崩溃的吧，特别是这还是一个需要维护和复用的页面
<ul>
<li><strong>大量冗余样式</strong>：由于组件负责人不同、复用方式是复制粘贴且没有代码审查机制，<strong>不同组件之间甚至组件内部</strong>都会出现大量冗余的内联样式（如明明父组件声明了样式，子组件重复声明了一次；或之前粘贴的组件带了一些样式，修改时直接在后面添加而没有删除之前的样式等等），这不仅增加了代码阅读难度，还增加了出现BUG的可能性（优先级混乱）</li>
<li><strong>双端重复代码多</strong>：桌面端和移动端大部分的代码都是一样的，编写时大多就是复制粘贴然后微调样式，然后继续复制粘贴，最后直接导致代码量翻倍，增加了维护成本</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>个人建议</strong>：</p>
<ul>
<li>搭建测试环境，允许模拟不同环境测试兼容性，或者直接通过Code-Review来判断兼容性（语法黑名单或白名单）</li>
<li>支持个人编写测试脚本来快速测试功能（如显示效果、资源加载、链接、表单测试），可以参考开源的成熟HTML测试方案</li>
<li>工程化管理（后文会提到），并使用组件复用、外联CSS等特性，最后编译生成EDM-HTML（与测试搭配使用）</li>
</ul>
</blockquote>
<h3 id="组件和样式复用">组件和样式复用</h3>
<p>和其他的前端项目一样，不同的EDM页面之间其实有<strong>相当大一部分的组件和样式是复用的</strong>，而现在的复用方式是原始的<strong>复制粘贴然后修改</strong>，这在编写和修改时都非常不便。</p>
<p>因此对EDM实现<strong>工程化管理</strong>是这里要讨论的重中之重，下面提出我的EDM框架方案（这里参考了MJML）：</p>
<blockquote>
<p>由于EDM重在单页面效果呈现，不存在像Vue或React这样的数据流管理和数据绑定需求，面向EDM的框架更应注重<strong>兼容性、样式管理和组件复用与微调</strong>这三个方面，主要特点在于：</p>
<ul>
<li>使用开发者熟悉的标签语法而尽量避免自创，降低上手成本</li>
<li><strong>外联样式表、类选择器复用和组件复用</strong>三大件保证了项目可维护性和可读性，提高了开发效率</li>
<li>编译器配合代码审查（工程化后更易实现审查和测试）保证了最终生成代码的一致性，最大程度地避免了代码冗余</li>
</ul>
</blockquote>
<ul>
<li>语法为<strong>现代HTML5网页语法的子集+部分语法补充</strong>，支持部分现代特性，编译后自动映射到<code>&lt;table&gt;</code>、<code>&lt;tr&gt;</code>和<code>&lt;td&gt;</code>标签，下面是一些例子：
<ul>
<li>使用<code>row-flex</code>的<code>&lt;div&gt;</code>标签映射成一个<code>&lt;tr&gt;</code>标签，其<code>align</code>等属性也会对应映射为单元格属性</li>
<li>使用<code>grid</code>实现的<code>&lt;div&gt;</code>标签映射成<code>&lt;table&gt;</code>和媒体查询的结合，自动生成不同场景下的表格，使用<code>display: none</code>切换（这些工作都会自动完成，编写时不用考虑）</li>
<li>普通流向的<code>&lt;div&gt;</code>则会被拆解成若干<code>&lt;tr&gt;</code>标签（最外层则会映射为<code>&lt;table&gt;</code>），直至显示元素本身被包裹在<code>&lt;td&gt;</code>标签中</li>
</ul>
</li>
<li>利用媒体查询，对于<strong>响应式设计</strong>应支持像素级的调整，以及针对指定屏幕大小的样式（如移动端单独设置字体），尽量避免需要编写两份雷同的HMTL代码的情况，以下是一些例子：
<ul>
<li>如需要定义某个组件在特定设备下的特定效果（如移动端的字体可能不同、组件间距或页边距不同），可以使用媒体查询给对应的class赋予特定样式（注意和上文中<code>grid</code>实现进行区分，这里主要作用是<strong>微调样式</strong>，虽然最后都会根据断点合并成一个<code>&lt;table&gt;</code>）</li>
<li>在编译时，编译器会根据断点数量（统计各处所有断点数量，因此尽量使用统一的断点，否则可能生成多于两份<code>&lt;table&gt;</code>）生成若干份不同的<code>&lt;table&gt;</code>，在每个<code>&lt;table&gt;</code>内实现独立的样式，并使用<code>display: none</code>切换</li>
<li>若必须为不同端编写不同页面，框架也提供了<code>&lt;responsive&gt;</code>语法糖
<ul>
<li>必须且只能接收至少一个<code>&lt;breakpoint&gt;</code>子标签，其他标签是非法的</li>
<li>子标签<code>&lt;breakpoint width=&quot;? px&quot;&gt;</code>接收任何流元素，<code>width</code>属性留空则默认为0，按顺序对应<code>(prev-breakpoint, width)</code>的范围，在编译时会对应映射到对应的<code>&lt;table&gt;</code>中</li>
<li>行为与定义多个<code>&lt;div&gt;</code>和对应class，并用媒体查询控制<code>display</code>属性是一致的</li>
</ul>
</li>
</ul>
</li>
<li>完整<strong>支持外联样式表和类选择器</strong>，支持样式表交叉管理（直接使用<code>&lt;link&gt;</code>标签管理），<strong>这里并不打算兼容ID选择器</strong>
<ul>
<li>支持完整的CSS层级系统（内联、<code>&lt;style&gt;</code>标签和<code>&lt;link&gt;</code>外联样式表）和优先级系统</li>
<li>Dev模式下查看效果无需编译，Prod模式下会根据优先级规则检查元素的所有样式和组件树，最终为每个元素生成一份无冗余的内联样式</li>
<li>对于不兼容的CSS样式，编译器应直接予以禁用和警告</li>
<li>支持断点定义语法糖防止重复生成断点<code>&lt;table&gt;</code>：使用<code>@value val</code>直接定义断点，在<code>@media</code>和HTML中的<code>&lt;breakpoint&gt;</code>标签中（需使用<code>&quot;&#123;@val&#125;&quot;</code>语法来定义CSS寻址）均可使用</li>
</ul>
</li>
<li>对于某些重复使用的组件，比如<code>logo-header</code>、<code>quiz</code>或<code>footer</code>等等，可以<strong>新增一些include相关语法</strong>如<code>&lt;component src=&quot;...&quot; /&gt;</code>来<strong>在HTML中引入组件化开发的特性</strong>，一方面避免了大量的复制粘贴，一方面可以做到一次修改全局应用（配合Git分支可以做到不同版本并行）
<ul>
<li>组件Wrapper标签<code>&lt;component&gt;</code>除了<code>src</code>属性还应支持<code>style</code>内联样式和<code>class</code>类选择器，来定义组件在页面内与其他组件的交互样式（如<code>padding</code>等）</li>
<li>无论在Dev模式还是Prod模式，编译器对<code>&lt;component&gt;</code>的行为都应是像C/C++预处理器那样进行文本替换，在Prod模式下还要做额外的内联样式计算</li>
</ul>
</li>
</ul>
<h3 id="项目管理和开发环境">项目管理和开发环境</h3>
<p>在现在的项目框架（单个HTML+原始内联复用）模式下，公司里采用按<strong>文件夹+文件名</strong>来组织EDM文件，虽然我个人更倾向于使用<strong>Git分支管理</strong>，即一个分支里包含需要使用的所有<strong>参考资料（可以复制修改的组件）</strong>，但这二者我个人觉得并没有什么本质上的区别和优劣之分。</p>
<p>但在新的EDM工程框架下，我认为Git版本管理是必须的：</p>
<ul>
<li>多人可能共享一份组件库和样式库，对于多人协作来说Git的版本和分支管理尤为必要</li>
<li>不同EDM可能会使用不同版本的组件，为了避免新建组件造成不必要的冗余，可以使用切换分支的方法</li>
<li>Git仓库可以设置Hook来实现Commit时的代码审查和兼容性检查</li>
</ul>
<h4 id="VSCode环境">VSCode环境</h4>
<p>由于框架还是提供了一些额外的标签语法和一些限制，暂且定义一种.edm的新格式，并用VSCode插件和NPM包来完善开发体验，最终生成一个可用的脚手架。</p>
<blockquote>
<p>这里参考了其他的前端项目的VSCode开发环境体验，个人认为MJML的VSCode开发体验还不够好。</p>
</blockquote>
<ul>
<li>VSCode插件功能（可能新开发，也可能基于已有插件）
<ul>
<li>代码Lint和Formatter：HTML自动缩进、标签对称修改、未闭合警告……</li>
<li>代码提示（IntelliSense）：标签提示、Boilerplate、路径提示……</li>
<li>实时侧栏预览和环境切换（搭配Node实现）</li>
</ul>
</li>
<li>Node功能：
<ul>
<li>编译器和开发环境（实时渲染）</li>
<li>Commit检查事件</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>email</tag>
        <tag>html</tag>
        <tag>css</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket 应用研究</title>
    <url>/posts/2808426581/</url>
    <content><![CDATA[<h2 id="了解WebSocket协议">了解WebSocket协议</h2>
<p>在 WebSocket 出现之前，如果我们想实现实时通信，比较常采用的方式是 Ajax 轮询，即在特定时间间隔（比如每秒）由浏览器发出请求，服务器返回最新的数据。这样做的问题有：</p>
<ul>
<li>HTTP头部重复信息较多，有效载荷少</li>
<li>服务器<strong>被动</strong>接收浏览器的请求然后响应，数据没有更新时仍然要接收并处理请求，导致服务器 CPU 占用</li>
</ul>
<p>WebSocket协议的出现解决了上述问题：</p>
<ul>
<li>WebSocket建立连接后不再发送HTTP头，WebSocket 的头部信息少，通常只有 2Bytes 左右，能节省带宽</li>
<li>WebSocket 支持服务端主动推送消息，更好地支持实时通信</li>
</ul>
<p>由于上述特点，WS广泛应用于<strong>视频弹幕、在线聊天、音视频通话、实时定位</strong>等场景。</p>
<blockquote>
<p>🌟WebSocket已经成为HTML5标准之一，被目前所有主流浏览器支持，内部提供<code>WebSocket()</code> API</p>
</blockquote>
<h3 id="通信原理解析">通信原理解析</h3>
<blockquote>
<p>WebSocket 是基于 TCP 的一种新的应用层网络协议。它实现了浏览器与服务器全双工通信，即允许服务器主动发送信息给客户端。因此，在 WebSocket 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输，客户端和服务器之间的数据交换变得更加简单。</p>
</blockquote>
<p>WebSocket的特点如下：</p>
<ul>
<li>握手时使用<strong>HTTP协议请求协议升级</strong>，握手成功后使用<strong>TCP</strong>直接通信</li>
<li><strong>独立</strong>的应用层协议，<strong>端口</strong>默认复用<strong>HTTP的80（ws）<strong>和</strong>HTTPS的443（wss）</strong></li>
<li><strong>全双工</strong>通信，双方都可以主动向对方推送信息</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230709002811.png"
                      alt="" title="WS对比HTTP"
                ></p>
<h4 id="建立连接">建立连接</h4>
<p>直接向WS服务器发送请求切换协议的报文（默认就是HTTP的端口，也可以指定端口）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230709002816.png"
                      alt=""
                ></p>
<ul>
<li>客户端请求包含<code>Connection: Upgrade</code> 表示要升级协议，以及<code>Upgrade: websocket</code>字段说明要切换到WS协议，以上报文创建工作由浏览器中的<code>WebSocket</code> 功能完成</li>
<li>服务器返回状态码101表示协议切换完成，可以进行全双工通信，在上方的“消息”可以查看</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230709002824.png"
                      alt=""
                ></p>
<h4 id="数据交换">数据交换</h4>
<blockquote>
<p>🚦需要注意的是，这些工作在实际使用时<strong>由服务端和浏览器自动完成，使用者不需要关心</strong>。</p>
</blockquote>
<p>WebSocket协议使用自己的帧（frame）结构传递信息，<strong>一条WS消息可能被分成若干WS帧进行发送，在接收端重新组装</strong>。</p>
<p>WS帧结构如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230709002931.png"
                      alt=""
                ></p>
<p>WS报文头和HTTP不同，不包括繁杂的Header信息，只包含基础的三项：</p>
<ul>
<li><code>FIN</code> 表示当前帧是否是当前消息的最后帧</li>
<li><code>opcode</code> 操作码，表示当前请求的类型
<ul>
<li>0x0，表示该帧是一个<strong>延续帧</strong>（这意味着服务器应该将帧的数据连接到从该客户端接收到的最后一个帧）；</li>
<li>0x1，传输数据是文本；</li>
<li>0x2，传输数据是二进制数据；</li>
<li>0x3-7：保留的操作代码，用于后续定义的非控制帧；</li>
<li>0x8：表示连接断开；</li>
<li>0x9：表示这是一个心跳请求（ping）；</li>
<li>0xA：表示这是一个心跳响应（pong）；</li>
<li>0xB-F：保留的操作代码，用于后续定义的控制帧；</li>
</ul>
</li>
<li><code>len</code> 表示载荷的长度</li>
</ul>
<h4 id="维持连接：心跳机制">维持连接：心跳机制</h4>
<p>由于WebSocket是全双工、保持连接的机制，我们需要通过一定手段来确定连接正常没有断开或者服务是否可用，这就是<strong>心跳机制</strong>。</p>
<p>可以看见，上面的操作码中定义了用于心跳请求和响应的位，可以通过<strong>定时发送</strong>对应数据包来确定让对方知道自己在线且正常工作，确保通信有效。如果对方无法响应，便可以弃用旧连接，发起新的连接了。</p>
<p>在JS中我们可以简单地用<code>setInterval()</code> 创建定时器发送消息即可。</p>
<h3 id="Node-js-实践">Node.js 实践</h3>
<p>通过用Node.js原生的<code>ws</code> 库实现一个基础的WebSocket聊天室，理解WebSocket在实际使用过程中的调用流程和抽象模型。</p>
<h4 id="创建服务端">创建服务端</h4>
<p>首先初始化一个项目，这里使用 <code>pnpm init</code> ，并安装依赖 <code>pnpm add ws</code>。</p>
<blockquote>
<p>这里基于个人爱好，我在<code>package.json</code> 中写入了 <code>&quot;type&quot;: &quot;module&quot;</code> 以启用ESM，如果你习惯使用CJS请留意代码中的导入部分。</p>
</blockquote>
<p>在写代码之前，我们先阅读ws的<a class="link"   href="https://github.com/websockets/ws/blob/HEAD/doc/ws.md"  title="文档">文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>和处理流程：</p>
<blockquote>
<p>🌟服务端使用 <code>WebSocketServer</code> 创建一个服务端实例，对于每个连接创建一个 <code>WebSocket</code> 实例，一个<code>WebSocketServer</code> 实例管理多个<code>WebSocket</code> 实例。<code>WebSocketServer</code>通过<code>connection</code> 事件与<code>WebSocket</code> 实例连接，每个<code>WebSocket</code> 实例对应实际的WS连接。</p>
</blockquote>
<ul>
<li>整个处理流程<strong>基于事件驱动</strong>，即<strong>在<code>connection</code>事件中获取当前连接的****<code>WebSocket</code>**** 实例并给它绑定对应的事件处理器</strong>
<ul>
<li><code>connection</code> ：连接事件，一切操作的起点，<strong>只有它绑定在Server上</strong>
<ul>
<li><code>socket</code> 参数可以获得当前连接的WebSocket实例</li>
<li><code>request</code> 参数可以获得当前连接请求的所有HTTP报文信息，如Origin、Cookie等</li>
</ul>
</li>
<li><code>message</code> ：接收到某个Socket传来的消息的事件，参数为<code>data</code> ，即消息的载荷，可以是文本、Buffer或二进制</li>
<li><code>close</code> ：服务关闭事件，<strong>由于WebSocket是全双工协议，在服务正式关闭时（任何一方</strong>**<code>close()</code>）双方都会收到关闭报文和对应事件**​</li>
</ul>
</li>
<li><code>WebSocketServer</code> 实例可以<strong>管理所有连接的Sockets</strong>（默认可以多连接），使用<code>clients</code> 属性获取与当前服务器连接的所有<code>WebSocket</code>实例 <strong>（可以用来实现广播）</strong></li>
<li><code>WebSocket</code> 实例对应了一个WebSocket连接，常用的API如下：
<ul>
<li><code>Event</code> 接口：一般包含了<code>type</code>, <code>data</code>, <code>target</code> 等属性可以调用
<ul>
<li><code>type</code> ：事件属性，如message, close, connection等</li>
<li><code>data</code>：有效载荷</li>
<li><code>target</code>：一般对应<code>WebSocket</code>实例</li>
</ul>
</li>
<li><code>url</code> 属性：目标WS服务器地址</li>
<li><code>send(data, [options], [callback])</code> 方法：向<strong>对方</strong>发送信息（服务端也可以调用）</li>
<li><code>close([ErrorCode], [data])</code> 方法：关闭连接</li>
</ul>
</li>
</ul>
<p>创建一个<strong>基础服务端</strong>和一个<strong>用于测试的客户端</strong>，代码如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">WebSocketServer</span>, <span class="title class_">WebSocket</span> &#125; <span class="keyword">from</span> <span class="string">&quot;ws&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> <span class="title class_">WebSocketServer</span>(&#123; <span class="attr">port</span>: <span class="number">4567</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">broadcast</span>(<span class="params">msg, user, source</span>) &#123;</span><br><span class="line">  server.<span class="property">clients</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">client</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (client.<span class="property">readyState</span> === <span class="title class_">WebSocket</span>.<span class="property">OPEN</span> &amp;&amp; client !== source) &#123;</span><br><span class="line">      client.<span class="title function_">send</span>(<span class="string">`[<span class="subst">$&#123;user&#125;</span>] <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="function">(<span class="params">socket, req</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> user = req.<span class="property">headers</span>.<span class="property">origin</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[Server] connected: <span class="subst">$&#123;user&#125;</span>`</span>);</span><br><span class="line">  socket.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`From <span class="subst">$&#123;user&#125;</span>: <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">    socket.<span class="title function_">send</span>(<span class="string">`[Echo] You sent -&gt; <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">    <span class="title function_">broadcast</span>(msg, user, socket);</span><br><span class="line">    <span class="keyword">if</span> (msg === <span class="string">&#x27;bye&#x27;</span>) &#123;</span><br><span class="line">      socket.<span class="title function_">close</span>(<span class="number">0</span>, <span class="string">&quot;Bye&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  socket.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">(<span class="params">code, reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[Server] Connection closed with code: <span class="subst">$&#123;code&#125;</span> for <span class="subst">$&#123;reason&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket Server started at port 4567...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// client.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">WebSocket</span> &#125; <span class="keyword">from</span> <span class="string">&quot;ws&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:4567&#x27;</span>, &#123; <span class="attr">origin</span>: ((<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">10</span>).<span class="title function_">toFixed</span>(<span class="number">0</span>)).<span class="title function_">toString</span>() &#125;);</span><br><span class="line"></span><br><span class="line">socket.<span class="title function_">addEventListener</span>(<span class="string">&#x27;open&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Connected to server: <span class="subst">$&#123;e.target.url&#125;</span>`</span>)</span><br><span class="line">  socket.<span class="title function_">send</span>(<span class="string">&#x27;Hello Server from NodeJS Client!&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">socket.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// e.type=事件类型，open|message|close</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">socket.<span class="title function_">addEventListener</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Type=<span class="subst">$&#123;e.type&#125;</span>\nCode=<span class="subst">$&#123;e.code&#125;</span>\nReason=<span class="subst">$&#123;e.reason&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  socket.<span class="title function_">send</span>(count++);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>可以看到，在上面的代码中我们利用<code>clients</code> 属性手写实现了<strong>广播</strong>功能，所谓WS“不提供”的功能，这里我们能窥见一点WebSocket的本质属性——它只是一种服务协议，提供了一种全双工的沟通方式，而上层的调用和实现、需要什么功能则完全由开发者决定，就像HTTP一样是一种“基础设施”。</p>
<p>运行效果如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230709002940.png"
                      alt=""
                ></p>
<h4 id="创建前端页面">创建前端页面</h4>
<p>首先使用<code>pnpm create vite</code> 创建一个SPW应用，这里使用React+Typescript+SWC的方案，你也可以根据自己的喜好选择。然后按照流程<code>pnpm install</code> 安装依赖、<code>pnpm run dev</code>启动开发服务器。</p>
<h5 id="手写WebSocket">手写WebSocket</h5>
<p>我们使用上面写的服务端作为WebSocket服务器，改写<code>./src/App.tsx</code>，代码如下：</p>
<div class="highlight-container" data-rel="Tsx"><figure class="iseeu highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useMemo, useRef, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./App.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ws = useRef&lt;<span class="title class_">WebSocket</span> | <span class="literal">null</span>&gt;(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> [connected, setConnected] = useState&lt;<span class="built_in">boolean</span>&gt;(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [host, setHost] = useState&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;localhost:4567&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [send, setSend] = useState&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [messages, setMessages] = useState&lt;&#123;</span><br><span class="line">    <span class="attr">category</span>: <span class="string">&#x27;message&#x27;</span> | <span class="string">&#x27;error&#x27;</span> | <span class="string">&#x27;info&#x27;</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="built_in">string</span></span><br><span class="line">  &#125;[]&gt;([]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleConnect</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ws.<span class="property">current</span> &amp;&amp; ws.<span class="property">current</span>.<span class="property">readyState</span> === <span class="title class_">WebSocket</span>.<span class="property">OPEN</span>) &#123; </span><br><span class="line">      messages.<span class="title function_">push</span>(&#123;<span class="attr">category</span>: <span class="string">&#x27;info&#x27;</span>, <span class="attr">message</span>: <span class="string">&#x27;Already connected!&#x27;</span>&#125;);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ws.<span class="property">current</span> = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://&#x27;</span> + host);</span><br><span class="line">    ws.<span class="property">current</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;open&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      messages.<span class="title function_">push</span>(&#123;<span class="attr">category</span>: <span class="string">&#x27;info&#x27;</span>, <span class="attr">message</span>: <span class="string">&#x27;Connected to &#x27;</span> + ws.<span class="property">current</span>!.<span class="property">url</span>&#125;);</span><br><span class="line">      <span class="title function_">setMessages</span>([...messages])</span><br><span class="line">      <span class="title function_">setConnected</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    ws.<span class="property">current</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      messages.<span class="title function_">push</span>(&#123;<span class="attr">category</span>: <span class="string">&#x27;message&#x27;</span>, <span class="attr">message</span>: event.<span class="property">data</span> <span class="keyword">as</span> <span class="built_in">string</span>&#125;);</span><br><span class="line">      <span class="title function_">setMessages</span>([...messages])</span><br><span class="line">    &#125;);</span><br><span class="line">    ws.<span class="property">current</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      messages.<span class="title function_">push</span>(&#123;<span class="attr">category</span>: <span class="string">&#x27;info&#x27;</span>, <span class="attr">message</span>: <span class="string">&#x27;Disconnected from &#x27;</span> + ws.<span class="property">current</span>!.<span class="property">url</span>&#125;);</span><br><span class="line">      <span class="title function_">setMessages</span>([...messages])</span><br><span class="line">    &#125;);</span><br><span class="line">    ws.<span class="property">current</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      messages.<span class="title function_">push</span>(&#123; <span class="attr">category</span>: <span class="string">&#x27;error&#x27;</span>, <span class="attr">message</span>: <span class="string">&#x27;Error Connection&#x27;</span> &#125;);</span><br><span class="line">      <span class="title function_">setMessages</span>([...messages])</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleDisconnect</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ws.<span class="property">current</span> &amp;&amp; ws.<span class="property">current</span>.<span class="property">readyState</span> === <span class="title class_">WebSocket</span>.<span class="property">OPEN</span>) &#123;</span><br><span class="line">      ws.<span class="property">current</span>.<span class="title function_">close</span>();</span><br><span class="line">      <span class="title function_">setMessages</span>([]);</span><br><span class="line">      <span class="title function_">setConnected</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleSendMessage</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ws.<span class="property">current</span> &amp;&amp; ws.<span class="property">current</span>.<span class="property">readyState</span> === <span class="title class_">WebSocket</span>.<span class="property">OPEN</span>) &#123;</span><br><span class="line">      ws.<span class="property">current</span>.<span class="title function_">send</span>(send);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> texts = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> messages.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; category, message &#125;, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;category&#125;</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;`[$&#123;category.toUpperCase()&#125;] $&#123;message&#125;`&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [messages])</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">handleDisconnect</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;flex-container&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;host&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> setHost(e.target.value)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">disabled</span>=<span class="string">&#123;connected&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;handleConnect&#125;</span>&gt;</span>Connect<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">disabled</span>=<span class="string">&#123;!connected&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;handleDisconnect&#125;</span>&gt;</span>Disconnect<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;</span></span><br><span class="line"><span class="language-xml">        connected &amp;&amp;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;flex-container sender&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;send&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> &#123;setSend(e.target?.value)&#125;&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleSendMessage&#125;</span>&gt;</span>Send<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setMessages([])&#125;&gt;Clear<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#125;      </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;log-div&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;texts&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span></span><br></pre></td></tr></table></figure></div>
<p>部分CSS样式如下：</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">gap</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.log-div</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: aliceblue;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">  <span class="attribute">overflow-x</span>: hidden;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.log-div</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.log-div</span> <span class="selector-class">.info</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#888</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.log-div</span> <span class="selector-class">.error</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff0000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sender</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sender</span> <span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>从代码中我们可以看到我们使用了<code>ref</code> 管理WS实例（不会随视图渲染改变的变量），并使用几个<code>state</code> 来管理消息列表、连接状态和输入框缓存，最后将连接和发送操作封装为可调用的方法。</p>
<p>最终效果如下图所示，可以看到尽管来自同一域名，我们的WebSocket服务器也能区分不同会话。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230709002946.png"
                      alt=""
                ></p>
<h5 id="使用react-use-websocket">使用<code>react-use-websocket</code></h5>
<p>在上面的开发过程中我们可以发现，建立WebSocket连接其实是一个可以抽象的逻辑，以供重复调用，在React中也就是抽象为一个Hook，每次需要用到WebSocket的时候就调用这个Hook。</p>
<p>这里我们使用一个名为<code>react-use-websocket</code>的npm包，先安装它 <code>pnpm add react-use-websocket</code> （如果你使用React17及以下请安装3.0.0版本）。使用封装好的包的好处是节省开发时间和提供更健壮和全面的封装，避免自己开发时没有考虑到的边界情况引发的Bugs（但不是绝对的）。</p>
<p><code>react-use-websocket</code> 提供的API如下（Copy自官方文档），可以看到它直接为我们封装好了一系列的行为（如<strong>心跳重连</strong>、JSON封装等），将基础的<code>ReadyState</code>属性、<code>send</code> 操作等暴露了出来：</p>
<div class="highlight-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UseWebSocket</span> = (</span><br><span class="line">  <span class="comment">//Url can be return value of a memoized async function.</span></span><br><span class="line">  <span class="attr">url</span>: <span class="built_in">string</span> | <span class="function">() =&gt;</span> <span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt;,</span><br><span class="line">  <span class="attr">options</span>: &#123;</span><br><span class="line">    fromSocketIO?: <span class="built_in">boolean</span>;</span><br><span class="line">    queryParams?: &#123; [<span class="attr">field</span>: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125;;</span><br><span class="line">    protocols?: <span class="built_in">string</span> | <span class="built_in">string</span>[];</span><br><span class="line">    share?: <span class="built_in">boolean</span>;</span><br><span class="line">    onOpen?: <span class="function">(<span class="params">event: WebSocketEventMap[<span class="string">&#x27;open&#x27;</span>]</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">    onClose?: <span class="function">(<span class="params">event: WebSocketEventMap[<span class="string">&#x27;close&#x27;</span>]</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">    onMessage?: <span class="function">(<span class="params">event: WebSocketEventMap[<span class="string">&#x27;message&#x27;</span>]</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">    onError?: <span class="function">(<span class="params">event: WebSocketEventMap[<span class="string">&#x27;error&#x27;</span>]</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">    onReconnectStop?: <span class="function">(<span class="params">numAttempts: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">    shouldReconnect?: <span class="function">(<span class="params">event: WebSocketEventMap[<span class="string">&#x27;close&#x27;</span>]</span>) =&gt;</span> <span class="built_in">boolean</span>;</span><br><span class="line">    reconnectInterval?: <span class="built_in">number</span> | (<span class="function">(<span class="params">lastAttemptNumber: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>);</span><br><span class="line">    reconnectAttempts?: <span class="built_in">number</span>;</span><br><span class="line">    filter?: <span class="function">(<span class="params">message: WebSocketEventMap[<span class="string">&#x27;message&#x27;</span>]</span>) =&gt;</span> <span class="built_in">boolean</span>;</span><br><span class="line">    retryOnError?: <span class="built_in">boolean</span>;</span><br><span class="line">    eventSourceOptions?: <span class="title class_">EventSourceInit</span>;</span><br><span class="line">  &#125; = &#123;&#125;,</span><br><span class="line">  <span class="attr">shouldConnect</span>: <span class="built_in">boolean</span> = <span class="literal">true</span>,</span><br><span class="line">): &#123;</span><br><span class="line">  <span class="attr">sendMessage</span>: <span class="function">(<span class="params">message: <span class="built_in">string</span>, keep: <span class="built_in">boolean</span> = <span class="literal">true</span></span>) =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">  <span class="comment">//jsonMessage must be JSON-parsable</span></span><br><span class="line">  <span class="attr">sendJsonMessage</span>: <span class="function">(<span class="params">jsonMessage: JsonValue, keep: <span class="built_in">boolean</span> = <span class="literal">true</span></span>) =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">  <span class="comment">//null before first received message</span></span><br><span class="line">  <span class="attr">lastMessage</span>: <span class="title class_">WebSocketEventMap</span>[<span class="string">&#x27;message&#x27;</span>] | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">//null before first received message. If message.data is not JSON parsable, then this will be a static empty object</span></span><br><span class="line">  <span class="attr">lastJsonMessage</span>: <span class="title class_">JsonValue</span> | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// -1 if uninstantiated, otherwise follows WebSocket readyState mapping: 0: &#x27;Connecting&#x27;, 1 &#x27;OPEN&#x27;, 2: &#x27;CLOSING&#x27;, 3: &#x27;CLOSED&#x27;</span></span><br><span class="line">  <span class="attr">readyState</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="comment">// If using a shared websocket, return value will be a proxy-wrapped websocket, with certain properties/methods protected</span></span><br><span class="line">  <span class="attr">getWebSocket</span>: <span class="function">() =&gt;</span> (<span class="title class_">WebSocketLike</span> | <span class="literal">null</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>使用<code>react-use-websocket</code> 改写后的代码如下：</p>
<div class="highlight-container" data-rel="Tsx"><figure class="iseeu highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useMemo, useRef, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> useWebSocket <span class="keyword">from</span> <span class="string">&#x27;react-use-websocket&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./App.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">WebSocketLike</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-use-websocket/dist/lib/types&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ws = useRef&lt;<span class="title class_">WebSocketLike</span> | <span class="literal">null</span>&gt;(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> senderRef = useRef&lt;<span class="title class_">HTMLInputElement</span>&gt;(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> [shouldConnect, setShouldConnect] = useState&lt;<span class="built_in">boolean</span>&gt;(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [host, setHost] = useState&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;localhost:4567&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [messages, setMessages] = useState&lt;&#123;</span><br><span class="line">    <span class="attr">category</span>: <span class="string">&#x27;message&#x27;</span> | <span class="string">&#x27;error&#x27;</span> | <span class="string">&#x27;info&#x27;</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="built_in">string</span></span><br><span class="line">  &#125;[]&gt;([]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    sendMessage,</span><br><span class="line">    lastMessage,</span><br><span class="line">    readyState,</span><br><span class="line">    getWebSocket,</span><br><span class="line">  &#125; = <span class="title function_">useWebSocket</span>(<span class="string">&quot;ws://&quot;</span>+host, &#123;</span><br><span class="line">    <span class="attr">onOpen</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      ws.<span class="property">current</span> = <span class="title function_">getWebSocket</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">shouldReconnect</span>: <span class="function">() =&gt;</span> shouldConnect,</span><br><span class="line">  &#125;, shouldConnect);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> connected = readyState === <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lastMessage) &#123;</span><br><span class="line">      <span class="comment">// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment</span></span><br><span class="line">      <span class="keyword">const</span> &#123; data &#125; = lastMessage</span><br><span class="line">      <span class="title function_">setMessages</span>(<span class="function">(<span class="params">prev</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [...prev, &#123; <span class="attr">category</span>: <span class="string">&#x27;message&#x27;</span>, <span class="attr">message</span>: data <span class="keyword">as</span> <span class="built_in">string</span> &#125;]</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [lastMessage])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> texts = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> messages.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; category, message &#125;, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;category&#125;</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;`[$&#123;category.toUpperCase()&#125;] $&#123;message&#125;`&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [messages])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleConnect</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setShouldConnect</span>(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleDisconnect</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ws.<span class="property">current</span>) &#123;</span><br><span class="line">      ws.<span class="property">current</span>.<span class="title function_">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">handleDisconnect</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;flex-container&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;host&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> setHost(e.target.value)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">disabled</span>=<span class="string">&#123;connected&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;handleConnect&#125;</span>&gt;</span>Connect<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">disabled</span>=<span class="string">&#123;!connected&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;handleDisconnect&#125;</span>&gt;</span>Disconnect<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;</span></span><br><span class="line"><span class="language-xml">        connected &amp;&amp;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;flex-container sender&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;senderRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">              if (senderRef.current) &#123;</span></span><br><span class="line"><span class="language-xml">                sendMessage(senderRef.current.value);</span></span><br><span class="line"><span class="language-xml">                senderRef.current.value = &#x27;&#x27;;</span></span><br><span class="line"><span class="language-xml">              &#125;</span></span><br><span class="line"><span class="language-xml">            &#125;&#125;&gt;Send<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#125;      </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;log-div&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;texts&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>可以看到，我们使用了<code>react-use-websocket</code> 后由于用其暴露的属性进行了逻辑重写，包括使用<code>useEffect</code> 来更新消息队列、直接使用<code>sendMessage()</code> 来发送消息以及直接使用<code>readyState</code> 来判断连接状态。相较于之前的实现，封装后的代码显然减小了重复代码量。</p>
<p>需要注意的是，由于该Hook将WebSocket实例封装在了内部，外部采用状态驱动的函数式形式，因此无法通过新建实例的方式对同一WS地址进行断开和重连（即手动控制连接状态），只能依赖以下两种方式：</p>
<ul>
<li>将<code>shouldConnect</code> 和<code>shouldReconnect</code> 绑定到一个外部的<code>connect</code> 状态中，<strong>等待重连来重新建立连接</strong>（上面代码的方法）</li>
<li>通过刷新输入Hook的<code>url</code> 参数可以做到<strong>立刻新建<code>WebSocket</code>实例并重连（推荐）</strong>，实践中可以在重连后立刻清空状态，等待用户重新输入</li>
<li>如果不需要用户控制连接，后台维护连接的话就不需要将<code>connect</code> 操作暴露给用户</li>
</ul>
<h4 id="使用WebSocket传输文件">使用WebSocket传输文件</h4>
<p>WebSocket中使用ArrayBuffer传输文件，在<code>react-use-websocket</code>中直接将文件用<code>sendMessage()</code> 传输出去即可，<code>ws</code> 接收到的参数中<code>isBin</code> 就是<code>true</code> ，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230709002953.png"
                      alt=""
                ></p>
<p>因此，使用ArrayBuffer传输文件的方案有下：</p>
<ul>
<li>直接传输文件，WebSocket可以接收<code>Blob</code> 对象（<code>File</code> 是<code>Blob</code> 的子类）进行传输</li>
<li>使用JSON包装后传输，这时需要将文件手动读取为ArrayBuffer传输</li>
<li>高级操作：<strong>在服务端读取已传输字节数和总长度，返回传输百分比</strong></li>
</ul>
<h2 id="socket-io-库"><a class="link"   href="http://socket.io" >socket.io <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 库</h2>
<blockquote>
<p>🚦<a class="link"   href="http://Socket.IO"  title="Socket.IO">Socket.IO <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> <strong>不是</strong> WebSocket实现。尽管它<strong>尽可能使用 WebSocket 作为传输协议</strong>，但它一方面<strong>可能回退到其他传输方式（如Ajax轮询）</strong>，另一方面其<strong>每条消息都被附上了额外的数据来实现自身逻辑，如轮询回退、自动重连等</strong>。<br>
这就是<strong>为什么 WebSocket 客户端将无法成功连接到 <strong><a href="http://Socket.IO" title="Socket.IO"><strong>Socket.IO</strong></a></strong> 服务器，而 <strong><a href="http://Socket.IO" title="Socket.IO"><strong>Socket.IO</strong></a></strong> 客户端也将无法连接到普通 WebSocket 服务器</strong>，虽然Socket.io的传输协议使用了WebSocket，但它们在接口上并不是兼容的。</p>
</blockquote>
<p><a class="link"   href="http://Socket.IO"  title="Socket.IO">Socket.IO <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 是一个多语言、跨平台的库，可以在客户端和服务器之间实现 <strong>低延迟</strong>, <strong>双向</strong> 和 <strong>基于事件的</strong> 通信。通常情况下，它建立在 <a class="link"   href="https://fr.wikipedia.org/wiki/WebSocket"  title="WebSocket">WebSocket <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 协议之上，并提供额外的保证，例如回退到 HTTP 长轮询或自动重新连接。它提供以下额外特性：</p>
<ul>
<li>HTTP 长轮询回退：如果无法建立 WebSocket 连接，连接将回退到 HTTP 长轮询</li>
<li>自动重新连接：<a class="link"   href="http://Socket.IO"  title="Socket.IO">Socket.IO <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 包含一个<strong>心跳机制</strong>，它会定期检查连接的状态</li>
<li>数据包缓冲：当客户端断开连接时，数据包会自动缓冲，并在重新连接时发送</li>
<li>广播和多路复用
<ul>
<li>服务器端可以通过<strong>广播向所有客户端或特定子集</strong>发送信息</li>
<li>多路复用：通过<strong>命名空间</strong>机制使用<strong>单个连接拆分出多个信道</strong><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230709002958.png"
                      alt=""
                ></li>
</ul>
</li>
</ul>
<h3 id="工作原理">工作原理</h3>
<p>socket.io默认工作在WebSocket上，在轮询模式中则回退到HTTP，但其报文内容是一致的。socket.io通过在报文负载中附上额外信息来确保自身额外功能的实现。</p>
<p>如<code>socket.emit(&quot;hello&quot;, &quot;world&quot;)</code> 将作为单个 WebSocket 帧发送，其中包含<code>42[&quot;hello&quot;,&quot;world&quot;]</code>：</p>
<ul>
<li><code>4</code> 是 <a class="link"   href="http://Engine.IO"  title="Engine.IO">Engine.IO <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> “消息”数据包类型</li>
<li><code>2</code> 是 <a class="link"   href="http://Socket.IO"  title="Socket.IO">Socket.IO <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> “消息”数据包类型</li>
<li><code>[&quot;hello&quot;,&quot;world&quot;]</code>是参数数组被<code>JSON.stringify()</code>过的版本</li>
</ul>
<p>你可能注意到了上面有engine.io和socket.io两种不同的数据包类型标识符，这<strong><a class="link"   href="http://xn--Socket-2e8i713gsgf.io" >对应了Socket.io <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 两个不同的层</strong>：</p>
<ul>
<li>底层通道 <a class="link"   href="http://Engine.IO" >Engine.IO <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>：<strong>负责建立服务器和客户端之间的低级连接</strong>，如WebSocket连接、轮询回退、断线检测（心跳机制）等，<strong>向上提供一个全双工连接的抽象</strong>
<ul>
<li><strong>默认使用HTTP长轮询建立连接，后续尝试升级协议为WebSocket</strong>
<ul>
<li>HTTP 长轮询：由连续的 HTTP 请求组成，WebSocket的回退策略
<ul>
<li>长时间运行的 <code>GET</code> 请求，用于从服务器接收数据</li>
<li>短时 <code>POST</code> 请求，用于向服务器发送数据</li>
</ul>
</li>
<li>WebSocket 传输：由WebSocket 连接组成，它在服务器和客户端之间提供双向和低延迟的通信通道</li>
</ul>
</li>
<li>向下实现可交付保证，<strong>向上屏蔽通讯实现细节，并提供上层功能所需的API</strong>（如拓展的事件体系）</li>
</ul>
</li>
<li><a class="link"   href="http://xn--Socket-9o7ik76gyqa5476a.IO" >上层封装Socket.IO <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>：在Engine.IO建立连接后添加<strong>面向用户的附加功能</strong>，如自动重连、多路复用等</li>
</ul>
<h4 id="Socket-实例"><code>Socket</code> 实例</h4>
<p>这里的Socket概念和WebSocket类似，对应一个连接，其具有以下额外属性：</p>
<ul>
<li><code>id</code> 属性：每个新连接都分配有一个随机的 20 个字符的标识符</li>
<li><code>handshake</code> 属性：握手信息</li>
<li><code>conn</code> 属性：底层连接信息</li>
</ul>
<h5 id="房间">房间</h5>
<p>房间是在<strong>服务器端可见的客户端的集合</strong>，它包含一个或多个客户端。</p>
<ul>
<li>每个Socket创建后会加入由<strong>其自己的 id 标识的房间</strong>，这意味着您可以将其用于私人消息传递</li>
<li><code>socket.rooms()</code> 可以查看当前Socket所在房间的集合</li>
<li><code>socket.join(roomName: string)</code> 可以使socket加入某个房间</li>
<li><code>io.to(room).emit(event, ...args)</code> 可以<strong>向房间内所有客户端广播事件</strong>
<ul>
<li><code>to()</code> 支持级联，同时向多个房间发送</li>
<li>若从<code>socket</code> 发送广播，则除了发送者外房间内所有客户端都会收到广播</li>
</ul>
</li>
</ul>
<h5 id="中间件">中间件</h5>
<p>中间件函数是为每个传入连接执行的函数，Socket.io里的中间件和其他地方的中间件含义是相同的，通常用于登录检测等领域。</p>
<h4 id="消息类型与事件处理">消息类型与事件处理</h4>
<blockquote>
<p><a class="link"   href="http://Socket.IO"  title="Socket.IO">Socket.IO <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> API 的灵感来自 Node.js EventEmitter，这意味着您可以在一侧发出事件并在另一侧注册侦听器</p>
</blockquote>
<p>和普通的WebSocket一样，Socket.io也是<strong>基于事件驱动的双工通讯</strong></p>
<ul>
<li><code>io.on('connection', (socket) ⇒ &#123;...&#125;)</code> 是服务端<strong>一切事件的起点</strong>，需要在回调中给每个socket绑定事件</li>
<li><code>socket.on(event: string, callback: (...args) ⇒ void)</code> 是<strong>对Socket连接注册事件监听</strong>的方法
<ul>
<li><code>socket.once()</code> 是签名和<code>on()</code> 相同的<strong>一次性监听函数</strong></li>
<li><code>socket.onAny(listener)</code> 可用于<strong>监听任意事件</strong></li>
<li><code>disconnect</code> 和 <code>disconnecting</code> ：在服务端发出的特殊事件，Socket 实例在断开连接时触发，<code>payload</code> 为断开原因</li>
<li><code>event</code> 是<strong>可以自定义的</strong>，只要不覆盖任何现有事件就可以是任何类型的字段，这<strong>对应了原版WebSocket的<code>type</code>字段</strong>，但不同之处是原版WebSocket中只能使用<code>send()</code> 方法，<code>type</code> 固定为<code>message</code> ，但<strong>这里是可以完全自定义的</strong></li>
</ul>
</li>
<li><code>socket.off(event: string)</code> 用于移除指定监听器</li>
<li><code>socket.emit(event: string, ...args: any)</code> 是<strong>向对方发送事件</strong>的方法
<ul>
<li><code>socket.send(..args)</code> 方法仍是支持的，将发送一个默认的<code>message</code> 事件</li>
<li>可以发送任意数量的参数，并且<strong>支持所有可序列化的数据结构</strong>，<strong>包括像Buffer 或 TypedArray这样的二进制对象</strong>，并且<strong>无需<code>JSON.stringify()</code>，因为它会为您完成</strong></li>
<li>可以在<code>emit</code> 中添加回调，只需要把最后一个参数设为回调函数，在服务端进行调用即可</li>
</ul>
</li>
</ul>
<h4 id="广播事件">广播事件</h4>
<ul>
<li><code>socket.broadcast.emit(event, ...args)</code> 会向<strong>除发送者外的所有客户端</strong>发送消息</li>
</ul>
<h4 id="命名空间和多路复用">命名空间和多路复用</h4>
<blockquote>
<p>🚦待完成</p>
</blockquote>
<h3 id="Node-js-实践-2">Node.js 实践</h3>
<h4 id="创建后端服务器">创建后端服务器</h4>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Server</span> &#125; <span class="keyword">from</span> <span class="string">&quot;socket.io&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> io = <span class="keyword">new</span> <span class="title class_">Server</span>(&#123;</span><br><span class="line">  <span class="attr">cors</span>: <span class="string">&#x27;http://127.0.0.1:5173/&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> progress = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">io.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[Server] Connection established with <span class="subst">$&#123;socket.id&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟进度</span></span><br><span class="line">  <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (progress &lt; <span class="number">100</span>) &#123;</span><br><span class="line">      socket.<span class="title function_">emit</span>(<span class="string">&quot;progress&quot;</span>, progress);</span><br><span class="line">      socket.<span class="title function_">send</span>(<span class="string">`<span class="subst">$&#123;progress&#125;</span>% 这是一条模拟日志`</span>);</span><br><span class="line">      progress++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      socket.<span class="title function_">emit</span>(<span class="string">&quot;progress&quot;</span>, progress);</span><br><span class="line">      socket.<span class="title function_">send</span>(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">      progress = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">      socket.<span class="title function_">disconnect</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 基础回声</span></span><br><span class="line">  socket.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[Message] <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">    socket.<span class="title function_">send</span>(<span class="string">`[Echo] You sent -&gt; <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断开连接</span></span><br><span class="line">  socket.<span class="title function_">on</span>(<span class="string">&#x27;disconnect&#x27;</span>, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">    progress = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[Server] Connection with <span class="subst">$&#123;socket.id&#125;</span> closed with <span class="subst">$&#123;reason&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">io.<span class="title function_">listen</span>(<span class="number">4567</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>在这个例子中我使用自定义事件<code>progress</code> 模拟了一个后台进程向前端输出日志和进度的过程。</p>
<blockquote>
<p>🌟需要注意的是，在前后端分离的情况下我们需要手动指定跨域，就像上面的<code>cors: 'http://127.0.0.1:5173/',</code> 一样</p>
</blockquote>
<h4 id="修改前端页面">修改前端页面</h4>
<p>这里我们沿用上一个WebSocket的例子，先安装依赖 <code>pnpm add socket.io-client</code> 。</p>
<p>直接抽象出一个<code>useSocket</code> Hook进行封装：</p>
<div class="highlight-container" data-rel="Tsx"><figure class="iseeu highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// useSocket.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable react-hooks/exhaustive-deps */</span></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect, useRef, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; io &#125; <span class="keyword">from</span> <span class="string">&quot;socket.io-client&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">useSocket</span>(<span class="params">url: <span class="built_in">string</span>, autoConnect=<span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> socket = <span class="title function_">useRef</span>(<span class="title function_">io</span>(url, &#123; autoConnect &#125;));</span><br><span class="line">  <span class="keyword">const</span> [isConnected, setIsConnected] = <span class="title function_">useState</span>(socket.<span class="property">current</span>.<span class="property">connected</span>);</span><br><span class="line">  <span class="keyword">const</span> [latestMessage, setLatestMessage] = useState&lt;<span class="built_in">unknown</span>&gt;(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> [progress, setProgress] = useState&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    socket.<span class="property">current</span>.<span class="title function_">on</span>(<span class="string">&quot;connect&quot;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">      <span class="title function_">setIsConnected</span>(<span class="literal">true</span>);</span><br><span class="line">      <span class="title function_">setLatestMessage</span>(<span class="string">&#x27;Connected!&#x27;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">    socket.<span class="property">current</span>.<span class="title function_">on</span>(<span class="string">&quot;disconnect&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setIsConnected</span>(<span class="literal">false</span>);</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&#x27;Disconnected!&#x27;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">    socket.<span class="property">current</span>.<span class="title function_">on</span>(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setLatestMessage</span>(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>: <span class="subst">$&#123;data <span class="keyword">as</span> <span class="built_in">string</span>&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    socket.<span class="property">current</span>.<span class="title function_">on</span>(<span class="string">&quot;progress&quot;</span>, <span class="function">(<span class="params">progress: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setProgress</span>(progress);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      socket.<span class="property">current</span>.<span class="title function_">off</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">      socket.<span class="property">current</span>.<span class="title function_">off</span>(<span class="string">&quot;disconnect&quot;</span>);</span><br><span class="line">      socket.<span class="property">current</span>.<span class="title function_">off</span>(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">      socket.<span class="property">current</span>.<span class="title function_">off</span>(<span class="string">&quot;progress&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleSendMessage</span> = (<span class="params">message: <span class="built_in">string</span></span>) =&gt; &#123; </span><br><span class="line">    socket.<span class="property">current</span>.<span class="title function_">send</span>(message);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; isConnected, latestMessage, progress, <span class="attr">sendMessage</span>: handleSendMessage, <span class="attr">socket</span>: socket.<span class="property">current</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// App.tsx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; useCallback, useEffect, useMemo, useRef, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./App.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> useSocket <span class="keyword">from</span> <span class="string">&#x27;./useSocket&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inputTypes = [<span class="string">&#x27;text&#x27;</span>, <span class="string">&#x27;file&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="keyword">const</span> senderRef = useRef&lt;<span class="title class_">HTMLInputElement</span>&gt;(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [inputType, setInputType] = useState&lt;<span class="built_in">string</span>&gt;(inputTypes[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [host, setHost] = useState&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;localhost:4567&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; isConnected, latestMessage, progress, socket, sendMessage &#125; = <span class="title function_">useSocket</span>(<span class="string">&quot;http://&quot;</span> + host);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [messages, setMessages] = useState&lt;&#123;</span><br><span class="line">    <span class="attr">category</span>: <span class="string">&#x27;message&#x27;</span> | <span class="string">&#x27;error&#x27;</span> | <span class="string">&#x27;info&#x27;</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="built_in">string</span></span><br><span class="line">  &#125;[]&gt;([]);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (latestMessage) &#123;</span><br><span class="line">      <span class="comment">// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment</span></span><br><span class="line">      <span class="title function_">setMessages</span>(<span class="function">(<span class="params">prev</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [...prev, &#123; <span class="attr">category</span>: <span class="string">&#x27;message&#x27;</span>, <span class="attr">message</span>: latestMessage <span class="keyword">as</span> <span class="built_in">string</span> &#125;]</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [latestMessage])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> texts = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> messages.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; category, message &#125;, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;category&#125;</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;`[$&#123;category.toUpperCase()&#125;] $&#123;message&#125;`&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [messages])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleConnect</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    socket.<span class="title function_">connect</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleDisconnect = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    socket.<span class="title function_">disconnect</span>();</span><br><span class="line">  &#125;, [socket])</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">handleDisconnect</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [handleDisconnect])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;flex-container&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;host&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> setHost(e.target.value)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">disabled</span>=<span class="string">&#123;isConnected&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;handleConnect&#125;</span>&gt;</span>Connect<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">disabled</span>=<span class="string">&#123;!isConnected&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;handleDisconnect&#125;</span>&gt;</span>Disconnect<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;</span></span><br><span class="line"><span class="language-xml">        isConnected &amp;&amp;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;flex-container sender&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">select</span> <span class="attr">value</span>=<span class="string">&#123;inputType&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> &#123;setInputType(e.target.value)&#125;&#125;&gt;</span></span><br><span class="line"><span class="language-xml">              &#123;inputTypes.map((type, index) =&gt; &#123; </span></span><br><span class="line"><span class="language-xml">                return <span class="tag">&lt;<span class="name">option</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">value</span>=<span class="string">&#123;type&#125;</span>&gt;</span>&#123;type&#125;<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;progress&#125;%<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#123;inputType&#125;</span> <span class="attr">ref</span>=<span class="string">&#123;senderRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">              if (senderRef.current) &#123;</span></span><br><span class="line"><span class="language-xml">                if (inputType === &#x27;text&#x27;) sendMessage(senderRef.current.value);</span></span><br><span class="line"><span class="language-xml">                senderRef.current.value = &#x27;&#x27;;</span></span><br><span class="line"><span class="language-xml">              &#125;</span></span><br><span class="line"><span class="language-xml">            &#125;&#125;&gt;Send<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#125;      </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;log-div&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;texts&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>最终运行效果如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230709003014.gif"
                      alt=""
                ></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>MonoRepo 前端项目实操</title>
    <url>/posts/3828472050/</url>
    <content><![CDATA[<p><strong>monorepo</strong> (monolithic repository) 是一种<strong>项目架构</strong>（而不是软件架构或设计模式），是一种项目管理手段，简单的来说：<strong>一个仓库内包含系统的多个开发项目（模块，包）</strong>，把所有相关的 package 都放在一个仓库里进行管理，<strong>每个 package 独立发布</strong>。</p>
<p>通过本博客，你将了解monorepo的概念，以及进行一次采用yarn workspace+lerna的monorepo方案的实践。需要注意的是，本博客并不包含npm版本发布实践的部分。</p>
<span id="more"></span>
<blockquote>
<p>一点题外话：关于monorepo体系国内的资料其实比较少，我在写这篇文章的时候其实本来想的是快速看一点国内的资料就上手开始做，但发现国内相关的技术博客实在质量一般，没有一篇系统性的全面介绍，因此写下这篇博客也是希望能帮到后来想要快速上手monorepo架构解决问题的同学。</p>
</blockquote>
<h2 id="monorepo-辩经">monorepo 辩经</h2>
<blockquote>
<p>来自yarn3 workspace文档中的一段话：</p>
<p>In short, they allow multiple projects to live together in the same repository AND to cross-reference each other - any modification to one’s source code being instantly applied to the others.</p>
</blockquote>
<p>虽然在一些原教旨主义看来，按项目拆分仓库、拆分npm包是天然且唯一的方案；但当不同仓库/项目的内容出现关联时，创建复杂的包引用和软连接始终不如直接把源码放在一起来的高效。</p>
<p><strong>工程化的最终目的是让业务开发可以 100% 聚焦在业务逻辑上</strong>，而不是将精力分散到代码复用、依赖版本管理上，因此所谓的工程化思想只是手段，而不是目的。正所谓”不论黑猫白猫，抓到耗子就是好猫“，monorepo架构虽然有着Git版本管理困难、仓库臃肿、编译时间长等原教旨主义唾弃的问题，但在有些项目之间依赖紧密的框架内部它就是最好的方案。</p>
<p>正因如此，许多热门的前端项目如：React, Angular, Babel, Jest, Umijs, Vue 等都是采用的这种架构模式，monorepo架构使它们可以快速迭代、修改不同组件而不必等待依赖链更新。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230525225432.awebp"
                      alt=""
                ></p>
<h3 id="monorepo的优点">monorepo的优点</h3>
<p>除了上面提到了方便不同仓库/项目的内容出现关联时的软链接过程（交给包管理器自动完成），monorepo还有以下优点：</p>
<ul>
<li>更容易统一项目配置和脚手架（如Git Hooks、ESLint、Prettier等）</li>
<li>同时为一系列包发版</li>
<li>维护库代码时不同项目之间的改动立刻生效</li>
<li>可以使用自动化工具生成CHANGELOG（如lerna）</li>
</ul>
<h3 id="你是否需要monorepo">你是否需要monorepo</h3>
<p>还是那句话，**没有银弹！**你需不需要使用monorepo完全取决于你自己的需求！但实际情况是，需要使用monorepo的场景，其害处（如编译时间增加、代码仓库膨胀等）远不足以让团队放弃这个方案，他们已经完全沉浸于monorepo所带来的开发体验了（如即时生效的改动）。</p>
<p>这里提供一个quiz，满足下面三个要求就说明你适合monorepo：</p>
<ul>
<li>主业务流程和功能规模相对稳定，规模不太可能剧增</li>
<li>业务一般由单个团队维护，在多端之间的权限相对一致，涉及端规模比较可控</li>
<li>用户侧业务逻辑有变的时候，常对上线时间有强要求，因此最好变更范围易控，一次修改可多端生效</li>
</ul>
<h2 id="monorepo-实操">monorepo 实操</h2>
<p>这里我们使用<strong>yarn的<a class="link"   href="https://yarnpkg.com/features/workspaces" >workspace <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>机制</strong>和**<a class="link"   href="https://lerna.js.org/" >lerna <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>**来进行monorepo的管理，<strong>使用yarn workspace来管理依赖，使用lerna来管理npm包的版本发布</strong>，这是目前社区中最主流的方案，也是yarn官方推荐的方案，虽然有pnpm方案作为替代，但这里还是选用这个经典的方案。</p>
<p>在最后的<a href="#%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83">上手操作</a>中跟着步骤走，你将得到一个<strong>基于yarn3和lerna的monorepo仓库</strong>，同时管理react前端和koa.js后端项目。</p>
<h3 id="什么是-worksapce">什么是 worksapce</h3>
<p>根据yarn3的文档，我们可知在yarn3中workspace是<strong>为了monorepo中多项目管理设置的<code>yarn link</code>（软链接）的语法糖</strong>，使用workspace使我们可以在所有子项目之间共享一份依赖，而不用单独安装。</p>
<p>除此之外，由于npm/yarn/pnpm都支持worksapce的功能，其实际上是一个<strong>定义在package.json中的协议</strong>，不同包管理器都支持这个协议，但其不同之处在于依赖管理的方式（扁平、pnpm或者pnp方式）。</p>
<p><strong>需要注意的是，workspace与后面我们提高的lerna并不冲突，[lerna会尝试使用原生的workspace机制来管理依赖](#如何使用 lerna)，这也为我们使用二者共同管理monorepo埋下了可能的种子。</strong></p>
<h4 id="workspace-协议">workspace 协议</h4>
<p>首先，我们要明晰有些词汇的含义（来源于yarn文档）：</p>
<ul>
<li>仓库（<strong>原文中叫project</strong>，为了避免混淆我这里就叫仓库了）：你的整个目录，通常也是你的Git仓库所在地</li>
<li>项目（<strong>原文中叫workspace</strong>，同样是为了避免混淆）：通常是packages/目录下的某个目录，也是实际的工作目录</li>
<li>项目树（<strong>原文中叫worktree</strong>）：项目对应的目录树，列出了<strong>项目及其子项目</strong>（是的，项目也可以有自己的子项目，无限套娃，但这需要特殊的声明，不在本文的讨论范围内）<strong>，一个仓库至少有一个项目和一个工作树，也可以有多个</strong>。</li>
</ul>
<p>为了开始我们的monorepo之旅，我们需要在根项目（最外层的项目，即根目录下的package.json）中声明一个项目树，就像下面这样（当然后面讲的lerna会自动为我们生成）：</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;workspaces&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    	<span class="string">&quot;packages/*&quot;</span></span><br><span class="line">  	<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>
<p>为了维持workspace的特性，需要<strong>对workspace中的项目做一些限制</strong>或者说定义：</p>
<ul>
<li>只能访问项目自己定义的依赖，而不能访问其他项目的依赖，即使存在在node_modules中</li>
<li>项目会优先访问本地依赖，如果可以满足要求就不会请求远程仓库</li>
</ul>
<p>除了限制，我们还对worksapce有一些额外的语法支持，以满足monorepo的开发需求：</p>
<ul>
<li>别名语法（<code>workspace:</code>）
<ul>
<li>通配符如 <code>foo: workspace:*</code>：这会在当前项目树中查找所有名为<code>foo</code>的包</li>
<li>其他别名如 <code>foo: workspace:foo@*</code> 也是有效的，它们都会<strong>在发布时转化为有效名称</strong></li>
<li>相对路径语法如 <code>foo: workspace:../foo</code> 也是有效的，会根据对应的workspace进行寻找（适用于嵌套的情况）</li>
<li><strong>可以直接使用 <code>yarn workspace &lt;workspace&gt; add &lt;package&gt;</code> 来添加当前工作目录下的其他包，会变成 <code>workspace:^</code>的形式（推荐！）</strong></li>
</ul>
</li>
<li>发布项目：包管理器将动态替换这些 <code>workspace:</code> 依赖，但<strong>包管理器本身并不承担发布本身的工作</strong>，一般由其他方案如<a class="link"   href="https://lerna.js.org/" >lerna <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>或<a class="link"   href="https://rushjs.io/" >rush <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>来承担</li>
</ul>
<h4 id="如何使用-yarn-workspaces">如何使用 yarn workspaces</h4>
<p>虽然npm/yarn/pnpm都支持workspace，且都有几乎统一的workspace协议（定义在package.json）中，彼此的架构也都借鉴了老祖宗lerna，但语法上还是略有不同，大同小异。</p>
<p>这里我主要介绍yarn workspace的CLI语法和使用 <s>（因为自己项目的技术选型是这个嘿嘿）</s></p>
<p>需要注意的是：<strong>在根目录运行<code>yarn &lt;command&gt;</code>会对所有项目都运行对应指令。</strong>（值得注意的是，在任何目录运行<code>yarn install</code>都会安装所有依赖）</p>
<ul>
<li><code>yarn workspace &lt;workspace&gt; &lt;command&gt;</code>：对指定的workspace执行指令
<ul>
<li><code>yarn workspace &lt;workspace&gt; run &lt;command&gt;</code>：对指定项目运行命令</li>
<li><code>yarn workspace &lt;workspace&gt; add/remove &lt;package&gt; [-D]</code>：向指定项目添加/删除依赖</li>
</ul>
</li>
<li><code>yarn workspaces &lt;command&gt;</code>：对所有workspace执行指令
<ul>
<li><code>yarn workspaces run &lt;command&gt;</code>：对所有workspace执行指令</li>
<li><code>yarn workspaces info [--json]</code>：打印依赖关系树</li>
</ul>
</li>
<li><code>yarn add/remove &lt;package&gt; -W</code>：忽略workspace协议中的依赖管理，直接在根目录安装项目依赖（适用于通用脚手架如eslint等）</li>
</ul>
<h3 id="什么是-Lerna">什么是 Lerna</h3>
<blockquote>
<p>Lerna is <strong>The Original Tool for JavaScript Monorepos</strong>.</p>
<p>It is a fast, modern build system for managing and publishing multiple JavaScript/TypeScript packages from the same repository.</p>
</blockquote>
<p>Lerna 是一个管理多个 npm 模块的工具，是 Babel 自己用来维护自己的 monorepo 并开源出的一个项目。优化维护多包的工作流，解决多个包互相依赖，且发布需要手动维护多个包的问题。</p>
<p>需要注意的是，<strong>lerna本身并不负责构建和测试等任务，而是基于npm scripts执行一套集中管理packages的自动化管理流程，并在这个统筹的层次进行优化（而并不深入到任务本身）</strong>。</p>
<p>它在此处的主要作用不是管理不同的packages（这些由包管理器如 yarn 负责），而是<strong>独立发布这些在一个repo中的packages</strong>。</p>
<p>Lerna在其官网列出了其特色功能：</p>
<ul>
<li>链接其下不同的项目**（这一部分通常由包管理器完成）**</li>
<li>批量或独立对子项目运行指定脚本（如build、publish等）</li>
<li><strong>独立发布某个子包</strong>而不是整个仓库，这是包管理器如yarn和pnpm无法完成的功能</li>
<li>快速构建（Super fast!），通过<a class="link"   href="https://twitter.com/i/status/1529493314621145090" >nx <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>和<a class="link"   href="https://lerna.js.org/docs/features/cache-tasks" >缓存机制 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>加速构建过程</li>
<li>零配置，易于上手，可以在现有的monorepo项目中无痛引入</li>
<li>漂亮的控制台输出和<a class="link"   href="https://lerna.js.org/docs/getting-started#visualizing-workspace" >依赖可视化图 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<h4 id="如何使用-lerna">如何使用 lerna</h4>
<p>通过简单的初始化，你可以在任何现有项目中引入lerna来管理你的monorepo项目：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npx lerna@latest init -y <span class="comment"># npm官方已不再推荐全局安装包，而是通过npx使用最新版的包</span></span></span><br></pre></td></tr></table></figure></div>
<p>这个操作会做以下步骤：</p>
<ol>
<li>将lerna添加到devDependencies中，并将private设为true（脚手架不需要发布）</li>
<li>在根目录生成一个lerna.json用于配置</li>
<li>生成./packages目录</li>
<li><strong>配置npm/yarn/pnpm的workspace协议</strong>用于依赖管理。</li>
</ol>
<blockquote>
<p>由于现在的包管理器（包括npm）都自带了完整的<strong>workspace协议</strong>和依赖管理，lerna就不再使用其自带的<code>lerna-bootstrap</code>方案，而转投workspace方案，而bootstrap方案在v7版本已经废弃。</p>
</blockquote>
<h4 id="创建缓存">创建缓存</h4>
<p>如果不进行任何配置，lerna运行任何命令都会执行所有的任务（即使没有任何代码发生改变），我们可以通过增加缓存配置来改善命令运行的时间。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npx lerna add-caching</span></span><br></pre></td></tr></table></figure></div>
<p>这个命令会通过一系列CLI提示指导你生成nx.json来配置生成过程的缓存。</p>
<h4 id="版本管理">版本管理</h4>
<p><code>lerna version</code> 的作用是进行 <code>version bump</code>，支持手动和自动两种模式。</p>
<ul>
<li>手动确定版本：运行<code>lerna version</code>后跟着提示一步步走</li>
<li>自动确定版本：自动根据 <code>conventional commit</code> 规范确定版本（要求满足commit规范才行），命令：<code>lerna version --conventional-commits</code>
<ul>
<li>commit(scope)：只更新对应scope版本</li>
<li>存在feat提交： 需要更新minor版本</li>
<li>存在fix提交： 需要更新patch版本</li>
<li>存在BREAKING CHANGE提交： 需要更新大版本</li>
</ul>
</li>
</ul>
<h4 id="发布npm包">发布npm包</h4>
<p>这是lerna最重要的功能之一，也是包管理器暂时无法替代的功能。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npx lerna publish --no-private</span></span><br></pre></td></tr></table></figure></div>
<p>以上命令会自动独立地发布仓库内未设为私有（private）的所有packages。</p>
<h4 id="什么是nx">什么是nx</h4>
<p>相信看过了上面的介绍，对反复提到的nx模块也感到了一丝好奇，lerna的众多功能包括任务优化（fast task scheduling &amp; task pipelines）、构建缓存（caching）、可视化依赖（dependency visualization）等功能都依赖于nx的实现。那么，什么是nx呢？</p>
<blockquote>
<p>Nx is a smart, fast and extensible build system with first class monorepo support and powerful integrations.</p>
</blockquote>
<p>本文就不再深究nx是如何实现的，它为什么快这样的问题，只需要知道<strong>nx是一个新型的构建工具</strong>即可，更多内容会放在<strong>前端工具链-构建工具</strong>中。</p>
<p>nx的设计理念和vscode类似，作为构造工具本身已经足够快和优秀（就像vscode作为编辑器本身已经合格一样），支持workspaces等现代特性，还支持庞大的插件系统，让其更加强大。</p>
<p>除此之外，nx是一个独立的项目，lerna引用了nx（也就是说lerna的所有指令都会默认使用nx完成），但你也可以独立于lerna使用nx，为workspace机制带来nx的特性。</p>
<h3 id="实战演练">实战演练</h3>
<p>我们已经了解了yarn workspace和lerna的基础知识，现在我们来实现一个基础需求吧：对一个原本的react前端+koajs后端的人员管理系统进行monorepo重构，它们本来就放在一个仓库里，现在我们对它进行monorepo改造。</p>
<p>为了方便演示，这里就用我之前做过的一个作业作为例子：<a class="link"   href="https://github.com/KiritoKing/HUST-Kingsoft-2022" >KiritoKing/HUST-Kingsoft-2022 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>这个项目的架构包含以下部分：</p>
<ul>
<li>fe/src：存放前端代码</li>
<li>server：存放后端代码</li>
<li>static：公共资源</li>
</ul>
<p>当初为了共享一个脚手架以及方便启动，就把前后端放在了一个项目里，也算一个monorepo的雏形吧。</p>
<h4 id="理清改造思路">理清改造思路</h4>
<p>在开始之前，我们要先理清我们的重构思路。我们要将这个仓库中的前端项目和后端项目打包为两个独立的模块，放在同一个仓库中管理：<strong>使用yarn workspace来管理依赖，使用lerna来管理npm包的版本发布</strong>。</p>
<p>除此之外，还有一个更重要的部分是，我们要<strong>理清工具之间的关系：yarn和lerna在这个过程中到底扮演了什么角色？</strong></p>
<p>yarn和lerna这两个工具的<strong>互补性远远大于它们的互斥性</strong>，换言之就是它们可以配合运行得很好。</p>
<ul>
<li>在功能上，它们是互补的：workspace用于管理依赖，lerna用于管理包的版本发布</li>
<li>在层级上，它们是依赖的：workspace是一个<strong>底层</strong>的工具，它负责实现处理包的安装、在项目之间创建符号链接，和在根目录和受控的项目文件夹下中分配模块；而lerna是一个更高级的工具，它在更高层级提供了monorepo的操作指令并对其进行优化（利用nx优化流程）</li>
</ul>
<p>以及，最后一个原则问题：<strong>在二者功能重合时，应该使用yarn命令还是lerna命令？</strong></p>
<p>实际上，在项目中我们一般不会遇到这个问题。因为yarn和lerna在职能上是有严格区分的，<strong>安装和管理依赖全权交由yarn负责，而其他功能则交由lerna负责</strong>。</p>
<p>虽然lerna的流水线功能可以由yarn基础地实现，但出于**自定义性（如pipeline定义）和性能优化（如caching）**的角度来说，这些功能应优先交给lerna。</p>
<h4 id="开始改造">开始改造</h4>
<p>首先我们先将整个项目clone下来，并使用yarn-v3进行依赖安装（如果corepack那一步出错可以参考我另一篇<strong>前端工具链-包管理器</strong>的文章）。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/KiritoKing/HUST-Kingsoft-2022.git</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">准备yarn-v3环境，要求node-v16.10+</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo corepack <span class="built_in">enable</span> <span class="comment"># 要求管理员权限</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">corepack prepare yarn@stable --activate <span class="comment"># 安装yarn-v3最新版</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ./HUST-Kingsoft-2022</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yarn install</span></span><br></pre></td></tr></table></figure></div>
<p>然后，我们引入lerna到项目中：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npx lerna@latest init</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yarn install <span class="comment"># 安装lerna</span></span></span><br></pre></td></tr></table></figure></div>
<p>如果以上步骤均成功，我们就可以看到以下画面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230526010217.png"
                      alt=""
                ></p>
<p>然后我们需要对lerna.json进行一些修改，让它启用yarn workspaces（仅展示关键配置）：</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;npmClient&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yarn&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;useWorkspaces&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>
<p>接下来，我们对其进行目录改造，也是最复杂的一步：</p>
<p>首先，我们需要创建子包：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们有两种方法创建项目，以front-end为例</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方法1：yarn方法</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ./packages</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> front-end</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ./front-end</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yarn init -y <span class="comment"># 初始化项目</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方法2：lerna方法</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lerna create front-end -y <span class="comment"># 这相当于一个语法糖，推荐此方法</span></span></span><br></pre></td></tr></table></figure></div>
<p>然后我们需要将./fe/src的代码和其他文件转移到新目录中：</p>
<ol>
<li>
<p>将<strong>src、webpack、static</strong>目录整个拷贝过来，然后删除原目录（服务端不需要）</p>
</li>
<li>
<p>参考根目录下的package.json修改项目里的配置文件</p>
</li>
<li>
<p>修改webpack配置./packages/front-end/webpack/webpack.common.config.js，删去变量<code>fe</code>以及一切对其引用</p>
</li>
<li>
<p>将.bebelrc配置文件也放进新包中</p>
</li>
<li>
<p>由于原依赖中缺少了<code>@ant-design/icons</code>，需要手动添加</p>
</li>
</ol>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yarn workspace front-end add @ant-design/icons</span></span><br></pre></td></tr></table></figure></div>
<ol start="6">
<li>最后运行构建依赖树并用webpack-serve运行</li>
</ol>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yarn install</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yarn workspace front-end dev <span class="comment"># 运行dev-server</span></span></span><br></pre></td></tr></table></figure></div>
<p>如果成功会看到登陆界面（背景图是随机的），但此时还不能正常登录，因为后端服务还没有运行。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230526014313.png"
                      alt=""
                ></p>
<p>好了，又到了喜闻乐见的抄作业时间，当下我的front-end/package.json是长这样的（我是用<code>lerna create</code>创建的），如果你运行不起来可以检查一下：</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;front-end&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&gt; TODO: description&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;KiritoKing &lt;kiritoclzh@gmail.com&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;homepage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://github.com/KiritoKing/HUST-Kingsoft-2022#readme&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/index.tsx&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;proxy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://localhost:9001&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;directories&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;lib&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lib&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;__tests__&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;lib&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;repository&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;git&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;git+https://github.com/KiritoKing/HUST-Kingsoft-2022.git&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack server --open --config ./webpack/webpack.dev.config.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack --config ./webpack/webpack.prod.config.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node ./__tests__/front-end.test.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;bugs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://github.com/KiritoKing/HUST-Kingsoft-2022/issues&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@babel/core&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.19.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@babel/preset-env&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.19.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@babel/preset-react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.18.6&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@babel/preset-typescript&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.18.6&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@emotion/react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^11.10.4&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@emotion/styled&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^11.10.4&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@types/react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^18.0.21&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@types/react-dom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^18.0.6&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@typescript-eslint/eslint-plugin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.41.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;babel-loader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^8.2.5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;classnames&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.3.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;clean-webpack-plugin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;css-loader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^6.7.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;html-webpack-plugin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.5.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mini-css-extract-plugin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.6.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;style-loader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.3.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;typescript-plugin-css-modules&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.4.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;webpack&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.74.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;webpack-cli&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.10.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;webpack-dev-server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.11.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;webpack-merge&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.8.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@ant-design/icons&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.1.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@faker-js/faker&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.6.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@reduxjs/toolkit&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.9.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;antd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.24.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;axios&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.1.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^18.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;react-dom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^18.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;react-redux&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^8.0.5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;react-router-dom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^6.4.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;react-use-cookie&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.4.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>目录树长这样：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230526014456.png"
                      alt=""
                ></p>
<p>下面就练习一下吧，按照上面的方法对比较简单的server部分如法炮制，制作一个back-end包。（如果实在不行也可以看看monorepo分支）</p>
<blockquote>
<p>需要注意的是，server部分由于逻辑有点写死了（早期作品理解一下），它在初次登录时会报错（可以在console看到），这时<strong>在back-end目录下创建一个server目录并把data移动进去就行。</strong></p>
<p><s>如果你有兴趣也可以帮我修一修bug</s></p>
</blockquote>
<p>在你的工作完成后，使用admin+123456就可以登录系统了，界面如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230526015319.png"
                      alt=""
                ></p>
<p>至此，我们对其的<strong>monorepo改造已经基本完成，两个项目已经变成了独立的package，可以独立开发、维护、部署和发布。</strong></p>
<h4 id="善后和总结">善后和总结</h4>
<p>通过上面的实战，我们大概可以知道，在monorepo仓库中：</p>
<ul>
<li>每个项目都有自己的依赖，不同项目之间可以共用依赖，但必须在各自的package.json中分别声明</li>
<li>根目录下的依赖一般是整个项目的脚手架，如eslint, prettier之类（webpack一般会放在需要框架的项目中，不同项目之间如果需要共享配置则可以创建一个<a href="">共享配置包(package)</a>）</li>
</ul>
<p>但是，作为一个全栈应用，整个项目应该也是可以启动的，这里我们再做进一步的工作：在根目录package.json中添加<strong>一次性运行两个服务和编译全部服务</strong>的指令。</p>
<p>这里我直接使用了Copilot的代码稍加修改，使用了lerna运行脚本的能力：</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npx lerna run start --parallel&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npx lerna run build&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npx lerna run typescript&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;clean&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npx lerna run clean --parallel&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;prepublish&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npx lerna run prepublish --parallel&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;prepare&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npx lerna run prepare --parallel&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;postinstall&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npx lerna run postinstall --parallel&quot;</span></span><br><span class="line">  	<span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>
<p>这里解释一下<strong>为什么要用npx，因为yarn3的PnP到现在实际上还是实验性功能，出现兼容性问题在所难免，因此这里选择调用npx来调用lerna功能</strong>，详见<a class="link"   href="https://github.com/lerna/lerna/issues/3622" >这篇Issue <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>这下我们运行一下 <code>yarn run dev</code>，出现以下界面就代表成功了：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230526022337.png"
                      alt=""
                ></p>
<p>在运行 <code>yarn run build</code> 时我们发现lerna很智能地跳过了没有配置build的back-end包。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230526022522.png"
                      alt=""
                ></p>
<h2 id="monorepo-最佳实践">monorepo 最佳实践</h2>
<p>如果你没有npm发版需求，那么npm/yarn/pnpm自带的workspace就可以满足你的几乎一切monorepo需求，但代价就是可能需要牺牲lerna或rush带来的一些额外功能，如指令自定义流水线（pipeline）等（yarn本身不支持拓扑排序规则运行脚本，lerna等构建工具则支持）。</p>
<p>在这一部分，我们将继续完善我们刚刚创建的monorepo仓库，如果你的练习还没有达到一条指令运行和构建整个项目，请修复这些bug <s>（或直接从分支抄作业）</s> 。完善后的仓库将拥有以下功能（当然这并不只是monorepo的最佳实践，而是<strong>前端工程化的最佳实践</strong>在monorepo的体现）：</p>
<ul>
<li>Commit Lint功能：检查commit信息的规范性</li>
<li>Git Hooks：在提交时实施代码检查</li>
<li>自动版本号更新：根据commit信息自动更新版本号</li>
<li>自动生成CHANGELOG：根据commit信息自动生成版本对应的changelog</li>
<li>项目独立和整体 Docker 部署（在<a href="">另一篇博客</a>中详细介绍，此处不再赘述）</li>
<li>生成一个<strong>共享配置包</strong>，管理项目的共享部分和通用接口类型</li>
</ul>
<h3 id="Commit-规范">Commit 规范</h3>
<blockquote>
<p>Commit Message有什么用？为什么需要Commit Message？</p>
</blockquote>
<p>这可能是很多Git初学者会问的问题。先不要嘲笑，在初学者的视野里，它一个人的练手项目，并不需要什么额外信息，他们可能甚至只是想找一个东西可以上传自己的代码，碰巧这个东西就是Git(Hub)而已，所以才会有<code>push -f</code>，才会嫌弃commit message是无用的。</p>
<p>一旦项目复杂了起来，需要版本和分支管理，或者多人协作，抑或需要配置自动化工作流（就像本文中的需求那样），commit message和Git规范就显得重要了起来。</p>
<p>只有有了统一的commit message规范，才能有统一的、自动化的工作流，提高团队效率。目前业界采用比较普遍的是 <strong>Conventional Commit</strong> 规范（约定式提交）。</p>
<blockquote>
<p>约定式提交规范是一种基于提交信息的轻量级约定。 它提供了一组简单规则来创建清晰的提交历史； 这更有利于编写自动化工具。 通过在提交信息中描述功能、修复和破坏性变更， 使这种惯例与 <a class="link"   href="http://semver.org/lang/zh-CN" >SemVer <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 相互对应。（SemVer是一种版本管理规范，也是npm倡导的版本标准）</p>
</blockquote>
<p>一份符合 conventional commit 规范的 commit message 应该长下面这样：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;type&gt;[optional scope]: &lt;description&gt;</span><br><span class="line"></span><br><span class="line">[optional body]</span><br><span class="line"></span><br><span class="line">[optional footer(s)]</span><br></pre></td></tr></table></figure></div>
<ul>
<li>type：提交类型，用于为提交分类，决定更新哪个版本号（<code>MAJOR.MINOR.PATCH</code>中更新哪个部分）
<ul>
<li>基础类型
<ul>
<li>fix：代表修复了某个bug，通常更新<code>patch</code></li>
<li>feat：代表在代码库中新增了一个功能，通常更新<code>minor</code></li>
<li>BREAKING CHANGE：在原有类型后面添加感叹号（!），如<code>fix!</code>，需要更新<code>major</code></li>
</ul>
</li>
<li>扩展类型（基于Angular约定）：build(更改构建系统或外部依赖), chore(无法被归类的修改), ci(更改部署信息), docs, perf(代码性能优化), refactor(广义重构，不添加新功能或修复bug的代码修改), revert(版本回退), style(代码格式化，而非样式修改), test(修改或增加测试)</li>
</ul>
</li>
<li>scope：改动范围，声明改动了哪个部分的代码，<strong>在monorepo中通常为workspace</strong>，留空则默认为全局</li>
<li>BREAKING CHANGE需要在脚注（footer）部分添加说明：<code>BREAKING CHANGE: ....</code></li>
</ul>
<p>以下是一个示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 包含了 ! 和 BREAKING CHANGE 脚注的提交说明</span><br><span class="line">chore!: drop support for Node 6</span><br><span class="line"></span><br><span class="line">BREAKING CHANGE: use JavaScript features not available in Node 6.</span><br><span class="line"></span><br><span class="line"># 包含范围的提交说明</span><br><span class="line">feat(lang): add polish language</span><br></pre></td></tr></table></figure></div>
<h3 id="如何自动规范-Commit-Message">如何自动规范 Commit Message</h3>
<p>自动化任务可以从两部分入手：</p>
<ul>
<li>通过一些向导或者shortcut快速生成符合规范的commit message</li>
<li>在真正commit的时候检查commit message格式，若不满足规范则不予通过以保证自动化流程</li>
</ul>
<h4 id="Commit-向导工具：Commitizen">Commit 向导工具：Commitizen</h4>
<p>使用commit向导工具（通常是cli向导）如<a class="link"   href="https://github.com/commitizen/cz-cli" >Commitizen <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>可以快速创建符合规范的commit message，这里介绍使用commitizen-cli工具生成commit message的方法，也便于后面直接利用相关工具直接生成conventional changelog。</p>
<p>在node-v12/14/16+npm-v6+的环境中，commitizen可以直接安装使用：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install -g commitizen cz-conventional-changelog</span></span><br></pre></td></tr></table></figure></div>
<p>然后我们可以对仓库做一些调整让它变得&quot;commitizen-friendly&quot;，这样我们可以直接使用<code>git cz</code>调用commitizen，如果你不调整也可以使用<code>npx cz</code>调用。</p>
<p>只需要在根目录下创建一个.czrc的配置文件，其配置如下：</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cz-conventional-changelog&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>
<p>然后运行<code>git cz</code>试试看，大概会得到下面的效果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://commitizen-tools.github.io/commitizen/images/demo.gif"
                      alt=""
                ></p>
<h4 id="使用Git-Hooks管理Commit规范">使用Git Hooks管理Commit规范</h4>
<p>Git Hooks就是Git提供的Hooks（废话），众所周知Hooks一般指的是一个过程在不同的生命周期中暴露给外部的接口，以供外面获取或修改对应的数据，如React中组件的生命周期Hooks、Webpack的构建过程Hooks等，Git Hooks就是Git流程中的Hooks，如Add、Commit等都有对应的Hooks。</p>
<h5 id="使用Husky管理Hooks">使用Husky管理Hooks</h5>
<p>Husky是一个轻量级（6kb）、跨平台的Node工具包，用于更好地在Commit阶段注入Hooks。</p>
<blockquote>
<p>It’s recommended to add husky in root <code>package.json</code>. You can use tools like <a class="link"   href="https://github.com/lerna/lerna" >lerna <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> and filters to only run scripts in packages that have been changed.</p>
</blockquote>
<p>由于husky官方建议我们在根目录添加husky，因此这里我们直接在根目录使用yanr-v2+的安装命令（husky总是遵循包管理器的最新特性和最佳实践）</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yarn dlx husky-init --yarn2 <span class="comment"># dlx: Run a package in a temporary environment，类似于npx</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yarn</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动安装</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yarn add husky pinst -D</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yarn husky install <span class="comment"># 开启 Git Hooks</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">记得设置postinstall脚本为 husky install</span></span><br></pre></td></tr></table></figure></div>
<p>以上命令会自动帮你完成项目的配置，并安装依赖。</p>
<blockquote>
<p>不同版本的husky之间差别较大，特别是v4和v5，<strong>这里使用的是v5版本</strong>，它利用了Git的现代新特性如core.hooksPath，因此使用方法有较大区别，<strong>原有的在package.json中的配置方法被废弃</strong>，必须使用命令行或修改.husky目录下的命令。</p>
<p>除此之外，对于yarn的配置也有较大区别，具体可以查看<strong>我分支中的.husky目录下的<a class="link"   href="https://github.com/KiritoKing/HUST-Kingsoft-2022/tree/mono-best-practice/.husky" >配置文件 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong>。（建议查看以作参考！）</p>
</blockquote>
<p>如果要添加Husky规则，应该遵循以下规则：</p>
<ol>
<li>先使用<code>yarn husky add &lt;file&gt; [cmd]</code>写入文件</li>
<li>暂存刚刚的文件：<code>git add &lt;file&gt;</code></li>
</ol>
<h5 id="添加commit-lint">添加commit-lint</h5>
<p>首先我们安装相关包：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Install commitlint cli and conventional config</span></span><br><span class="line">yarn add -D @commitlint/config-conventional @commitlint/cli</span><br></pre></td></tr></table></figure></div>
<p>然后我们在根目录下创建一个<code>.commitlintrc.json</code>配置文件（但凡配置文件我都倾向于使用json而不是js，为了避免奇怪的lint问题），内容如下：</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;@commitlint/config-conventional&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>
<p>然后我们使用husky添加相关hook：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">yarn husky add .husky/commit-msg  &#x27;yarn commitlint --edit $&#123;1&#125;&#x27;</span><br></pre></td></tr></table></figure></div>
<p>此时我们的hook就注册成功了，现在就只能提交符合conventional规范的commit了，如果违反了就会报错；而如果你按规范提交就可以成功提交（如使用<code>git cz</code>）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230527021134.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230527021457.png"
                      alt=""
                ></p>
<blockquote>
<p>这里我卡在了一个奇怪的错误，JSON解析失败，后来问了GPT才发现是我的文档格式设成了UTF-16，改成UTF-8就正常了。<s>最开始我还以为是Windows系统的锅。</s></p>
</blockquote>
<p>至此，我们关于commit message的所有配置就完成了。</p>
<h3 id="利用commit-message">利用commit message</h3>
<p>经历了有些波折的配置commit过程，是时候尝尝甜头了！我们的规范化的commit message能帮我做什么呢？</p>
<p>这里演示两个最基础的功能：</p>
<ul>
<li>自动发布版本</li>
<li>自动生成日志（changelog）</li>
</ul>
<p>这里我们直接借用lerna的自动版本管理功能（基于conventional commit messages）</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lerna version --conventional-commits</span></span><br></pre></td></tr></table></figure></div>
<p>结果如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230527022942.png"
                      alt=""
                ></p>
<p>由图可知，这个命令帮我们做了这些事：</p>
<ol>
<li>读取commit messages：从某个tag开始（记录版本时会在git历史上打tag，包括手动）寻找commit messages，并根据规则解析</li>
<li>如果找到需要更改版本号的commit，就在对应scope修改版本号（会询问）</li>
<li>在新commit打标签，并根据两个tag之间的commit message自动生成changelog</li>
<li>提交标签（tag和commit是有区别的），推送更新到npm（如果有设置）</li>
</ol>
<p>自动生成的CHANGELOG长这样：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230527023454.png"
                      alt=""
                ></p>
<p>Commit 记录则长这样：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230527023529.png"
                      alt=""
                ></p>
<h3 id="其他-Hooks">其他 Hooks</h3>
<p>除了处理commit信息来完善提交、发版自动化流程以外，我们还可以添加其他hooks（借助husky），这里最重要的就是<strong>代码检查和测试</strong>了。</p>
<h4 id="代码检查">代码检查</h4>
<p>我们可以使用pre-commit的Hook来实现提交代码检查：<strong>保证提交到git暂存区的所有代码都是符合规范的！</strong></p>
<p>这里我们借用<a class="link"   href="https://github.com/okonet/lint-staged" >lint-staged <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>和上文提到的husky快速实现git提交时代码检查的功能。</p>
<p>我们首先安装并添加lint-staged的hooks：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yarn add -D lint-staged</span></span><br></pre></td></tr></table></figure></div>
<p>然后对其进行配置，由于lint-staged支持在package.json中配置，就不新增配置文件了（多一事不如少一事）。除此之外，我们还要定义我们的lint脚本，由于我们之前的项目中已经有了eslint和prettier的配置（兼容配置也做好了），就直接使用就行了：</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    ...<span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lint-staged&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;*.js&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eslint --fix&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;*.ts&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eslint --fix&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;*.tsx&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eslint --fix&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;*.json&quot;</span><span class="punctuation">:</span> <span class="string">&quot;prettier --write&quot;</span></span><br><span class="line">  	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>注意：</p>
<ol>
<li>数组内的元素是<strong>串行执行</strong>的</li>
<li>一定要做筛选，尽管eslint和prettier本身具有筛选机制，但这里不做筛选很可能报错</li>
</ol>
</blockquote>
<p>随便修改一点代码，用命令<code>yarn lint-staged</code>试运行一下：（可能报错，安装一下<code>yarn add @typescript-eslint/eslint-plugin -D</code>就好）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230527031712.png"
                      alt=""
                ></p>
<p>将这个hook注入进husky，修改.husky/pre-commit：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env sh</span></span><br><span class="line">. <span class="string">&quot;<span class="subst">$(dirname -- <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span>/_/husky.sh&quot;</span></span><br><span class="line"></span><br><span class="line">yarn lint-staged</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>最后测试一下提交效果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230527032237.png"
                      alt=""
                ></p>
<h4 id="测试">测试</h4>
<p>与代码检查一样在pre-commit中添加测试命令即可，一般在代码检查后运行，这里就不再赘述。</p>
<h3 id="抽取独立配置包">抽取独立配置包</h3>
<div class="note info"><p>等待补充</p>
</div>
<hr>
<h2 id="参考资料">参考资料</h2>
<h3 id="文档">文档</h3>
<ul>
<li><a class="link"   href="https://lerna.js.org/docs/getting-started" >Getting Started | Lerna <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://yarnpkg.com/features/workspaces" >Workspaces | Yarn - Package Manager (yarnpkg.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://docs.npmjs.com/cli/v9/using-npm/workspaces" >workspaces | npm Docs (npmjs.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.conventionalcommits.org/zh-hans/v1.0.0/" >约定式提交 (conventionalcommits.org) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://github.com/okonet/lint-staged" >okonet/lint-staged: 🚫💩 — Run linters on git staged files (github.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<h3 id="博客">博客</h3>
<ul>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/65533186" >精读《Monorepo 的优势》 - 知乎 (zhihu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/77577415" >Monorepo 是什么，为什么大家都在用？ - 知乎 (zhihu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/7065141885576151070#heading-1" >monorepo的理解以及简单实现 - 掘金 (juejin.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/7011024137707585544" >Monorepo最佳实践之Yarn Workspaces - 掘金 (juejin.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.jianshu.com/p/8dbe488d391b" >如何使用 Yarn Workspaces 配置一个 Monorepo JS/TS 项目 - 简书 (jianshu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/7097820725301477406" >lerna + yarn workspace 使用总结 - 掘金 (juejin.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/71385053" >基于lerna和yarn workspace的monorepo工作流 - 知乎 (zhihu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/6844903911095025678" >基于 Lerna 管理 packages 的 Monorepo 项目最佳实践 - 掘金 (juejin.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/381794854" >Yarn Workspace使用指南 - 知乎 (zhihu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/LifeRiver/article/details/125077901" >Nx 介绍: 基于插件的单一代码库(Monorepo)构建系统_nx.json_AaronZZH的博客-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>[<a class="link"   href="https://juejin.cn/post/7071992448511279141" >译]用 PNPM Workspaces 替换 Lerna + Yarn - 掘金 (juejin.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/6844903871832145927" >Git commit message 规范 - 掘金 (juejin.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.cnblogs.com/jiaoshou/p/12250278.html" >lint-staged 使用教程 - 较瘦 - 博客园 (cnblogs.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>monorepo</tag>
        <tag>项目管理</tag>
        <tag>yarn</tag>
        <tag>lerna</tag>
      </tags>
  </entry>
  <entry>
    <title>peerDependencies 版本冲突解决</title>
    <url>/posts/3463082280/</url>
    <content><![CDATA[<p>在为公司一个老项目配置Prettier和ESLint、StyleLint兼容性设置后，我再次使用 npm install 生成 package-lock.json 时遇到了下面这个错误。</p>
<span id="more"></span>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm ERR! code ERESOLVE</span><br><span class="line">npm ERR! ERESOLVE could not resolve</span><br><span class="line">npm ERR! </span><br><span class="line">npm ERR! While resolving: stylelint-prettier@3.0.0</span><br><span class="line">npm ERR! Found: stylelint@13.13.1</span><br><span class="line">npm ERR! node_modules/stylelint</span><br><span class="line">npm ERR!   dev stylelint@&quot;^13.13.1&quot; from the root project</span><br><span class="line">npm ERR!   peer stylelint@&quot;^13.0.0 || ^14.0.0&quot; from @nuxtjs/stylelint-module@4.1.0</span><br><span class="line">npm ERR!   node_modules/@nuxtjs/stylelint-module</span><br><span class="line">npm ERR!     dev @nuxtjs/stylelint-module@&quot;^4.0.0&quot; from the root project</span><br><span class="line">npm ERR!   4 more (stylelint-config-prettier, ...)</span><br><span class="line">npm ERR! </span><br><span class="line">npm ERR! Could not resolve dependency:</span><br><span class="line">npm ERR! peer stylelint@&quot;&gt;=14.0.0&quot; from stylelint-prettier@3.0.0</span><br><span class="line">npm ERR! node_modules/stylelint-prettier</span><br><span class="line">npm ERR!   dev stylelint-prettier@&quot;^3.0.0&quot; from the root project</span><br><span class="line">npm ERR! </span><br><span class="line">npm ERR! Conflicting peer dependency: stylelint@15.6.2</span><br><span class="line">npm ERR! node_modules/stylelint</span><br><span class="line">npm ERR!   peer stylelint@&quot;&gt;=14.0.0&quot; from stylelint-prettier@3.0.0</span><br><span class="line">npm ERR!   node_modules/stylelint-prettier</span><br><span class="line">npm ERR!     dev stylelint-prettier@&quot;^3.0.0&quot; from the root project</span><br><span class="line">npm ERR!</span><br><span class="line">npm ERR! Fix the upstream dependency conflict, or retry</span><br><span class="line">npm ERR! this command with --force, or --legacy-peer-deps</span><br><span class="line">npm ERR! to accept an incorrect (and potentially broken) dependency resolution.</span><br></pre></td></tr></table></figure></div>
<p>但我平时用的是yarn3进行包管理，也没有遇到任何问题，所以现在问题成了三个：</p>
<ul>
<li>如何解决这个依赖冲突问题？</li>
<li>为什么yarn3没有出现这个问题而npm8遇到了？</li>
<li>如果把部署方案改成yarn是否可以直接规避依赖版本冲突？</li>
</ul>
<h2 id="为什么会出现这个冲突？">为什么会出现这个冲突？</h2>
<p>在我的<a href="">前端工具链</a>一文中曾详解过npm3中扁平依赖项的解析方式，以及其不确定依赖关系的问题：npm3无法固定依赖，即如果两个包都依赖了同一个包，但是版本不同，则具体安装依赖和构建依赖树时会<strong>按第一个出现该包的版本为标准（即谁先就是谁）</strong>，并后续不再重复安装。</p>
<p>我也没有想到，npm8了仍然采用这样的方案。</p>
<h2 id="yarn2-为什么没有出现这个问题？">yarn2+为什么没有出现这个问题？</h2>
<h2 id="如何解决这个问题？">如何解决这个问题？</h2>
<p>除了换用其他包管理器，在npm中有没有办法解决呢？</p>
<h3 id="方法1：头痛医头法">方法1：头痛医头法</h3>
<p>这是最简单的方法（但其实没有解决问题，只是缓兵之计），直接加上<code>--legacy-peer-deps</code> 选项，可以顺利安装，并生成 package-lock.json。</p>
<p>后续使用 <code>npm ci --legacy-peer-deps</code> 读取 lock 文件进行部署即可。</p>
<h4 id="peerDependency-做了什么">peerDependency 做了什么</h4>
<p><code>--force</code> 我就不再介绍了，意为强制npm获取远程资源而不使用本地cache，并不能解决这里的问题。</p>
<p>peer本意是同辈人，官方是这样定义的：</p>
<blockquote>
<p><em>peerDependencies</em>: A peer dependency is a specific version or set of versions of a third-party software library that a module is designed to work with. They’re similar in concept to the relationship between a browser extension and a browser.</p>
</blockquote>
<p>在引用一段我在另一篇推文中的定义：</p>
<blockquote>
<p><code>peerDependencies</code>: 表示工程需要和这个依赖（的指定版本）配套使用，<strong>一般用于插件开发</strong>而非项目开发，是为了解决本项目依赖和作为插件被引入的时候与主项目依赖版本冲突的问题（如<code>vuex@4.1.0</code>表明了自己需要<code>vue@^3.2.0</code>配套使用），但<strong>这个选项对于解决某些插件兼容性问题出奇的好用</strong>（算某些奇技淫巧吧），可以使用<code>-P</code>选项来添加。</p>
</blockquote>
<p>所以引入peer可以解决部分的依赖版本问题，因为它可以指定依赖的版本（而不是不确定的间接依赖）。</p>
<p>在多个依赖版本冲突时，install的优先级是这样的：</p>
<ol>
<li>如果用户<strong>显式依赖</strong>了核心库，则可以忽略各插件的<em>peerDependencies</em>声明；</li>
<li>如果用户没有显式依赖核心库，则按照插件<em>peerDependencies</em>中声明的版本将库安装到项目根目录中；</li>
<li>当<strong>用户依赖的版本、各插件依赖的版本之间不相互兼容，会报错让用户自行修复</strong>。</li>
</ol>
<h4 id="为什么会报错">为什么会报错</h4>
<p>既然 peer 的设计目的是为了解决兼容性问题，为什么会报错呢？</p>
<p>在 npm-v7+ 中会默认安装 peer 的版本，但一个可以预见的错误是<strong>如果两个包的依赖版本打架了在扁平结构下应该装哪个版本呢？</strong></p>
<blockquote>
<p>npm：摆了，不知道，throw Error吧！</p>
</blockquote>
<p>这就是我们看到错误的原因，而这个时候我们加上<code>--legacy-peer-deps</code>就相当于告诉npm：行吧，我知道了，你就不检查peer了吧，直接按v4-v6的方法，哪个在前面装哪个吧，出了问题不怪你~~（才怪）~~，这下npm才愿意给你装上依赖。</p>
<h3 id="方法2：直面版本法">方法2：直面版本法</h3>
<p>根据报错信息可以看到，是stylelint-v13版本太老了的原因~~（我的VSCode也一直提醒我不再支持）~~，毕竟都出到15了。</p>
<h4 id="升级-stylelint">升级 stylelint</h4>
<p>这个方法亲测不可行，因为<a class="link"   href="https://blog.csdn.net/qq1014156094/article/details/122456439" >只升级stylelint-v14而不升级其他配套的话不兼容vue+scss语法 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，遂放弃。</p>
<h4 id="降级-stylelint-prettier">降级 stylelint-prettier</h4>
<p>根据报错信息可以看到，是 stylelint-prettier 这个插件要求至少要求 v14+，我们去查它的<a class="link"   href="https://github.com/prettier/stylelint-prettier/blob/main/CHANGELOG.md" >CHANGELOG <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>可以发现在v2.0版本就放弃了v14以前的版本支持，因此最高版本为 v1.2.0（真老啊），将 package.json 中对应版本修改为 1.2.0 后不再报错，问题解决。</p>
<p>顺带还发现了 v3.0.0 中 <code>stylelint-prettier/recommended</code> 报错的原因，是要手动引用，当然降级后自然也不存在这个问题了。</p>
<h3 id="方法3：换用yarn部署">方法3：换用yarn部署</h3>
<p>需要修改 Dockerfile，此方案暂时搁置。</p>
<h4 id="为什么yarn不会报错">为什么yarn不会报错</h4>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a class="link"   href="https://stackoverflow.com/questions/66239691/what-does-npm-install-legacy-peer-deps-do-exactly-when-is-it-recommended-wh" >javascript - What does npm install --legacy-peer-deps do exactly? When is it recommended / What’s a potential use case? - Stack Overflow <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>项目管理</tag>
        <tag>npm</tag>
        <tag>包管理</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Hexo 搭建和部署个人网站</title>
    <url>/posts/1933027073/</url>
    <content><![CDATA[<h2 id="技术选型">技术选型</h2>
<p>在做博客之前先了解了一下国内已有的线上博客平台，因为其在<strong>SEO和曝光</strong>（自带流量，不用手动SEO）方面有一定的先天优势：</p>
<ul>
<li><strong>CSDN</strong>：老牌国内社区，主要问题是<strong>内容质量低，充斥着广告和复制粘贴翻译的低创，公开拿开源资料来收费</strong>，<s>还把导入MD的功能砍了</s>（根据官方的说法是保留了MD导入的）</li>
<li><strong>知乎</strong>：问答社区，编写体验尚可，之前在上面写过几篇NLP的文章，内容质量有点参差不齐，编写体验不错，支持MD导入</li>
<li><strong>掘金/思否</strong>：查资料的时候经常看别人的文章，感觉这两家的内容质量还不错，观看体验尚可，但没在上面写过</li>
<li><strong>博客园</strong>：默认样式很丑，需要（个人直觉）在线配置有点麻烦，但自由度高，有SEO优化，部署相对方便（特别是对国内这种需要公安备案的环境）</li>
<li><s>新浪：已经死啦</s></li>
</ul>
<p>上述平台中<strong>知乎、掘金、思否我会尝试同步更新</strong>，博客园随缘更新。</p>
<p>目前国外我了解的开放博客解决方案（或者说本地博客部署框架）有：</p>
<ul>
<li><strong>WordPress</strong>：老牌博客框架，提供自己的在线平台；功能大而全，开发语言为PHP，个人不太熟悉，但实际写作过程中几乎不用接触代码</li>
<li><strong>Hexo</strong>：Node.JS框架，自定义程度高，整体较为轻量，<strong>适合前端开发者</strong></li>
<li><strong>Notion</strong>：基于数据库的知识管理平台，支持页面公开发布，个人一直在用，最近也支持了Wiki模式，但鉴于无本地和URL为uuid等特性，这里没有把他当作博客的第一选择，而仅仅是用作个人知识管理，后续考虑编写hexo插件和调用Notion API打通hexo+Notion的工作流</li>
<li><s>Hugo：未作了解</s></li>
</ul>
<p>最终，主要是因为个人对整个Hexo生态比较熟悉，选择了<strong>Hexo</strong>平台（并不是说其他平台不好）</p>
<p>对个人而言，<strong>Hexo有以下优点</strong>：</p>
<ul>
<li>架构简单，整个CLI都是基于Node的，对JS开发者友好</li>
<li>使用JSON数据库存储元数据，方便扩展（缺点是体量大了可能会有性能缺陷，后续要考虑长期维护的话是一个问题）</li>
<li>插件较多，自定义性方便（后面会给到我的插件方案）</li>
<li>部署方便，可以直接使用Git进行CI/CD自动化部署（如Github Action）</li>
<li>主流平台（这里我使用<strong>腾讯云</strong>）都支持直接<strong>通过serverless部署hexo</strong>（不知道什么是serverless的可以参考我的<a class="link"   href="https://chlorinec.top/posts/317388827/" >这篇博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）</li>
</ul>
<h2 id="博客架构">博客架构</h2>
<p>Hexo采用<code>hexo-6.3.0</code>和<code>node-v16.17.1</code>+<code>npm-v9</code>在本地构建，主题使用<a class="link"   href="https://github.com/EvanNotFound/hexo-theme-redefine" >Redefine <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>（可能后续会进行改动和二次开发）。</p>
<p>在整个博客中，Hexo作为<strong>静态网站框架</strong>，起到<strong>Hold整个Markdown博客数据库并渲染成HTML</strong>、<strong>渲染其他静态网页</strong>两个作用。</p>
<blockquote>
<p><strong>如何创建Hexo博客这里就不再赘述了，网上有很多教程，这里也不做教程推荐。</strong></p>
</blockquote>
<h3 id="Hexo配置与插件">Hexo配置与插件</h3>
<p>参考我之前的项目 <a class="link"   href="https://github.com/KiritoKing/hexo-msdoc-renderer" >KiritoKing/hexo-msdoc-renderer <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，为博客增加以下基础功能：</p>
<ul>
<li>根据目录自动添加分类，由插件<a class="link"   href="https://github.com/xu-song/hexo-auto-category" >xu-song/hexo-auto-category <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>实现</li>
<li>为每个页面生成独立URL来替代原有Path，由插件<a class="link"   href="https://github.com/rozbo/hexo-abbrlink" >rozbo/hexo-abbrlink <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>实现</li>
<li>修改默认渲染器为<a class="link"   href="https://github.com/hexojs/hexo-renderer-markdown-it" >hexojs/hexo-renderer-markdown-it <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>提供更多MD拓展语法支持</li>
<li><a href="#%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE">图片上传到COS图床</a>中，由本地编辑器（Typora）实现（后续计划，将COS图床与Webify部署合并）</li>
<li><s>根据文档编辑时间自动编辑date的front-matter（开发中）</s></li>
</ul>
<h3 id="部署方案">部署方案</h3>
<ul>
<li>项目源码使用Git，存储库位于Github，方便使用CI/CD自动化生成页面</li>
<li>页面部署可以<strong>使用Github Action自动触发部署</strong>（到Github Page），但这里我使用的是<strong>腾讯云的Webify Serverless服务</strong>，其自带CI部署可以在Push时自动生成页面并部署</li>
<li>评论系统实现采用<a class="link"   href="https://github.com/gitalk/gitalk" >gitalk <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>实现，具体嵌入则由主题提供</li>
</ul>
<h3 id="其他页面">其他页面</h3>
<p>由于除了博客，个人网站还需要显示其他页面，目前个人有以下解决方案：</p>
<ul>
<li>直接在<code>./source</code>中创建对应目录映射为URL，将单页面静态网站放在目录中，使用<code>_config.yml</code>中的<code>skip_render</code>选项跳过渲染（生成时直接拷贝到<code>public</code>中）</li>
<li>Fork主题，添加指定页面的Scaffold代码，利用<code>./_data</code>动态渲染页面，模板EJS设计完成后PR</li>
<li>利用Serverless按量计费特性，直接创建新页面绑定到另一个域名，跨域跳转</li>
</ul>
<p>方案A适用于不会经常改变的静态页面，如<strong>个人简历</strong>；方案B适用于动态页面，如项目列表，可能需要用Github抓取信息更新<code>yml</code>文件来刷新页面；方案C适用于不同架构创建的页面（如React页面），且该页面可能有频繁改动的情况。</p>
<h3 id="Hexo主题备选">Hexo主题备选</h3>
<p>因为做过不少Hexo外包项目，这里收集了一些我个人觉得不错的主题：</p>
<ul>
<li><a class="link"   href="https://github.com/zhwangart/hexo-theme-acorn" >zhwangart/hexo-theme-acorn: <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>：适用于中小型企业门户</li>
<li><a class="link"   href="https://github.com/volantis-x/hexo-theme-volantis" >volantis-x/hexo-theme-volantis <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>：适合开放式博客平台（多人共建）</li>
<li><a class="link"   href="https://github.com/EvanNotFound/hexo-theme-redefine" >EvanNotFound/hexo-theme-redefine <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>：适合个人展示型博客</li>
<li><a class="link"   href="https://github.com/nexmoe/hexo-theme-yet-the-books" >nexmoe/hexo-theme-yet-the-books <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>：适合偏文学创作</li>
</ul>
<h3 id="后续开发计划">后续开发计划</h3>
<p>目前打算开发一个基于React+Next/Electron的<strong>Hexo的GUI管理方案</strong>（<code>hexo-utils</code>），不过<strong>不是编辑器类型而是偏管理向</strong>，按Package进行功能划分如下：</p>
<ul>
<li>
<p><code>hexo-utils/git-utils</code>：实现可配置的自动化Git工作流</p>
<ul>
<li>自动添加暂存区</li>
<li>根据暂存区改动自动添加Commit Message（配合自定义commitlint使用）</li>
<li>（可选）根据Git Log自动修改文章Front-Matter修改日期</li>
<li>（可选）推送到远程仓库</li>
<li>（可选）自动化CI部署</li>
</ul>
</li>
<li>
<p><code>hexo-utils/core</code>：维护应用所需数据和逻辑，钩入hexo-hooks</p>
<ul>
<li>更完备的Draft管理：Draft中目录自动对应Post中目录</li>
<li>根据Git Log自动生成和更新热力图</li>
<li>Tags管理: 维护一个本地的Tags库，为文章自动上标签、去标签、格式化标签（大小写）</li>
</ul>
</li>
<li>
<p><code>hexo-utils/cli</code>：为<code>core</code>添加CLI入口</p>
</li>
<li>
<p><code>hexo-utils/webui</code>：为<code>core</code>添加Web-UI入口，作为<strong>hexo插件</strong>引用，用react+next实现</p>
</li>
<li>
<p><code>hexo-utils/client</code>：使用electron封装<code>core</code>功能，支持管理多个hexo目录</p>
</li>
<li>
<p><code>hexo-utils/notion-utils</code>：与Notion<strong>双向同步</strong>构建知识管理和分享体系</p>
<ul>
<li>将Draft和Post拍平后同步到Notion，使用一个Property进行区分</li>
<li>Notion中更新后的文章会自动导出并同步到指定的Repo中</li>
<li>同理Repo中更新的内容也会同步到Notion数据库中</li>
</ul>
</li>
</ul>
<h2 id="Typora-图床配置">Typora 图床配置</h2>
<p>我一直都习惯用 Typora 进行写作，习惯了所以也入了正版~~（其实是当时不知道beta可以一直用~~。</p>
<h3 id="图床配置">图床配置</h3>
<p>之前一直用的picgo的GUI客户端，因为最开始接触MD写作的时候并不会写前端和Node那一块，所以就用了gui，但越到后面越发现这个electron的客户端就是个性能累赘：不仅冷启动速度慢还经常卡死，而且是一个根本不必要的功能（指上传完全可以用cli实现），所以就借此机会切换到picgo-core。</p>
<blockquote>
<p>切换到CLI后可以做到<strong>0秒冷启动</strong>的效果，非常顺滑，而且<strong>没有一个额外的electron进程占后台</strong>。本文所有图片均使用picgo-core上传。</p>
</blockquote>
<p>首先你先要有一个包管理器（npm, yarn, pnpm）都可以：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里以npm为例</span></span><br><span class="line">npm i picgo -g</span><br></pre></td></tr></table></figure></div>
<p>然后是配置图床，个人使用的是<strong>腾讯云COS</strong>作为图床：</p>
<ol>
<li>在<a class="link"   href="https://console.cloud.tencent.com/cam/capi" >访问密钥 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中获取你的AppId, SecretId, SecretId；在<a class="link"   href="https://console.cloud.tencent.com/cos/bucket" >存储桶列表 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>获取Bucket和AP位置。</li>
<li>建议在终端中运行 <code>picgo set uploader</code>运行CLI向导，运行完毕后你的配置文件应如下图所示：</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/image-20230522214210799.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/image-20230522214653844.png"
                      alt=""
                ></p>
<ol start="3">
<li>在Typora中 设置 -&gt; 图像 设置好上传服务（如果你前面配置好了就可以直接验证，也可以打开配置文件检查一下）</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230522221603.png"
                      alt=""
                ></p>
<p>上传成功会得到如下提示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/20230522221527.png"
                      alt=""
                ></p>
<ol start="4">
<li><strong>配置时间戳上传</strong>，这里需要借用 <a class="link"   href="https://github.com/gclove/picgo-plugin-super-prefix" >picgo-plugin-super-prefix <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 这个插件。</li>
</ol>
<p>首先全局安装这个包：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">picgo install super-prefix</span><br></pre></td></tr></table></figure></div>
<p>然后在配置文件里添加和修改下面的代码，就可以让图片存储在对应存储桶的<code>YYYY/MM/YYYYMMDDHHmmss.*</code>路径里（如<code>*/picgo-core/2023/05/20230522221603.png</code>）：</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    	<span class="attr">&quot;picgo-plugin-super-prefix&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  	<span class="attr">&quot;picgo-plugin-super-prefix&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;prefixFormat&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YYYY/MM/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fileFormat&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YYYYMMDDHHmmss&quot;</span></span><br><span class="line">  	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>
<h2 id="Serverless-部署">Serverless 部署</h2>
<h3 id="腾讯云Webify服务">腾讯云Webify服务</h3>
<blockquote>
<p>利益相关：无，希望腾讯看到了早日给我打钱<s>或者把我招进去</s></p>
<p>（一些废话）这部分其实是2023年6月份才更新的，原因是想对博客做SEO优化，发现原来的部署总是失败，点开日志发现是环境缺失了一些包（详见<a class="link"   href="https://www.npmjs.com/package/hexo-all-minifier?activeTab=explore" >hexo-all-minifier <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）。前些日子正好学习了一些CI和Docker相关的知识，也了解了微服务和无服务（serverless）部署的基础知识，正好成为了研究部署工作的契机。</p>
</blockquote>
<p>在我不知道什么时候，腾讯云的整个Serverless架构都发生了变化：</p>
<ul>
<li>Cloudbase 云开发：整个腾讯云微服务/无服务（serverless）的部署框架和底层平台实现，<strong>按月订阅</strong>并提供全部服务
<ul>
<li>静态网页托管服务</li>
<li>网络优化服务，如CDN</li>
<li>后端即服务，如数据库、小程序后台等</li>
<li>Serverless服务，如云函数等</li>
</ul>
</li>
<li>Webify 云开发：Cloudbase的Web应用托管服务接口，对标vercel的微服务平台，提供了网页部署功能的封装，支持<strong>按量计费</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230613224037.png"
                      alt=""
                ></p>
<p>虽然腾讯的文档很乱（痛批腾讯的一贯风格），不过整个Webify的体验是明显的好于Cloudbase+静态网页托管的流程的（虽然应该只是做了一层业务封装），整个体验上看起来是对标Vercel的，甚至支持一键部署。</p>
<p>上图就是现在我使用的腾讯云业务现在彼此的关系，所谓“Web应用托管”其实就是Serverless部署服务+提供“快捷网页托管”相关的Docker镜像，即新方案应该就是<strong>旧方案的业务整合+拆分</strong>，并没有本质上的区别。</p>
<blockquote>
<p>Web 应用托管采用<strong>按量计费</strong>模式，自身能力免费，应用按照其使用的 TCB 底层环境的各项资源独立计费，如静态托管等。</p>
</blockquote>
<h3 id="Github-Page">Github Page</h3>
<p>由于腾讯云的方案无法做加载优化（资源压缩处理）和SEO优化，原因是其Hexo模板的Dockerfile是写死的（而且node版本特别老），无法进行定制，因此我被迫尝试了其他方案进行尝试。这里先尝试了Github Page，因为其开源且文档丰富。</p>
<p>我对这里方案的要求有下：</p>
<ul>
<li>体验对标收费的Serverless服务，即不创建额外仓库，且通过Action自动化构建流程</li>
<li>解决原有环境问题，支持进行SEO和加载优化
<ul>
<li>使用<code>hexo-all-minifier</code> 做资源压缩和加载速度优化</li>
<li>使用<code>hexo-seo</code> 做SEO优化</li>
</ul>
</li>
</ul>
<h4 id="部署教程">部署教程</h4>
<blockquote>
<p>这里参考了<a class="link"   href="https://hexo.io/zh-cn/docs/github-pages.html" >Hexo官方教程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<ol>
<li>创建Github Pages服务，根据Github Pages文档我们需要将hexo仓库更名为 <code>username.github.io</code> （注意这里username和我们的用户名必须完全匹配）</li>
<li>编写Github Action工作流
<ol>
<li>使用 <code>node --version</code> 指令检查你电脑上的 Node.js 版本，并记下该版本</li>
<li>在储存库中建立 <code>.github/workflows/pages.yml</code>，具体代码如下，注意将<code>node-version</code> 字段的<code>16</code> 改成自己环境里的node版本</li>
<li>工作流定义在Push后会运行部署流程，并将生成的页面放在<code>gh-pages</code> 分支中（由<code>peaceiris/actions-gh-pages@v3</code> 定义）</li>
</ol>
</li>
</ol>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .github/workflows/pages.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">name:</span> <span class="string">Pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span> <span class="comment"># default branch</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">pages:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">permissions:</span></span><br><span class="line">      <span class="attr">contents:</span> <span class="string">write</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="number">16.</span><span class="string">x</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&quot;16&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">NPM</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/cache@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.OS</span> <span class="string">&#125;&#125;-npm-cache</span></span><br><span class="line">          <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">github_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br></pre></td></tr></table></figure></div>
<ol>
<li>在仓库的Settings → Github Pages → Source中设置分支为<code>gh_pages</code></li>
<li>访问 <a href="https://kiritoking.github.io">username.github.io</a> 就可以看见自己的网站啦</li>
</ol>
<h4 id="添加CNAME解析">添加CNAME解析</h4>
<ol>
<li>在<code>./source</code> 目录下添加<code>CNAME</code> 文件，内容你自己的域名，如下所示</li>
</ol>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">chlorinec.top</span><br></pre></td></tr></table></figure></div>
<ol>
<li>在域名提供商处添加或修改DNS解析，我的是DNSPod，如下图所示</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://secure2.wostatic.cn/static/kTtVCVJFznswWDgaFhhD1Y/image.png?auth_key=1688837942-843UhhkReGXiLpy1uBAnud-0-6ca7faae1be25c0065739b219b1bacb7"
                      alt=""
                ></p>
<h4 id="CDN加速">CDN加速</h4>
<p>在更新完博客部署方式的几小时后，我发现我的域名已经不能正常访问了，感叹一下防火墙的速度，要是搜索引擎的爬虫有这一半快就好了。</p>
<p>学习过计网的同学都知道，CDN是一种部署在端侧的缓存加速方案，CDN（内容分发网络）负责缓存通过网络的内容，并将这些缓存的内容传递给就近的用户，使用户可以从就近的CDN源获取而不是远方的源服务器。</p>
<p>正常情况下CDN是加速网络访问，缓解主信道压力的手段，在某些不可言说的特殊网络波动因素的影响下，CDN就成了拯救页面可访问性的救命稻草。</p>
<p>这里我选择Cloudfare的国内服务进行CDN加速服务，因为其对个人开发者提供<strong>免费</strong>服务。</p>
<ol>
<li>创建Cloudfare账号，点击创建网站，输入你的域名，选择服务套餐</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://secure2.wostatic.cn/static/m2WQH29E72vFrQjaHZDEXT/image.png?auth_key=1688922885-g32AXVHuS2LkqE9rRmjacV-0-c1fcb49042ca97a660c2e6b2892e5417"
                      alt=""
                ></p>
<ol>
<li>在你的域名注册机构→域名管理处更改DNS提供商为Cloudfare提供的两个链接，这里以腾讯云为例</li>
</ol>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">dayana.ns.cloudflare.com</span><br><span class="line">rob.ns.cloudflare.com</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://secure2.wostatic.cn/static/9LkaVc8c2XMvVkCFNqQLfj/image.png?auth_key=1688923173-t1gampvBGrSXw1XLKo4Guo-0-3e40b5172ed1e2d58797b7cd4127782c"
                      alt=""
                ></p>
<ol>
<li>等待一段时间后，Cloudfare就会接管DNS解析和CDN加速，如果你验证了邮箱也会收到邮件通知</li>
</ol>
<p>当域名配置了HTTPS时可能会遇到“重定向次数过多”的问题，这是CDN的回源政策导致的，解决方案如下：</p>
<p>Cloudface默认提供了4种**回源（用户请求CDN服务器，CDN服务器请求源服务器再返回给用户的过程）**政策，当源网站和CDN的HTTPS（SSL）设置冲突时就会发生循环重定向。</p>
<ul>
<li>关闭：完全不访问源站HTTPS</li>
<li>灵活（Flexible，默认情况）：当HTTPS没有配置或不受信任时，会访问HTTP 问题就出在这里，当源站支持HTTPS且配置了HTTP转HTTPS时，Flexible策略会访问HTTP，HTTP再通过源站转化成对HTTPS的访问，此时<strong>又会回源到HTTP</strong>，形成一个重定向闭环。将策略改成完全即可解决。</li>
<li>完全：必须使用HTTPS访问</li>
<li>完全（严格）：必须使用受信任的HTTPS证书访问</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://secure2.wostatic.cn/static/nNKgTwh1UdXzJiv1VXiEig/image.png?auth_key=1688923559-k4sqQav6HMsN6iszq6Pzaj-0-c88ec5649933c4a84ea06aa6f4fa1cc1"
                      alt=""
                ></p>
<h3 id="Vercel部署">Vercel部署</h3>
<p>Vercel部署很简单，直接注册账号选仓库就行，一切都是自动化的。</p>
<h2 id="SEO-优化">SEO 优化</h2>
<hr>
<h2 id="参考链接">参考链接</h2>
<ul>
<li><a class="link"   href="https://blog.skk.moe/post/use-nextjs-and-hexo-to-rebuild-my-blog/#Nei-Rong-Guan-Li-Cong-Hexo-Dao-Next-js" >使用 Next.js + Hexo 重构我的博客 | Sukka’s Blog (skk.moe) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/7208946311885586492" >通过Hexo + Github Pages部署你的react项目 - 掘金 (juejin.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.cnblogs.com/suguangti/p/14702744.html" >Typora + PicGo-Core + 腾讯云COS 图床配置 - MrSu - 博客园 (cnblogs.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://picgo.github.io/PicGo-Core-Doc/zh/guide/getting-started.html" >快速上手 | PicGo-Core <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://support.typoraio.cn/Upload-Image/#picgo-core-command-line-opensource" >Upload Images - Typora Support (typoraio.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/qq_42365842/article/details/124693106" >Picgo上传图片添加时间戳前缀_picgo super prefix_葡萄汁suki的博客-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/6844903517853843470" >Hexo遇上Travis-CI：可能是最通俗易懂的自动发布博客图文教程 - 掘金 (juejin.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://webify.cloudbase.net/docs/introduction/" >概述 | 云开发 Webify (cloudbase.net) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://docs.cloudbase.net/" >首页 | 云开发 CloudBase - 一站式后端云服务 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://ohevan.com/vercel-hexo-configuration.html" >使用 Vercel 和 Github 部署 Hexo 安装以及使用教程 - EvanNotFound’s Blog (ohevan.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>Hexo</tag>
        <tag>网站搭建与部署</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML 表单（form）相关知识</title>
    <url>/posts/2950425643/</url>
    <content><![CDATA[<p>自己也做了一段时间前端了，最近做项目的时候才发现自己对<strong>表单（form）元素</strong>一无所知，当年写登录框都是两个<code>&lt;input&gt;</code>直接拼在一起的（笑）。今天就专门来学习一下表单相关的知识。</p>
<p>本篇将从最基础的表单知识（如定义和概念）等入手 <s>（毕竟之前也没系统了解过）</s> ，再理解表单的本质：我们为什么需要表单、如何设计表单、与POST之间的联系等，最后再了解<em>antd</em>中的表单元素<code>&lt;a-form&gt;</code>的使用与实践。</p>
<span id="more"></span>
<h2 id="什么是表单">什么是表单</h2>
<p>这是一个最基础的问题，就是表单（form）的定义到底是什么样的？（当然，这里只讨论最基本的HTML表单）</p>
<blockquote>
<p><strong>HTML 表单用于搜集不同类型的用户输入</strong>。HTML 表单包含<em>表单元素</em>，表单元素指的是不同类型的 input 元素、复选框、单选按钮、提交按钮等等。</p>
<p>——W3CSchool</p>
</blockquote>
<p>从上述定义来看，我们可以简单地将表单（form）理解为<strong>浏览器内建的一种用户输入集合的数据结构</strong>，浏览器内建的好处在于其通用性和性能优化（基于C++而非JS）。</p>
<p>表单标签<code>&lt;form&gt;</code>支持的元素有：</p>
<ul>
<li><code>&lt;input&gt;</code>：最重要的表单元素有多种多样的类型
<ul>
<li>常用的类型：text，password，checkbox，radio，file，button，submit</li>
<li>不太常用的类型：hidden（隐藏的input），reset</li>
<li>隐藏元素的作用：在表单中添加额外信息（如用户信息标识），且对用户不可见</li>
</ul>
</li>
<li><code>&lt;label&gt;</code>：与input连用，<code>for</code>属性与input的<code>id</code>属性配合，示例如下：</li>
</ul>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">“name”</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>&lt;select&gt;</code>：下拉选框，示例如下</li>
</ul>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;city&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>&lt;textarea&gt;</code>：大段文本框（支持多行）</li>
</ul>
<h3 id="如何提交表单">如何提交表单</h3>
<p>我们有了收集信息的表单元素，要如何将信息提交给服务器呢？</p>
<ul>
<li><code>submit</code> 按钮为我们在页面上提交了一个显式的提交入口，除此之外，其他默认方法（如Enter提交）也可以触发提交操作</li>
<li><strong>通过<code>&lt;form&gt;</code>的<code>action</code>和<code>method</code>属性定义提交操作</strong></li>
</ul>
<p>HTML 表单的提交行为有如下规则：</p>
<ul>
<li><strong>表单只会提交表单中有<code>name</code>属性的表单元素</strong> （这一点非常重要）</li>
<li><code>action</code>虽然名字叫“行为”，但是它实际上<strong>只接收URL</strong> (绝对或相对) ，提交表单时会向这个URL发送HTTP请求（如我的博客中有一个表单，<code>action</code>值为<code>statistics.asp</code>，那么最终请求的URL就是<code>chlorinec.top/statistics.asp</code>）
<ul>
<li>如果<code>action</code>属性被忽略，则<strong>默认是当前页面</strong></li>
</ul>
</li>
<li><code>method</code>属性对应了HTTP请求头中的方法
<ul>
<li><strong>默认情况下为GET方法，在Query中添加信息</strong> （重要！）
<ul>
<li>适用于简单表单、安全要求较低</li>
<li>明文存储，容易泄露隐私</li>
</ul>
</li>
<li><strong>更多情况下，应该使用POST方法</strong>，它将表单信息存储在报文负载中而非Query Param中
<ul>
<li>需要注意的是，<strong>表单数据的格式默认并非是JSON格式的</strong>，因此在后端解析表单数据需要使用专用的表单解析方法</li>
<li>可以通过额外定义的方法，使原生表单传递JSON格式数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>默认的POST表单报文如下（示例来自MDN）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST / HTTP/2.0</span><br><span class="line">Host: foo.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 13</span><br><span class="line"></span><br><span class="line">say=Hi&amp;to=Mom</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h3 id="如何验证表单">如何验证表单</h3>
<p>表单相比一个个单列的数据输入元素的优势就在于它提供了一种将数据组织起来的形式，这样一种（浏览器内建支持）聚合的数据结构可以为我们提供很多便利：</p>
<ul>
<li>对很多操作进行预封装，如提交操作、清空操作，而不必再手写一个数据结构</li>
<li>遵守表单规范就可以<strong>用于提交的数据集合格式使在不同网页间保持统一</strong></li>
<li>集合的形式为我们在更高层次的数据操作提供了便利，如<strong>数据校验、数据组合</strong>等（也可以预封装有关）</li>
</ul>
<p>那么，为什么我们需要验证表单呢？这就要提到一句著名的原则了：后端永远不要相信前端传回的数据（前端亦然）。换句话说就是，<strong>你在任何情况下拿到了源自非自己的数据时都应该校验格式</strong>，你的后端同事如此，你的用户更应如此！<s>因为你永远不知道你的顾客会不会在你的酒馆点一份炒饭然后拿起汤姆逊一顿突突把服务器打得稀巴烂。</s></p>
<p>对于数据校验（data validation），一般有两种方式：</p>
<ul>
<li>客户端校验：在HTML中这发生在浏览器中，它可以<strong>实时</strong>地反馈用户的输入结果，通常发生在正式提交之前，有较好的用户体验
<ul>
<li>HTML校验：自定义性较差，但性能较好（由浏览器的C++代码实现）</li>
<li>JS校验：自定义程度高，一般用于复杂表单</li>
</ul>
</li>
<li>服务端校验：需要在表单提交后才能得到校验结果，用户体验较差，通常只作为数据库清洁的<strong>最后防线</strong>（主战场仍在客户端）</li>
</ul>
<h4 id="HTML校验：校验属性">HTML校验：校验属性</h4>
<p><strong>校验属性</strong>允许你对表单元素定义一些规则，除此之外你还可以设计一些<strong>CSS伪类来自定义校验结果的反馈形式</strong>。</p>
<ul>
<li><strong>CSS伪类：<code>:valid</code>和<code>:invalid</code>将分别定义校验通过和失败时表单元素的样式</strong></li>
<li><code>required</code> 属性：必填字段</li>
<li><code>pattern</code> 属性：基于<strong>正则表达式</strong>进行字符串匹配</li>
<li>限制输入的长度：<code>minlength</code>和<code>maxlength</code></li>
</ul>
<h4 id="JS校验">JS校验</h4>
<blockquote>
<p>JS中直接通过DOM或者ref去读取表单元素的值进行校验（设置valid状态）是非常灵活的，这里就不再赘述。</p>
</blockquote>
<p>JS和DOM提供了<strong>一套用于校验的API</strong>来反应校验结果到元素上，可以在绝大多数的<strong>表单元素</strong>中调用（<code>HTMLXXXElement</code>），<strong>校验成功与否（invalid事件）仍会反映在伪类上</strong>！</p>
<p>校验相关<strong>方法</strong>：</p>
<ul>
<li><code>checkValidity()</code>方法会立刻进行一次校验，返回bool值，可能<strong>触发<code>invalid</code>事件</strong></li>
<li><code>reportValidity()</code>方法会返回当前校验结果，并反映校验消息给用户</li>
<li><code>setCustomValidity(message)</code>方法为元素添加一个自定义的错误消息；如果设置了自定义错误消息，该元素被认为是无效的，则显示指定的错误。</li>
</ul>
<p>校验相关<strong>属性</strong>：（懒得打字了，直接截图MDN了）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230531123548.png"
                      alt=""
                ></p>
<h2 id="深入表单">深入表单</h2>
<h3 id="为什么我们需要表单">为什么我们需要表单</h3>
<p>其实如果从程序员角度出发，这个问题已经被我们回答了：<strong>如果有一个已经造好了的轮子，它能满足我们的现有需求，还具有性能优势和兼容性优势，我们没有任何理由不去使用它而去再造一个自己的轮子</strong> —— 这就是使用表单的最淳朴的理由。</p>
<p>但现在我们跳脱出程序员的框架，假设我们是一个产品经理或者说从用户的角度，我们再思考一下这个问题。</p>
<p>首先，需要明确一点的是，表单提交（或者说信息填写）对于用户来说是烦人的，这点从你每次填问卷星时的心情就能看出。那表单要如何改善这个填写体验呢？</p>
<p>答案仍是<strong>内建功能</strong>，像<strong>自动补全、自动校验</strong>等功能都是浏览器提供给表单的功能，如果你单列每个元素，再使用自己定义的数据结构进行集合和提交，就无法调用这些浏览器功能，这是表单独一无二的体验（与浏览器功能深度绑定），而不仅仅是免去了重复造轮子这么简单。</p>
<blockquote>
<p>对于浏览器（底层实现）而言，表单为信息收集提供了统一的标准和接口，有助于其对该功能进行专门的优化和实现。</p>
<p>对于开发者而言，表单为信息收集提供了一套预定义的行为，简化了开发步骤。</p>
<p>对于用户而言，表单为信息填写优化了流程，自动填充等功能优化了用户体验。</p>
</blockquote>
<h3 id="如何设计表单">如何设计表单</h3>
<div class="note info"><p>设计部分内容，待补充</p>
</div>
<h3 id="理解表单数据">理解表单数据</h3>
<p>HTTP中，提交数据的方式，最常用的就是GET和POST，这也对应着表单的两种提交方式。</p>
<ul>
<li>GET把参数编程键值对通过QueryString的方式放在URL尾部，如<code>example.com/api/user?id=123456&amp;region=zh-cn</code></li>
<li>POST把数据以键值对的方式放在HTML报文的Payload中，但这个方式一定是键值对吗？其实不然。我们参考W3C文档发现提交表单会经历如下步骤：
<ol>
<li>进行表单校验，确定哪些控件值要被纳入（valid且有<code>name</code>属性，即所谓的successful controls）</li>
<li>构建<strong>键值对</strong>（control-name/current-value）的数据结构</li>
<li>根据指定的编码类型<strong>对键值对进行编码</strong></li>
<li>提交编码后的值到<code>action</code>指定的url</li>
</ol>
</li>
</ul>
<p>从上面的步骤中我们可以清楚地看到，在第三步中我们可以修改编码类型，对应表单的<code>enctype</code>属性，而这个属性与HTTP请求头中的<code>Content-Type</code>字段相对应：</p>
<ul>
<li><code>application/x-www-form-urlencoded</code>：<strong>GET方法的默认编码，且不可修改</strong>；POST也默认为此编码，但表达当时略有不同（直接写成键值对而非Query）</li>
<li><code>multipart/form-data</code>：一种分部二进制的编码方式，使用<strong>表单上传文件</strong>时必须使用此格式. 请求体被分割成多部分，每部分使用 --boundary分割</li>
<li><code>application/json</code>：JSON格式，但<strong>老版本HTML原生表单并不支持这种格式，只有新版本的HTML才支持</strong>，对于不支持的格式会Fallback到默认值
<ul>
<li>根据键值对自动生成对象，并序列化为JSON</li>
<li><strong>当表单存在多个重名的表单域时，按JSON数组编码</strong></li>
<li><strong>当表单控件名（<code>name</code>属性）出现了复杂结构，如嵌套对象（<code>obj[key]</code>）或数组（<code>arr[0]</code>）这样的结构时，会自动生成对应对象</strong>，其中缺失的数组序号会用<code>null</code>替代</li>
<li>JSON还可以用于<strong>文件上传</strong></li>
</ul>
</li>
</ul>
<p>一个使用JSON的表单例子如下：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">enctype</span>=<span class="string">&#x27;application/json&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&#x27;pet[0][species]&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;Dahut&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&#x27;pet[0][name]&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;Hypatia&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&#x27;pet[1][species]&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;Felis Stultus&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&#x27;pet[1][name]&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;Billie&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>其生成的JSON如下：</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;pet&quot;</span><span class="punctuation">:</span>  <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;species&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Dahut&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hypatia&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;species&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Felis Stultus&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Billie&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>
<h2 id="组件库中的表单">组件库中的表单</h2>
<p>这里以<strong>Antd1.x+Vue2</strong>为背景介绍组件库中的表单概念，与HTML表单的区别与共性，以及具体使用方法。不同的组件库的表单设计思路可能略有不同（如mui和antd），不同框架对表单的操作模式也不同，但总体设计思路都是大同小异的。</p>
<blockquote>
<p>antd中的表单和表单项都使用antd的<code>Grid</code>布局（24等分的flex布局）。</p>
</blockquote>
<ul>
<li>在使用表单时需要用<code>this.form = this.$form.createForm(this, [options])</code>进行绑定（或者说包装）
<ul>
<li>经 <code>Form.create()</code> 包装过的组件会自带 <code>this.form</code> 属性，即可以<strong>直接在组件的<code>this</code>中获取表单的属性和方法</strong></li>
<li><code>getFieldsXXX(args)</code> 方法可以获取表单中控件的值，args用于指定控件，留空则获取所有</li>
<li>使用<code>this.form.validateFields(values, err)</code>进行表单校验并获取表单值</li>
</ul>
</li>
<li><strong>使用<code>v-decorator</code>指令进行表单绑定而不是<code>name</code>属性</strong></li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a class="link"   href="https://www.w3school.com.cn/html/html_forms.asp" >HTML 表单 (w3school.com.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Learn/Forms/Sending_and_retrieving_form_data" >发送表单数据 - 学习 Web 开发 | MDN (mozilla.org) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Learn/Forms/Form_validation" >表单数据校验 - 学习 Web 开发 | MDN (mozilla.org) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://imququ.com/post/four-ways-to-post-data-in-http.html" >四种常见的 POST 提交数据方式 | JerryQu 的小站 (imququ.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.webhek.com/post/html-json-form-submission/" >JSON编码格式提交表单数据详解 – WEB骇客 (webhek.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://blog.51cto.com/cnn237111/1113546" >深入理解POST的本质_51CTO博客_get post本质区别 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.woshipm.com/pd/4332910.html" >表单设计：掌握表单设计方法（表单体验篇） | 人人都是产品经理 (woshipm.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.woshipm.com/pd/4369965.html" >B端页面——详细表单设计流程 | 人人都是产品经理 (woshipm.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>表单</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖与节流的应用与实现</title>
    <url>/posts/1274785621/</url>
    <content><![CDATA[<p>防抖（debounce）和节流（throttle）都用于合并多次频繁的事件请求，使之只调用一次回调函数；不同之处在于防抖要求在请求稳定之后才会调用一次函数，而节流要求必须间隔指定时间才能触发一次回调函数，二者使用场景不同。但从个人体验来说，一般情况下防抖处理的回调函数调用机会比节流处理要更少。</p>
<span id="more"></span>
<h2 id="函数防抖（debounce）">函数防抖（debounce）</h2>
<blockquote>
<p>在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</p>
</blockquote>
<p>防抖的主要应用就是防止在某些刷新频繁的场景中回调也被频繁调用，<strong>如：搜索框刷新内容、resize更新页面布局等</strong>，避免回调的高频调用可以减小后端压力、提高前端响应性能。</p>
<p>主要实现方法就是<strong>利用闭包（closure）设置一个计时器，在计时器到达时就运行回调并清除计时器；若计时器途中事件源又刷新（发起新事件），就重置计时器，直到不再唤醒新事件为止</strong>。</p>
<p>简单的实现如下，注意闭包处理的函数调用要更改<code>this</code>的指向：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myDebounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="variable language_">this</span></span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(context, args)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="函数节流（throttle）">函数节流（throttle）</h2>
<blockquote>
<p>当持续触发事件时，有规律的每隔一个时间间隔执行一次事件处理函数。</p>
</blockquote>
<p>防抖的目的在于设定一个回调函数执行的间隔，也是用于合并请求。</p>
<p>节流和防抖的区别在于<strong>防抖只会在连续的事件周期结束时执行一次</strong>，而节流会<strong>在事件周期内按间隔时间有规律的执行多次</strong>。</p>
<p>简单的实现如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myThrottle</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        <span class="keyword">if</span> (now - prev &gt;= delay) &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">            prev = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="使用-loadash-库">使用 loadash 库</h2>
<blockquote>
<p>Lodash 是一个一致性、模块化、高性能的 JavaScript 实用工具库。</p>
</blockquote>
<p>这里就要说一点题外话了，我记得很久之前我在知乎上看到过一个问题：如何看待npm中add包下载数量超多少多少万？</p>
<p>然后下面的回答几乎清一色的是嘲讽前端程序员的平均水准的（虽然确实写前端的综合素质确实emmm，至少在数据结构和算法上确实不是强项吧），什么连加法都不会、奇偶数判断都不会云云，回答里充满了快活的空气。</p>
<p>但我看到了有一个正经的回答，原话我已经不记得了，我只记得一句话大意是：<strong>你们只看到了这个库的核心代码只有几行来实现加法，却没看到它对应的测试库和用例有好几千行</strong>。</p>
<p>我想这就是我们在项目中即使是一些比较简单的功能也使用社区中经过考验的库而不是自己造轮子去实现的原因（当然加法的例子还是太夸张了，除非你的客户经常有那种边界需求之类的），我自己也很喜欢造轮子，像写写stl、js解释器之类的，但这种玩具级的轮子也就放在自己的项目里玩玩就好，真正放到业务代码里还是应该尽量选择经过社区验证的库代码比较好（当然那些三无库除外）。</p>
<h3 id="debounce">_.debounce</h3>
<p><code>_.debounce(func, [wait=0], [options=])</code> 用于创建一个防抖动函数，该函数会从上一次被调用后，延迟 <code>wait</code> 毫秒后调用 <code>func</code> 方法。 debounced（防抖动）函数提供一个 <code>cancel</code> 方法取消延迟的函数调用以及 <code>flush</code> 方法立即调用。</p>
<ul>
<li>可以提供一个 options（选项） 对象决定如何调用 <code>func</code> 方法
<ul>
<li><code>options.leading</code> 与|或 <code>options.trailing</code> 决定延迟前后如何触发（注：是 先调用后等待 还是 先等待后调用）</li>
</ul>
</li>
<li><code>func</code> 调用时会传入最后一次提供给 debounced（防抖动）函数 的参数。 后续调用的 debounced（防抖动）函数返回是最后一次 <code>func</code> 调用的结果。</li>
<li><em>(Function)</em>: 返回新的 debounced（防抖动）函数。
<ul>
<li><code>cancel</code> 方法会取消当前调用</li>
<li><code>flush</code> 方法会清除计时器并立刻调用</li>
</ul>
</li>
</ul>
<h3 id="throttle">_.throttle</h3>
<p><code>_.throttle(func, [wait=0], [options=])</code> 创建一个节流函数，在 wait 秒内最多执行 <code>func</code> 一次的函数。<strong>该函数提供一个 <code>cancel</code> 方法取消延迟的函数调用以及 <code>flush</code> 方法立即调用。</strong></p>
<p>具体参数和返回与 <code>debounce</code> 几乎一致。</p>
<h3 id="按需引入">按需引入</h3>
<p>loadash 实际上是一个相对较大的库（如果你只用到其中一两个功能的话），这时就需要<strong>按需引入来减小打包大小</strong>。</p>
<ul>
<li>如果你使用webpack等构建工具，可以使用其内建的tree-shaking功能减小打包体积
<ul>
<li>使用<em>loadash-es</em>这个ES模块化的分支，不需要像更改引入入口一样改变使用习惯，直接引用如 <code>import &#123;debounce&#125; from 'loadash-es'</code></li>
<li>直接取对应成员，如 <code>import throttle from 'loadash/throttle'</code>，缺点是需要知道对应的函数到底存储在哪个js中</li>
</ul>
</li>
<li>使用官方提供的babel插件<a class="link"   href="https://github.com/lodash/babel-plugin-lodash" >lodash/babel-plugin-lodash <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>转译，在babel编译代码时，对引入<code>lodash</code>的语句进行替换，达到下文中<strong>更改引入入口</strong>的效果（相当于是利用babel帮你实现了上面的过程）</li>
<li>单独安装对应的loadash包，如你只使用<code>loadash.add</code>就只安装这个包而不安装整个loadash</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a class="link"   href="https://juejin.cn/post/7069218262634102798" >【建议收藏】这四个方法，让你使用lodash后js体积减少70kB - 掘金 (juejin.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/6844903669389885453" >7分钟理解JS的节流、防抖及使用场景 - 掘金 (juejin.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/6844903848230780941" >VUE防抖与节流的最佳解决方案——函数式组件 - 掘金 (juejin.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>防抖与节流</tag>
        <tag>闭包</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>我的个人密码管理方案 - KeePass</title>
    <url>/posts/3202227099/</url>
    <content><![CDATA[<p>大约高中的时候我就接触了一些密码管理软件，如1Password这些，但最终由于上手还是有些难度（那个时候也没有心思折腾）而回归了传统的 passwords.txt 方案。</p>
<p>早些年（大概在大一暑假）的时候，我在偶然的一次多端密码同步需求下开始重新了解密码管理方案，最终选择了 Keepass 这一开源方案，当初潦草配置了一下 Keepass 满足了我的基本需求（密码存储+多端同步+自动填充），但仍有很多小bug或者其他让我用得不是很舒心的地方困扰我。</p>
<p>于是，在另一个契机下~~（指公司电脑里需要登录一个东西但是我用keepass生成的16位强密码记不住又不能粘贴密码这样一个非常麻烦的事情）~~，我开始在另一台电脑重新配置我的 Keepass，并借此机会改善我的Keepass解决方案。</p>
<h2 id="为什么选择-Keepass">为什么选择 Keepass</h2>
<p>最初的情况是这样的，我开开心心的用我的OneDrive同步我心爱的Password.txt，并每日使用Ctrl+F寻找密码；但是，这并不是事情的全部，由于我并不是每次都能记住要在Password里记上一笔（特别是在网页里），但大部分Chromium浏览器又自带一个密码管理器，因此大部分网页密码就存在了浏览器里。</p>
<p>彼时我已经从Chrome投奔了Edge阵营~~（现在又想投奔回来因为我的Edge太卡了）~~，在Edge里也已经有了几百条密码记录，得益于微软账户的同步，我在手机和其他设备上也可以访问这些密码（浏览器中）。</p>
<p>这时，有一天我突发奇想，想要大统一密码方案，比如我的QQ在网页上、在应用里、在各种地方，都应该可以使用同一个密码和同一个服务进行填充（是的，我最初的需求就是因为我不记得我电脑上重置QQ密码是存在哪个网页上了，然后就经常找不到密码）。</p>
<p>正好，我发现了Edge也提供了类似的填充服务（在手机中设置），但我发现它并不好用，比如经常找不到或者无法调出，也无法方便地管理密码。也对，毕竟它本职就是一个浏览器，这只是一个附加功能罢了。</p>
<p>遂放弃Edge，开始寻找其他解决方案。</p>
<h3 id="Why-not-others">Why not others?</h3>
<p>首先我肯定先看了1Password，LastPass等方案，但它和别的方案（如BitWarden）一样有一个我不能接收的地方：贵。</p>
<p>首先对于我这种<strong>轻度需求</strong>的人来说，它没有免费订阅，而且订阅费都是刀乐，实在有点难顶。</p>
<p>所以，<s>选择Keepass的原因其实是没钱</s>，它是开源的，缺了什么功能也可以自定义，何乐而不为呢？遂一拍即合，开整！</p>
<h2 id="最初的-Keepass-方案">最初的 Keepass 方案</h2>
<p>最初的Keepass方案的参考资料已经不可考了~~，我记得甚至有小红书的资料~~，这里我就简述一下方案思路和现状。</p>
<h3 id="需求分析">需求分析</h3>
<p>由于我个人本来就是一个明文TXT存密码的人，生在这个地方也明白自己的隐私其实没什么好保护的，甚至都没什么人关心，只要保护好财产相关的隐私就可以了。因此，我对于互联网密码的安全性其实没有特别高的要求。</p>
<p>综上，我提出了以下几点需求，优先级依次递减：</p>
<ul>
<li>便捷且统一的密码管理和自动填充（网页和应用）</li>
<li>全平台多端同步（PC/Windows+Android+iOS）</li>
<li>自动生成和保存密码（可以在我注册时自动提示保存）</li>
<li>All-In-One体验（如集成TOTP认证）</li>
<li>安全性保证（至少不是明文）</li>
</ul>
<h3 id="Windows-端与基础配置">Windows 端与基础配置</h3>
<p>最初的方案使用了官方的Keepass客户端，但是官方客户端UI比较简陋，功能也不完全，需要安装很多对应的插件才能满足需求。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230522233015.png"
                      alt="image-20230522233014611"  
                >
<h4 id="数据底层与同步方案">数据底层与同步方案</h4>
<p>采用了单密码认证数据库+OneDrive同步的方案，这方面不在赘述。</p>
<h4 id="界面和逻辑优化插件">界面和逻辑优化插件</h4>
<ul>
<li>KPEnhancedEntryView：优化了条目列表的显示</li>
<li>YetAnotherFaviconDownloader：自动下载网页图标</li>
<li>SourceForgeUpdateChecker：自动检查插件更新</li>
<li>简体中文语言包：略</li>
</ul>
<h4 id="自动填充配置">自动填充配置</h4>
<p>KeePass使用树状目录组织密码，树的层级间会继承父级的规则，如自动填充、模板等，因此只需要在根目录配置好自动填充规则，所有条目都会共享这个规则，当然你也可以对特定条目/层级作自定义规则。</p>
<ol>
<li>在根目录处打开该层配置选项。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230522233608.png"
                      alt=""
                ></p>
<ol start="2">
<li>在自动输入栏里输入配置：<code>&#123;USERNAME&#125;&#123;TAB&#125;&#123;PASSWORD&#125;&#123;DELAY 100&#125;&#123;ENTER&#125;</code>（这里是一个模拟键盘输入的过程，意思是先输入USERNAME，按下TAB然后输入PASSWORD，最后等待100ms后按下回车），你也可以按照自己的喜好进行配置</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230522233703.png"
                      alt=""
                ></p>
<h4 id="自动填充服务优化">自动填充服务优化</h4>
<p>这是最重要的一步，毕竟自带的自动填充真的甚至不能说差强人意，连浏览器场景都不好应对。</p>
<p>首先是应用程序场景，我选择 <strong>AutoTypeSearch</strong> 插件来实现快捷键搜索Entry+选择后运行自动填充过程。</p>
<p>在浏览器场景下有以下几种方案可选：</p>
<ul>
<li>KeepassHttp：老牌方案，通过RPC传输SHA-256加密后的密码到浏览器，调用浏览器的自动填充（而不是模拟输入），但问题是也太老牌了（上次更新是6年前）</li>
<li>WebAutoType：在网页中运行自动输入过程，但个人体验下来不是很好（因为网页很多表单不规范导致模拟输入不好实施）</li>
<li>Kee Vault：我当时不知道从哪里得到的方案，个人感觉很方便，因此以下主要介绍该方案</li>
</ul>
<h5 id="Vault-方案">Vault 方案</h5>
<blockquote>
<p>Kee Vault的在线服务是商业服务（虽然起步是免费的），而连接本地Keepass是免费服务</p>
</blockquote>
<p><a class="link"   href="https://www.kee.pm/" >Vault <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的使用非常简单，只需要三步：</p>
<ol>
<li>在浏览器安装<a class="link"   href="https://chrome.google.com/webstore/detail/kee-password-manager/mmhlniccooihdimnnjhamobppdhaolme" >Vault插件 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>给Keepass安装KeePassRPC插件</li>
<li>在浏览器端连接二者的RPC过程</li>
</ol>
<p>而它的优点有：</p>
<ul>
<li>免配置，很方便</li>
<li>直接调用自动填充而没有模拟输入</li>
<li>可以在注册新账号（出现密码的场景）时提示你保存密码</li>
</ul>
<h4 id="使用体验优化">使用体验优化</h4>
<ul>
<li>快速解锁：KeePassWinHello - 调用Windows Hello解锁数据库，但目前体验下来不太稳定（经常没法唤醒，得输入密码）</li>
<li>条目模板：KPEntryTemplates - 这个我没有深究，不过挺重要的，让你新建条目的时候更轻松一点。</li>
</ul>
<p>没有模板的界面是这样的：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230522234538.jpg"
                      alt=""
                ></p>
<p>有模板的界面（配置好后）是这样的：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230522234600.jpg"
                      alt=""
                ></p>
<h3 id="移动端配置">移动端配置</h3>
<p>个人有一台Android设备和一台iPad OS设备，但主战场其实在Windows端，手机端基本只起到读取的作用，因此就简单配置了一下：</p>
<ul>
<li>
<p>OneDrive用于同步</p>
</li>
<li>
<p>Android：KeePass4Android</p>
<ul>
<li>优点：老牌方案，保持更新，稳定；支持<strong>快速解锁</strong>和本地缓存</li>
<li>缺点：部分界面优点过于老旧（如密码键盘）</li>
</ul>
</li>
<li>
<p>iPadOS：奇密（FantasyPass）</p>
<ul>
<li>这个方案我找了很久，其他方案要么太贵要么没法用（少功能如自动填充和同步）</li>
<li>优点：便宜（买断制），支持快速解锁、本地缓存和自动填充；对平板显示支持良好</li>
</ul>
</li>
</ul>
<h2 id="改进后的-Keepass-方案">改进后的 Keepass 方案</h2>
<p>这次在新电脑上重新配置Keepass，改进主要从以下几个方面入手：</p>
<ul>
<li>改进客户端体验：包括界面、解锁和输入等</li>
<li>改善密码管理：在一段时间使用Keepass+Vault后，加之之前浏览器导入的密码，数据库中存储了大量冗余或无效的密码，需要对其进行清理和合并</li>
<li>统一管理TOTP登录码：具体参考<a href="#%E5%9C%A8KeePass%E4%B8%AD%E7%AE%A1%E7%90%86TOTP">后文</a></li>
</ul>
<h3 id="Windows-客户端改进">Windows 客户端改进</h3>
<p>在新的客户端上我选择使用 KeepassXC，其是一个Keepass的开源客户端，支持Windows、Mac和Linux主流发行版（也可以自己编译）。</p>
<p>它最大的优点就是界面好看，且开箱即用。它虽然没有KeePass那么丰富的插件，但好处就是插件有的功能它自己都已经覆盖了，包括：</p>
<ul>
<li>Windows Hello 解锁</li>
<li>浏览器集成（Chromium+Firefox）</li>
<li>网页图标下载</li>
<li>TOTP生成</li>
</ul>
<p>使用它甚至都不需要教程，直接上手即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230523123957.png"
                      alt=""
                ></p>
<p>在个人习惯方面，我对其作了如下设置，尤其是<strong>最小化那一块非常重要（经常手滑关掉导致浏览器连不上）</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230523124230.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230523124313.png"
                      alt=""
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230523124334.png"
                      alt=""
                ></p>
<h3 id="移动端改进">移动端改进</h3>
<p>除了客户端换用了更现代的 KeepassDX 外没有什么改变。</p>
<h3 id="其他改进">其他改进</h3>
<h4 id="多URL方案">多URL方案</h4>
<p>BitWarden有内建的单条目对应多URL方案，但KeePass并不支持。我简单搜索了一下有以下几种解决方案：</p>
<ul>
<li><strong>克隆多条记录，并使用引用同步账号密码，设置不同URL</strong>（也是我的方案）</li>
<li>设置属性（需要插件或客户端支持），如KP2A_URL（KeePassHttp）、App（Keepass4Android）等</li>
</ul>
<h2 id="番外篇：2FA与TOTP">番外篇：2FA与TOTP</h2>
<h3 id="2FA">2FA</h3>
<p>2FA（双因素认证，2-Factor Authentication）是一种安全认证方案。</p>
<p>一般有三种因素可以作为认证一个人身份的凭据，如果用到了其中两种就是2FA：</p>
<ul>
<li><strong>秘密信息</strong>：只有该用户知道、其他人不知道的某种信息，比如<strong>密码</strong></li>
<li><strong>个人物品</strong>：该用户的私人物品，比如身份证、钥匙、手机</li>
<li><strong>生理特征</strong>：该用户的私人物品，比如身份证、钥匙。</li>
</ul>
<p>生活中常见的2FA有银行卡（银行卡+密码），网上支付（U盾+密码）等。但在手机普及的现代社会，<strong>手机</strong>就成为了2FA中除密码外个人物品中重要的一个认证物件。常见的实验方案有<strong>短信认证、发送认证通知</strong>等</p>
<p>但短信可以被伪基站等劫持，因此有一定的安全风险，这里就需要引入更安全的TOTP算法。</p>
<h3 id="TOTP算法">TOTP算法</h3>
<p>TOTP 的全称是&quot;基于时间的一次性密码&quot;（Time-based One-time Password）。它是公认的可靠解决方案，已经写入国际标准 <a class="link"   href="https://tools.ietf.org/html/rfc6238" >RFC6238 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>TOTP的认证过程其实相当简单：</p>
<ol>
<li>用户开启双因素认证后，服务器生成一个密钥（这个密钥就类似于一个<strong>token</strong>）</li>
<li>服务器提示用户扫描二维码（或者使用其他方式），把密钥保存到用户的手机。也就是说，服务器和用户的手机，现在都有了同一把密钥</li>
<li>用户登录时，手机客户端使用这个密钥和当前时间戳，生成一个哈希，有效期默认为30秒。用户在有效期内，把这个哈希提交给服务器</li>
<li>由于双端都持有同一个密钥，因此可以根据时间戳生成同一个Hash，跟用户提交的哈希比对。只要两者不一致，就拒绝登录。</li>
</ol>
<blockquote>
<p>注意，密钥必须跟手机绑定。一旦用户更换手机，就必须生成全新的密钥</p>
</blockquote>
<p>那么它的代码实现是不是也一样简单呢？答案是，是的。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">TC = floor((unixtime(now) − unixtime(T0)) / TS) <span class="comment"># TS: 有效时长，默认30s T0： 起始时间戳，默认为0</span></span><br><span class="line">TOTP = HASH(SecretKey, TC) <span class="comment"># HASH 为约定的哈希函数，默认是 SHA-1</span></span><br></pre></td></tr></table></figure></div>
<h3 id="在KeePass中管理TOTP">在KeePass中管理TOTP</h3>
<p>了解了上述原理后相信大家也就知道了，不必绑定某一家的Authenticator，直接使用KeePass或某些软件就能管理基于TOTP的2FA；而能集成到KeePass中统一管理自然是最好的。</p>
<p>在 KeePassXC 中可以 <strong>直接右键条目（或者菜单中的编辑条目）-&gt; 添加TOTP -&gt; 将SecretKey（二维码的值）复制进来</strong> 就将TOTP导入到了对应条目中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230523112544.png"
                      alt=""
                ></p>
<p>在设置成功后就可以在条目旁边看到一个时钟小图标，在下方条目预览中也可以直接看到TOTP的值。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230523113131.png"
                      alt=""
                ></p>
<p>在官方KeePass客户端中可能需要借助第三方插件如KeeTOTP来实现。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/39645975" >一劳永逸：KeePass全网最详使用指南 - 知乎 (zhihu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://post.smzdm.com/p/a25gd9lp/" >密码管理软件KeePass教程 篇一：Windows端的配置和使用教程（上）_软件应用_什么值得买 (smzdm.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>折腾日志</category>
      </categories>
      <tags>
        <tag>密码</tag>
        <tag>keepass</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 编程环境重新构建</title>
    <url>/posts/768258525/</url>
    <content><![CDATA[<p>虽然日常工作里做Web开发比较多，一般都是全套JS/TS解决问题，但偶尔也会有用到Python的场景，如涉及到数据分析、科学计算和机器学习等领域，Python往往是绕不开的，也会在特定领域用Python去展开一些后端或者RPC的开发。</p>
<p>但是好巧不巧，现在我的工作电脑上Python的环境可以说是一塌糊涂，版本和依赖都很混乱。为此，我打算好好地整理一下我的Python使用流程和环境，打造一个干净快速的开发环境。</p>
<p>这篇博客主要记录我折腾和理解Python环境的过程，主要有两项工作</p>
<ul>
<li><strong>从零开始</strong>构建面向PyQt5的Python环境</li>
<li>重新整理已有的混乱Python环境，并重建conda+pytorch+cuda工作环境</li>
</ul>
<h2 id="解决方案总结">解决方案总结</h2>
<blockquote>
<p>🌟全局只使用一个Python（winget官方源），使用miniconda管理多个Python环境</p>
</blockquote>
<ul>
<li>默认环境变量中只留下一个Python（winget-ms-store源），使用Windows Store安装，保持最新同步，<strong>不做虚拟环境管理，使用一个共享环境来满足简单开发需求</strong>（路径为：<code>~/AppData/Local/Microsoft/WindowsApps/python.exe</code>）</li>
<li>使用miniconda来管理虚拟环境，满足特定环境开发需求，如机器学习、Qt开发等
<ul>
<li>相较于之前的环境，现在的全局变量不再包含conda的Python路径，而只包含必要的Scripts，在默认Shell中只能操作conda而不能使用其他Python版本</li>
<li>使用专门的Anaconda Prompt终端来使用conda的虚拟环境，切换Python和pip版本等</li>
<li>在VS Code中使用自带的解释器选择来切换虚拟环境。由于Conda的虚拟环境切换是物理路径隔离，因此Code Runner使用<code>$pythonPath -u $fullFileName</code> 配置即可</li>
<li>使用miniconda来替换anaconda是因为我只对conda的管理功能有需求，其它科学计算库我更倾向于按需引入</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230709145600.png"
                      alt="" title="整理环境后，干干净净"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230709145602.png"
                      alt="" title="整理环境前， 结果里赫然显示了6个Python"
                ></p>
<h2 id="conda的使用">conda的使用</h2>
<p>conda是一个<strong>包管理器</strong>，也提供<strong>虚拟环境管理</strong>功能，这二者也是我们使用conda的重要原因。</p>
<ul>
<li>conda相比pip它使用自建的源提供软件包（这也是很多软件找不到的原因），而不像pip只提供一个指向SourceForge的链接<br>
注：在环境变量正常的情况下，激活虚拟环境后可以使用指定环境的pip</li>
<li>conda支持所有语言编写的二进制软件包，不像pip只提供Python软件包（虽然pip也支持安装二进制wheel）</li>
<li>conda的虚拟环境管理相比venv更完善、更好用</li>
</ul>
<h3 id="anaconda和miniconda">anaconda和miniconda</h3>
<p>在conda之上，我们有两个“分支”都可以获取conda本体：</p>
<ul>
<li>anaconda：包含了所有科学运算需要的包和conda，一个大而全的Python科学运算库，适合不专精开发的数据科学研究者</li>
<li>miniconda：仅包含conda, python和一些必须的依赖，其他科学运算库需要按需引入，一个小而美的Python解决方案，适合喜欢自定义的开发者</li>
</ul>
<p>这里由于我的需求并不需要anaconda的全部库，选择了miniconda。</p>
<h3 id="终端配置">终端配置</h3>
<blockquote>
<p>终端美化方面请移步：<a class="link"   href="https://www.wolai.com/mWoCoTKv9jJRQDKUQyEpct"  title="终端解决方案">终端解决方案 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p>使用<code>conda init &lt;shell&gt;</code> 可以为指定Shell注入conda-hooks，启用虚拟环境能力</p>
<blockquote>
<p>🌟<strong>不推荐在日用Shell中启用，这就是我Powershell卡的罪魁祸首</strong></p>
</blockquote>
<h4 id="直接在Powershell中使用Conda">直接在Powershell中使用Conda</h4>
<p>现在的conda在安装时不再建议添加环境变量，而是使用专门的Anaconda Prompt（即专门的Shell）来操作。</p>
<blockquote>
<p>Not recommended.Instead,open Anaconda with the Windows Start menu and select &quot;Anaconda (64-bit).This add to “PATH” option makes Anaconda get found before previously installed software,but may cause problems requiring you to uninstall and reinstall Anaconda.</p>
</blockquote>
<p>我本来不理解，直到配置了新电脑发现我的老电脑的Powershell启动奇慢无比，才开始找原因。</p>
<h4 id="环境变量（PATH）">环境变量（PATH）</h4>
<p>如果不将conda的相关路径添加到环境变量，如下图的四项所示（其实GCC那项如果你已经安装了其他GCC就不用了），你就不能在Anaconda Prompt以外的地方（如Powershell）中使用<code>conda</code>命令。</p>
<p>这不会对你的性能产生什么影响，如果你没有程序不兼容的话可以添加，比较方便。</p>
<p>这里个人推荐只添加<code>$CONDA/Library/bin</code>和<code>$CONDA/Library/usr/bin</code>两个目录到PATH中，而不要添加根目录（包含Python），这样就可以使用conda功能而不破坏全局Python版本管理。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230709145607.png"
                      alt=""
                ></p>
<h4 id="自动激活base环境">自动激活<code>base</code>环境</h4>
<p>运行<code>conda init powershell</code>会在你的用户目录<code>$PROFILE</code>生成一个<code>profile.ps1</code>，里面的内容如下，而<strong>这个就是我Powershell启动慢的罪魁祸首</strong>：</p>
<div class="highlight-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#region conda initialize</span></span><br><span class="line"><span class="comment"># !! Contents within this block are managed by &#x27;conda init&#x27; !!</span></span><br><span class="line"><span class="keyword">If</span> (<span class="built_in">Test-Path</span> <span class="string">&quot;C:\Users\kirito\anaconda3\Scripts\conda.exe&quot;</span>) &#123;</span><br><span class="line">    (&amp; <span class="string">&quot;C:\Users\kirito\anaconda3\Scripts\conda.exe&quot;</span> <span class="string">&quot;shell.powershell&quot;</span> <span class="string">&quot;hook&quot;</span>) | <span class="built_in">Out-String</span> | ?&#123;<span class="variable">$_</span>&#125; | <span class="built_in">Invoke-Expression</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#endregion</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>性能对比如下，可以说是立竿见影：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230709145610.png"
                      alt="" title="加载 profile.ps1 ： 2309ms"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230709145612.png"
                      alt="" title="不加载 profile.ps1 ： 664ms"
                ></p>
<blockquote>
<p>🚦如果你没有频繁调试Python的需求，请不要将这个<code>profile.ps1</code>设为常加载项，即使你使用<code>conda config --set auto_activate_base false</code>取消了自动激活<code>base</code>环境，它也会执行上述检查路径的过程拖慢启动。</p>
</blockquote>
<h3 id="conda的常用指令">conda的常用指令</h3>
<h4 id="虚拟环境相关">虚拟环境相关</h4>
<ul>
<li><code>conda create -n &lt;name&gt; python=&lt;version&gt;</code> 创建一个虚拟环境并指定版本</li>
<li><code>conda activate &lt;name&gt;</code> 激活虚拟环境</li>
<li><code>conda deactivate</code> 退出当前虚拟环境，回到base环境</li>
<li><code>conda env info</code> 查看当前虚拟环境信息</li>
<li><code>conda env list</code>列出所有虚拟环境</li>
<li><code>conda env remove -n &lt;name&gt;</code>移除一个虚拟环境（并删除其依赖）</li>
<li><code>conda env export &gt; env.yaml</code> 导出当前虚拟环境配置</li>
<li><code>conda create -f &lt;config&gt;</code> 从配置文件复制虚拟环境 </li>
</ul>
<h4 id="包管理相关">包管理相关</h4>
<ul>
<li><code>conda update -n &lt;env&gt; &lt;pkg&gt;</code> 更新依赖
<ul>
<li><code>&lt;env&gt;</code> 可以不指定，默认更新base环境（或当前环境）</li>
<li><code>&lt;pkg&gt;</code> 可以指定为conda或anaconda来更新自身</li>
</ul>
</li>
<li><code>conda install -n &lt;env&gt; &lt;pkg&gt; -c &lt;channel&gt;</code> 安装依赖
<ul>
<li><code>&lt;env&gt;</code> 可以不指定，默认更新base环境（或当前环境）</li>
<li><strong><code>&lt;pkg&gt;</code></strong>** 可以指定为Python，为当前环境安装自己的Python，否则将使用环境变量中的Python**​</li>
</ul>
</li>
</ul>
<h3 id="使用mamba改进conda">使用mamba改进conda</h3>
<p>conda虽然有着优秀的科学计算环境和虚拟环境管理，但其令人诟病的依赖解析速度 <s>（永远在solving）</s> 和单线程下载不禁让人想起隔壁的难兄难弟npm。</p>
<p>mamba为了改写conda下载慢的局面应运而生了，主打下面这些特性：</p>
<ul>
<li><code>conda</code>无缝替换为<code>mamba</code>（<strong>drop-in alternative</strong>），可以用mamba来执行任何conda指令，包括安装依赖和虚拟环境</li>
<li>使用多线程并行加速下载</li>
<li>使用<code>libsolv</code> 加速依赖解析</li>
<li>核心部分是通过C++实现，以获得最大执行效率</li>
</ul>
<p>安装mamba的指令</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ conda install -c conda-forge mamba</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>安装完成后飞速体验了下，确实起飞</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230709145614.gif"
                      alt=""
                ></p>
<p>使用<code>mamba</code> 安装pytorch：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建并激活虚拟环境</span></span><br><span class="line">$ mamba create -n pytorch python=3.9</span><br><span class="line">$ mamba activate pytorch</span><br><span class="line"><span class="comment"># 使用官方推荐的安装方式</span></span><br><span class="line">$ mamba install pytorch torchvision torchaudio pytorch-cuda=11.8 -c pytorch -c nvidia</span><br></pre></td></tr></table></figure></div>
<p>可以看到1.5GB的文件相较于mamba的速度可以说是直接起飞，限制你的只有网速和防火墙。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230709145617.png"
                      alt=""
                ></p>
<p>由于我之前安装好了cuda11.8和对应的cudnn，这里直接展示结果（<strong>也可以看到mamba全新安装pytorch居然只用了10分钟</strong>）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230709145619.png"
                      alt=""
                ></p>
<h2 id="重新构建Pytorch生产环境">重新构建Pytorch生产环境</h2>
<p>由于之前Winget手贱更新Conda的时候不小心把我之前辛苦配好的环境卸载了，当时安装的时候就挺痛苦的，半天都启用不了cuda。</p>
<p>半年后的今天我再来捋一捋这个环境依赖的逻辑，看看能不能跑通。</p>
<blockquote>
<p>使用环境：miniconda+mamba</p>
</blockquote>
<h3 id="安装cuda">安装cuda</h3>
<blockquote>
<p>如果你不是N卡用户或者只想使用CPU请跳过这部分</p>
</blockquote>
<ol>
<li>首先确保你正确安装了显卡驱动，在Shell中运行<code>nvidia-smi</code> 查看显卡信息，可以看到我的cuda版本是12.0</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230709145622.png"
                      alt=""
                ></p>
<ol>
<li>根据cuda版本在<a href="https://developer.nvidia.com/cuda-toolkit-archive" title="官网"><strong>官网</strong></a>中下载对应版本的CUDA Toolkit，版本要求是不高于自身GPU版本的Pytorch最高支持版本
<ul>
<li>个人实测cuda本身是<strong>向下兼容</strong>的，即GPU支持更低版本的cuda，如我的就支持18</li>
<li>pytorch目前只官方支持到cuda18，但<strong>社区</strong>表示是<strong>向上兼容</strong>的，即pytorch的cuda18支持Toolkit 的20+</li>
</ul>
</li>
<li>根据Toolkit版本去<a class="link"   href="https://developer.nvidia.com/rdp/cudnn-download"  title="官网">官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>下载安装cudnn，压缩包解压后放进Cuda Toolkit安装目录的对应文件夹里</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230709145624.png"
                      alt=""
                ></p>
<ol>
<li>检查安装，Shell运行<code>nvcc -V</code> </li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230709145626.png"
                      alt=""
                ></p>
<h3 id="安装Pytorch">安装Pytorch</h3>
<p>访问<a class="link"   href="https://pytorch.org/"  title="Pytorch官网">Pytorch官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>获取你的平台的安装代码：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230709145628.png"
                      alt=""
                ></p>
<p>我的平台安装代码如下（我使用mamba替代conda加快了安装进程）</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建并激活虚拟环境</span></span><br><span class="line">$ mamba create -n pytorch python=3.9</span><br><span class="line">$ mamba activate pytorch</span><br><span class="line"><span class="comment"># 使用官方推荐的安装方式</span></span><br><span class="line">$ mamba install pytorch torchvision torchaudio pytorch-cuda=11.8 -c pytorch -c nvidia</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>由于我之前安装好了cuda11.8和对应的cudnn，这里直接展示结果（<strong>也可以看到mamba全新安装pytorch居然只用了10分钟</strong>）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230709145631.png"
                      alt="" title="安装过程"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230709145633.png"
                      alt="" title="安装结果"
                ></p>
]]></content>
      <categories>
        <category>折腾日志</category>
      </categories>
      <tags>
        <tag>开发环境</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找 ReSharper 开源替代</title>
    <url>/posts/2913837123/</url>
    <content><![CDATA[<p>众所周知 JetBrains 家的IDE都十分的智能好用，Visual Studio 的代码提示和感知相比之下就略逊一筹。</p>
<p>凭着短暂的学生授权，我短暂地体验了几周 NetUltimate 工具包，其优秀的代码提示和质量检查功能令我印象深刻，这也是我Java环境选择IDEA的原因。</p>
<p>但基于以下几点，我最终还是选择了放弃ReSharper，回归原生Visual Studio体验。</p>
<ul>
<li>NetUltimate是收费工具，如果习惯该环境进行开发，在毕业后不从事.Net行业会额外付出高昂的授权费</li>
<li>ReSharper会严重拖慢VS的启动速度，在打开公司的大型项目时尤为如此</li>
<li>ReSharper配置项太多，相当于一个独立体系，学习成本较高</li>
</ul>
<p>但我对其优秀的IDE功能印象深刻，因此为了部分复刻其功能，我选择对VS进行以下自定义来尽可能还原ReSharper功能。</p>
<h2 id="前言">前言</h2>
<p>假期实习中短暂体验了.Net开发，让我对.Net和C#开发环境有一些自己的想法。</p>
<p>之前主要使用Typescript和React框架进行前端开发，对前端完整优秀的工具链印象深刻，直接使用VS进行开发给我带来了一定落差感。使用ReSharper一部分弥补了这种落差感，但基于上述缺点我又不得不放弃。</p>
<p>下面，我从一个前端开发者的角度，对Code Lint（代码质量）、Formatting（代码格式）、IntelliSense（代码提示和自动化工具）、编辑器样式等方面改造Visual Studio，改进.NET开发体验。</p>
<h2 id="外观部分">外观部分</h2>
<p>配置完后（主题OneMonokai，字体Noto Sans CJK Mono）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202302141419805.png"
                      alt=""
                ></p>
<h3 id="主题">主题</h3>
<p>原本使用VS Code一样的One Dark Pro，但为了保证拓展兼容性，最终选择了OneMonokai主题。</p>
<p><em>注：One Dark Pro使用SonarLint后导致提示文本也为黑色，无法在深色背景下看清</em></p>
<h3 id="字体">字体</h3>
<p>根据最佳编程字体原则：</p>
<ul>
<li>所有字母等距（Mono Space）</li>
<li>多语言支持（遇到中文字体不会回落到默认字体）</li>
<li>多语言等距（英文字母半角和中文字符全角宽度严格1比2）</li>
</ul>
<p>选择以下备选项（优先级从高到低），我选择的是Noto Sans</p>
<ul>
<li><strong>Noto Sans CJK Mono（Google家）</strong></li>
<li>更纱黑体 Mono Nerd</li>
<li>JetBrains Mono Nerd（JB家）</li>
<li>Consolas（微软家）</li>
</ul>
<hr>
<h2 id="拓展部分">拓展部分</h2>
<h3 id="1-代码提示与重构">1. 代码提示与重构</h3>
<p>ReSharper中的代码重构提示令人印象深刻，我选择以下两款插件来尽可能还原</p>
<h4 id="SonarLint">SonarLint</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202302141425329.png"
                      alt=""
                ></p>
<ul>
<li>形式：离线使用/免费注册后使用</li>
<li>功能：参考EsLint或PyLint，根据既定规则对代码质量进行改进提示
<ul>
<li>可以自定义规则</li>
<li>在线文档提供修改建议</li>
<li>实时在编辑器中显示建议</li>
</ul>
</li>
<li>Bug：可能导致重构菜单自己消失</li>
</ul>
<h4 id="CodeRush">CodeRush</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202302141427738.png"
                      alt=""
                ></p>
<ul>
<li>形式：免费注册后使用</li>
<li>功能：提供ReSharper中部分快速重构功能</li>
</ul>
<h3 id="2-代码格式化">2. 代码格式化</h3>
<h4 id="Code-Maid">Code Maid</h4>
<p>Code Maid是一个十分强大的开源插件，我常用的功能有下面几个：</p>
<ul>
<li>
<p>码撬窗口：显示当前文档类视图一般的列表，但支持实时重构和整理</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202302141430029.png"
                      alt=""
                ></p>
<ul>
<li>拖拽改变顺序</li>
<li>自动排序（可自定义规则）</li>
<li>支持region</li>
</ul>
</li>
<li>
<p>代码清理和格式化</p>
<ul>
<li>删除无用的using</li>
<li>整理空行</li>
<li>整理XML注释</li>
<li>支持XAML整理</li>
<li>支持第三方插件（Resharper、XAML Styler和自定义命令）</li>
<li>可以保存时自动整理（但为了保证性能和兼容我选择了关闭）</li>
</ul>
</li>
<li>
<p>生成进度展示</p>
</li>
</ul>
<h4 id="CSharpier">CSharpier</h4>
<p>一个很霸道的格式化工具，不支持自定义规则，但是是体验最接近Prettier的格式化工具（支持保存时自动格式化）</p>
<p>体验见仁见智，有人喜欢全自动，有人喜欢有自己的格式就不适合这个插件。</p>
<p>经过我的测试，其格式化和Code Maid的代码清理并没有规则冲突。</p>
<h4 id="XAML-Styler">XAML Styler</h4>
<p>一个老牌XAML格式化工具，具有以下优点：</p>
<ul>
<li>自定义项目多</li>
<li>兼容性好</li>
<li>支持保存时格式化（Format on save）</li>
</ul>
<h3 id="3-其他代码工具">3. 其他代码工具</h3>
<h4 id="快速创建">快速创建</h4>
<ul>
<li>Snippetica：提供简单的模板，方便创建代码</li>
<li>Add New File：实现Shift+F2自动按格式从模板创建对应目录、文件</li>
<li>Adjust C# Namespace：自动根据目录层级重构命名空间</li>
<li>XML Doc Provider：自动生成XML注释</li>
</ul>
<h4 id="界面改进">界面改进</h4>
<ul>
<li>C# Var Type CodeLens：显示Var的实际类型</li>
<li>Indent Guides：显示缩进层级</li>
</ul>
<h4 id="体验改进">体验改进</h4>
<ul>
<li>Open In VSCode：在VSC中打开指定文件（开发其他语言有奇效）</li>
<li>Select Next Occurrence：获得VSCode的选择体验</li>
<li>Auto Save：模仿VSCode按时间间隔自动保存</li>
<li>ILSpy：自动定位到对应反编译代码</li>
<li>Git Diff：获得VSCode中Git Lens的部分体验</li>
</ul>
]]></content>
      <categories>
        <category>折腾日志</category>
      </categories>
      <tags>
        <tag>开发环境</tag>
        <tag>.net</tag>
        <tag>jetbrains</tag>
      </tags>
  </entry>
  <entry>
    <title>初探 C# Script</title>
    <url>/posts/3021583790/</url>
    <content><![CDATA[<p><em>注：以下所有环境均为.net7.0</em></p>
<h1>C# Script（CSX）</h1>
<p>C#脚本的根源是伴随着VS2015发布的 <strong>C# 读取-求值-打印-循环 (REPL)</strong>，类似于一个CLI（Command-Line-Interface，命令行）环境，称为<strong>REPL CSI</strong>。这个CLI环境的发布也顺带引入了<strong>将C#脚本化的可能性</strong>。</p>
<p>以下是官网对C#脚本用途的定义：</p>
<p><strong>C# 脚本是一款用于测试 C# 和 .NET 代码段的工具，无需创建多个单元测试或控制台项目。它提供了轻型选项，可快速在命令行上对 LINQ 聚合方法进行编码、检查 .NET API 是否解压缩文件或调用 REST API，以了解返回的内容或工作原理。它提供了探索和了解 API 的简便方法，无需对 %TEMP% 目录中的另一个 CSPROJ 文件支付开销。</strong></p>
<p>我个人的理解的话就是C#的REPL CSI<strong>相当于一个C#版的Python虚拟机</strong>，一方面有一个解释型的CLI，一方面支持解释型的脚本。它可能会慢一点，但是对快速测试或者快速实现一个脚本功能是非常便利的。</p>
<p><em>理论相关参考了这篇文章：<a class="link"   href="https://learn.microsoft.com/zh-cn/archive/msdn-magazine/2016/january/essential-net-csharp-scripting" >必备 .NET - C# 脚本 | Microsoft Learn <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></em></p>
<h2 id="编写C-脚本">编写C#脚本</h2>
<p>接下来我们以做算法题为场景学习C#脚本的使用。</p>
<p>C#脚本的规则与C#9中的顶层语句很像，语法也和普通C#完全一致。</p>
<p>主要区别有以下几个：</p>
<ul>
<li>引入程序集：<code>#r &lt;Assembly.dll&gt;</code>
<ul>
<li>这里直接按相对路径引入即可</li>
<li>VSCode有个奇怪错误就是必须<code>#r System.Console</code>才不会报错，但实际上不影响运行，甚至加了<code>.dll</code>反而会报错</li>
</ul>
</li>
<li>引入其他脚本 <code>#load &lt;script.csx&gt;</code>
<ul>
<li>个人理解是直接把这些东西像宏一样加载进来</li>
</ul>
</li>
<li>引用命名空间仍然使用 <code>using</code></li>
</ul>
<hr>
<p>下面用经典的<strong>牌组大小判断</strong>为例展示一下CSX的编写：</p>
<p><code>main.csx</code></p>
<div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#r &quot;System.Console&quot;</span></span><br><span class="line"><span class="meta">#load &quot;CardAnalyzer.csx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> line = <span class="string">&quot;3 4 5 6 7-10 J Q K A&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((line = Console.ReadLine()) != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> tokens = line.Split(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (tokens.Length &lt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">var</span> a = GetCardsType(tokens[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">var</span> b = GetCardsType(tokens[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">if</span> (a == CardGroupType.Illegal || b == CardGroupType.Illegal)</span><br><span class="line">  &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (a == CardGroupType.JokerBomb)</span><br><span class="line">  &#123;</span><br><span class="line">    Console.WriteLine(tokens[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (b == CardGroupType.JokerBomb)</span><br><span class="line">  &#123;</span><br><span class="line">    Console.WriteLine(tokens[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (a == b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == CardGroupType.Multiple &amp;&amp; tokens[<span class="number">0</span>].Split(<span class="string">&#x27; &#x27;</span>).Length != tokens[<span class="number">1</span>].Split(<span class="string">&#x27; &#x27;</span>).Length)</span><br><span class="line">    &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> aMin = GetBaseCard(tokens[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">var</span> bMin = GetBaseCard(tokens[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (aMin &gt; bMin)</span><br><span class="line">      Console.WriteLine(tokens[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      Console.WriteLine(tokens[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (a == CardGroupType.Bomb)</span><br><span class="line">  &#123;</span><br><span class="line">    Console.WriteLine(tokens[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (b == CardGroupType.Bomb)</span><br><span class="line">  &#123;</span><br><span class="line">    Console.WriteLine(tokens[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>CardAnalyzer.csx</code></p>
<div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> CardGroupType</span><br><span class="line">&#123;</span><br><span class="line">  Single = <span class="number">0</span>,</span><br><span class="line">  Couple,</span><br><span class="line">  Triple,</span><br><span class="line">  Multiple,</span><br><span class="line">  Bomb,</span><br><span class="line">  JokerBomb,</span><br><span class="line">  Illegal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">ParseCard</span>(<span class="params"><span class="built_in">string</span> card</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> num;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">int</span>.TryParse(card, <span class="keyword">out</span> num))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> num - <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> (card)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;J&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;Q&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;K&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;joker&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;JOKER&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">      <span class="literal">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">CardGroupType <span class="title">GetCardsType</span>(<span class="params"><span class="built_in">string</span> token</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">string</span>[] cards = token.Split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">int</span>? prev = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">bool</span> same = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">int</span> lastCard = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">foreach</span> (<span class="keyword">var</span> card <span class="keyword">in</span> cards)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> cardIndex = ParseCard(card);</span><br><span class="line">    <span class="keyword">if</span> (same &amp;&amp; (prev == <span class="literal">null</span> || prev == cardIndex))</span><br><span class="line">    &#123;</span><br><span class="line">      count++;</span><br><span class="line">      prev = cardIndex;</span><br><span class="line">      lastCard = cardIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cardIndex == prev + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      count++;</span><br><span class="line">      prev = cardIndex;</span><br><span class="line">      same = <span class="literal">false</span>;</span><br><span class="line">      lastCard = cardIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> CardGroupType.Illegal;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">1</span>) <span class="keyword">return</span> CardGroupType.Single;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (same &amp;&amp; count == <span class="number">2</span>) <span class="keyword">return</span> CardGroupType.Couple;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (same &amp;&amp; count == <span class="number">3</span>) <span class="keyword">return</span> CardGroupType.Triple;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (same &amp;&amp; count == <span class="number">4</span>) <span class="keyword">return</span> CardGroupType.Bomb;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!same &amp;&amp; count &gt;= <span class="number">5</span>) <span class="keyword">return</span> CardGroupType.Multiple;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">2</span> &amp;&amp; lastCard == <span class="number">13</span>) <span class="keyword">return</span> CardGroupType.JokerBomb;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> CardGroupType.Illegal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">GetBaseCard</span>(<span class="params"><span class="built_in">string</span> token</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">string</span>[] cards = token.Split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  List&lt;<span class="built_in">int</span>&gt; cardNums = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">  <span class="keyword">foreach</span> (<span class="keyword">var</span> card <span class="keyword">in</span> cards)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> cardIndex = ParseCard(card);</span><br><span class="line">    cardNums.Add(cardIndex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cardNums.Min();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="CSX-运行时">CSX 运行时</h2>
<p>有两个工具可以用来运行CSX脚本：</p>
<ul>
<li><strong>dotnet-script</strong>：推荐</li>
<li>scriptcs</li>
</ul>
<h3 id="dotnet-script">dotnet-script</h3>
<p>这是一个官方提供的CSX运行时，提供以下功能：</p>
<ul>
<li>提供脚本运行环境（<code>dotnet script xxx.csx</code>直接运行脚本）</li>
<li>提供脚手架（<code>dotnet script init</code>），初始化一个VSCode的Debug环境</li>
<li>提供REPL环境：运行<code>dotnet script</code>调出REPL环境</li>
<li>提供系统级直接运行脚本的功能
<ul>
<li>Unix系：在开头加上 <code>#!/usr/bin/env dotnet-script</code> ，直接运行</li>
<li>Win：运行<code>dotnet script register</code>来向注册表写入CSX的处理方式</li>
</ul>
</li>
<li>提供内置的Nuget包支持 <code>#r &quot;nuget: PackageName, Version&quot;</code></li>
</ul>
<p>它有很多分支（我也不是很懂，我只用第一个），详见下面这个表格，来自于官方仓库：<a class="link"   href="https://github.com/dotnet-script/dotnet-script" >dotnet-script/dotnet-script: Run C# scripts from the .NET CLI. (github.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Version</th>
<th>Framework(s)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dotnet-script</code> (global tool)</td>
<td><a href="https://www.nuget.org/packages/dotnet-script/"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://camo.githubusercontent.com/0872d8a82cf8f7b0fc99164c3ad7e0fa23ff191895fe04029fbff187b2cc4cd4/687474703a2f2f696d672e736869656c64732e696f2f6e756765742f762f646f746e65742d7363726970742e7376673f6d61784167653d3130383030"
                      alt=""
                ></a></td>
<td><code>net6.0</code>, <code>net7.0</code></td>
</tr>
<tr>
<td><code>Dotnet.Script</code> (CLI as Nuget)</td>
<td><a href="https://www.nuget.org/packages/dotnet.script/"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://camo.githubusercontent.com/5a31db9298f32c0f723ae7936e928bb98995fc9163b1c8fd18cc2be3cd96d43f/687474703a2f2f696d672e736869656c64732e696f2f6e756765742f762f646f746e65742e7363726970742e7376673f6d61784167653d3130383030"
                      alt=""
                ></a></td>
<td><code>net6.0</code>, <code>net7.0</code></td>
</tr>
<tr>
<td><code>Dotnet.Script.Core</code></td>
<td><a href="https://www.nuget.org/packages/Dotnet.Script.Core/"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://camo.githubusercontent.com/b79194066652d5ee112ffade6e6d5e9b505a632f4a533120a2ca97372c882008/687474703a2f2f696d672e736869656c64732e696f2f6e756765742f762f446f746e65742e5363726970742e436f72652e7376673f6d61784167653d3130383030"
                      alt=""
                ></a></td>
<td><code>net6.0</code> , <code>netstandard2.0</code></td>
</tr>
<tr>
<td><code>Dotnet.Script.DependencyModel</code></td>
<td><a href="https://www.nuget.org/packages/Dotnet.Script.DependencyModel/"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://camo.githubusercontent.com/c59b67233016398ec0b24c2ff4b31b3e262f21f8a8809e767f6e8edfb9c92397/687474703a2f2f696d672e736869656c64732e696f2f6e756765742f762f446f746e65742e5363726970742e446570656e64656e63794d6f64656c2e7376673f6d61784167653d3130383030"
                      alt=""
                ></a></td>
<td><code>netstandard2.0</code></td>
</tr>
<tr>
<td><code>Dotnet.Script.DependencyModel.Nuget</code></td>
<td><a href="https://www.nuget.org/packages/Dotnet.Script.DependencyModel.Nuget/"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://camo.githubusercontent.com/bb9b6c94315ec1c1321681c37a59d1950980c0ab6ef08f81db88aad8dba80d8b/687474703a2f2f696d672e736869656c64732e696f2f6e756765742f762f446f746e65742e5363726970742e446570656e64656e63794d6f64656c2e4e756765742e7376673f6d61784167653d3130383030"
                      alt=""
                ></a></td>
<td><code>netstandard2.0</code></td>
</tr>
</tbody>
</table>
<p><a class="link"   href="http://xn--15q50rh9br1q8ua.NET" >如果有全局.NET <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 工具支持的话，<a class="link"   href="http://xn--onq35jna6315a.NET" >可以只用.NET <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> CLI输入<code>dotnet tool install -g dotnet-script</code>即可安装（<a class="link"   href="http://xn--gswv73d.NET" >要求.NET <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> Core 2.1 以上）。</p>
<h3 id="scriptcs">scriptcs</h3>
<p>这是 <strong>CodeRunner</strong> 内置的CSX运行命令环境实现，年代相比dotnet-script更久远一点，个人更推荐上一个。</p>
<p>官方仓库：<a class="link"   href="https://github.com/scriptcs/scriptcs" >scriptcs/scriptcs: Write C# apps with a text editor, nuget and the power of Roslyn! (github.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>它也提供类似的功能：</p>
<ul>
<li>脚本运行环境：<code>scriptcs xxx.csx</code>直接运行脚本</li>
<li>提供REPL环境</li>
<li>提供Nuget包支持，但是方式不如dotnet-script方便</li>
</ul>
<p>安装是通过Chocolatey进行：<code>cinst scriptcs </code>，优势是直接顶层环境变量。</p>
<p>个人对比下来，scriptcs比dotnet-script要慢一点，功能更少，Nuget引入也没那么方便，最后一次更新也更早，个人更推荐<strong>dotnet-script</strong>一点。</p>
<h1>传统项目作为环境</h1>
<p>由于大部分刷题环境不支持CSX，这里还是用传统的CLI方法<code>dotnet new</code>搭配VSCode管理项目搭建刷题环境。</p>
<ul>
<li>使用 <code>dotnet new console</code>创建一个新的控制台项目
<ul>
<li>这样在新版本创建的是一个运用<strong>顶层语句</strong>和<strong>隐式全局Using</strong>的项目</li>
<li>要创建老版本带类的项目可以使用 <code>--use-program-main</code> 参数</li>
<li>消除隐式Using可以在项目配置中取消<code>ImplicitUsing</code></li>
</ul>
</li>
<li>使用<code>dotnet run</code>直接运行项目</li>
<li>在VSCode中使用C#插件配置<code>launch.json</code>和<code>tasks.json</code>可以实现单步调试</li>
</ul>
]]></content>
      <categories>
        <category>折腾日志</category>
      </categories>
      <tags>
        <tag>开发环境</tag>
        <tag>c#</tag>
        <tag>.net</tag>
      </tags>
  </entry>
  <entry>
    <title>工欲善其事，必先利其器——打造自己趁手的终端体验</title>
    <url>/posts/651278606/</url>
    <content><![CDATA[<p>📌 本文介绍了终端在程序开发流程中的重要性，并探讨了如何打造趁手的终端体验。文章讲解了Shell基础、Terminal和Shell的关系、什么是Prompt、Prompt工具的使用以及Profile配置文件的作用。针对Powershell的改进，作者提出了使用starship作为Prompt工具的方案，并介绍了Powershell 7的新功能。此外，文章还介绍了在macOS上配置开发环境的方案，包括使用zsh + oh-my-zsh、iterm2主题和tmux等插件来提高终端生产力。<em>（Summarized By ChatGPT）</em></p>
<span id="more"></span>
<p>终端在程序开发流程中显然是十分重要的，很多复杂的工具使用CLI的效率要远远高于GUI，且CLI还可以编写自动化脚本来提升工作效率。因此，打造趁手的终端体验显然是开发环境配置的重要一环。</p>
<p>虽然在之前摸爬滚打的经历里，我已经脱离了在Windows下使用CMD和Git Bash作为终端的原始体验，在Windows Terminal和Powershell的组合下使用体验还算良好，也用oh-my-posh做了Prompt优化。</p>
<p>后面一次偶然的机会看到了Unix开发同学的zsh，看到他的自动补全和历史记录确实很是心动，就开始对已有的终端方案进行改进。</p>
<p>目前来说我的终端体验还有以下问题：</p>
<ul>
<li>缺少命令补全和历史记录提示（auto suggestion）</li>
<li>Shell启动速度过慢</li>
<li>WSL的Shell体验完全没有优化</li>
</ul>
<p>除了在Windows端优化Powershell解决上述问题外，这里还对WSL/macOS的终端（zsh）进行了美化和优化。</p>
<h1>Shell 基础</h1>
<p>这个<a class="link"   href="https://www.bilibili.com/video/BV1rk4y1W7dZ/?share_source=copy_web&amp;vd_source=0a01fb11a82eaf663fcad12ddb244da9" >视频 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>比较系统地讲了Shell相关的基础知识（平台无关），也和本文的主题——终端体验优化相关性较强。（这个原Po是mac上终端Warp的作者，也是用Rust写的，终端理解很强）</p>
<h2 id="Terminal和Shell">Terminal和Shell</h2>
<p>虽然在本文中会大量地混用Terminal和Shell的概念，并将他们都称为“终端”，但在此之前还是应该将这些概念好好地明晰一下。</p>
<p>下面将由表及里，从用户交互到系统调用地讲明这些概念。</p>
<h3 id="CLI-Command-Line-Interface">CLI (Command Line Interface)</h3>
<p>CLI (Command Line Interface)，中文为命令行界面，就是一种通过文本输入输出与计算机进行交互的形式，而Shell和Terminal就是CLI的载体。</p>
<p>形象地说就是像电视里的黑客那样对着黑乎乎绿油油的屏幕敲代码执行操作就是CLI，而平时拿鼠标点点划划进行操作就是GUI (Graphics User Interface， 图形用户界面)。</p>
<p>常用的CLI工具有ffmpeg, git 等，这些都是CLI应用。</p>
<h3 id="Terminal">Terminal</h3>
<p>Terminal，中文为终端，就是输入各种命令的地方（窗口）。在CLI中需要输入命令与计算机进行交互，终端就是承载这些交互的地方，它接受你的输入，返回计算机的输出。</p>
<p>最常见的Terminal是裸Shell，它们除了基础的文本交互功能外不提供任何其他功能。</p>
<p>更常用的Terminal工具有 Windows Terminal，Warp等，它们还可能提供一些额外的功能如Nerd Font支持、AI工作流等，可以支持运行各种不同的Shell。</p>
<h3 id="Shell">Shell</h3>
<p>Shell，意为壳，顾名思义就是给系统内核套上的一层壳，通过这层壳可以用命令实现系统功能调用。</p>
<p>当用户向终端（Terminal）输入命令时，Shell就会解释这些命令并执行。</p>
<p>常见的Shell有：cmd, powershell, bash, zsh等。</p>
<h2 id="什么是Prompt">什么是Prompt</h2>
<p>这里的Prompt和AI Prompt不是一个概念。Shell Prompt是命令行终端（CLI）的提示符，通常由一个字符、字符串或图标组成，显示当前命令行环境的信息，通常包含当前所在的目录、用户名、主机名。</p>
<p>对于开发者而言，一个好的Prompt应该包含以下信息：</p>
<ul>
<li>目录和用户信息（基础信息）</li>
<li>权限信息：当前命令是否sudo</li>
<li>Git信息，包含仓库、账号、分支等</li>
<li>运行环境信息，如Node版本、Python虚拟环境等</li>
<li>上一个命令运行是否成功</li>
</ul>
<p>拿oh-my-posh 2仓库中的图举一个例子，该图中就包含了权限、上一个命令结果、目录和用户还有Git信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/08/20230806200119.png"
                      alt=""
                ></p>
<h3 id="Prompt-工具">Prompt 工具</h3>
<p>Shell自带的Prompt引擎不能实现花花绿绿的效果，配置起来也比较麻烦，这就需要我们引入Prompt Engine来为我们渲染Prompt。</p>
<p>Prompt Engine可以用不同的语法高亮显示各种信息，稍加定制还可以花里胡哨。可惜现在我已经过了追求炫酷的年纪，只想实用加快速，这里我对不同终端下的不同Prompt工具做了一个简单速度对比。</p>
<blockquote>
<p>在Windows Terminal中**将启动参数中的<code>-nol</code>**<strong>删去，显示Shell启动信息以便调试</strong>。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Shell 版本</th>
<th>Prompt 工具</th>
<th>平均启动耗时（ms）</th>
</tr>
</thead>
<tbody>
<tr>
<td>PS 5.1</td>
<td>oh-my-posh 2 (legacy)</td>
<td>650</td>
</tr>
<tr>
<td>PS 5.1</td>
<td>oh-my-posh 7+</td>
<td>1000</td>
</tr>
<tr>
<td>PS 5.1</td>
<td>starship</td>
<td>500</td>
</tr>
<tr>
<td>PS 7</td>
<td>oh-my-posh 7+</td>
<td>600</td>
</tr>
</tbody>
</table>
<p>Powershell下我主要测试了以下prompt工具，oh-my-xxx系列是每个Shell都有自己的对应工具，starship则是偶然刷到的一个新的跨平台Rust Prompt工具。</p>
<ul>
<li>oh-my-posh 2 (legacy): 100%用Powershell脚本完成的Prompt工具，只支持Powershell，Prompt方面只支持Git信息</li>
<li>oh-my-posh：用Go重写的Prompt工具，可以支持不同Shell（虽然没人用），Prompt方面支持更多信息如Git、Node、Python等，代价是<strong>体积增加、运行速度慢</strong></li>
<li>starship：用Rust写的跨平台Prompt工具，很快，信息显示也很全，代价是由于比较新主题比较少</li>
</ul>
<h2 id="Nerdfont-管理">Nerdfont 管理</h2>
<blockquote>
<p>Nerd Fonts是面向开发者的字体，它在开发友好字体（如各种mono字体）的基础上封装了一系列ICONS和表情符号，又称iconic fonts。</p>
</blockquote>
<p>本文所有的Nerd Font都从<a class="link"   href="https://www.nerdfonts.com"  title="nerdfonts.com">nerdfonts.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>下载，具体使用得字体如下：</p>
<ul>
<li>Noto Sans Mono CJK：VS Code字体，不含Icons</li>
<li>Jetbrains Mono Nerd</li>
<li>FiraMono Nerd：终端字体</li>
</ul>
<h1>Powershell</h1>
<p>此前我的终端环境一直是基于Powershell 5（也就是系统内置的Windows Powershell）进行的，最多也是进行了一些Prompt美化来展示一些额外信息如Git信息、Node信息、Python信息等。</p>
<p>在进行选择之前，我首先对Powershell本身进行了调研，因为根据微软官方的描述，自 PowerShell 6.0 起，PowerShell在Windows内始终有两个版本：Windows Powershell（PowerShell 5.1）和Powershell 7（6.0+）。</p>
<ul>
<li>Windows Powershell（在Windows 11中是Powershell 5.1）是基于 .NET Framework的Powershell，顾名思义只能运行在Windows上，是系统内部自带的，地位与CMD等同，提供全部的Windows接口</li>
<li>Powershell（目前最新版是Powershell 7）是基于 .NET Core的跨平台Powershell，可以运行在任何系统上，地位与第三方Shell等同，只支持window-cmdlet的子集，但支持许多新功能</li>
</ul>
<h2 id="Profile-配置文件">Profile 配置文件</h2>
<p>打开相关的<code>profile.ps1</code>，根据<a class="link"   href="https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_profiles?view=powershell-7.3"  title="微软的官方文档">微软的官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，配置文件在Windows中存储在以下目录，且<strong>按顺序加载</strong>，也就是说后加载的可以覆盖先加载的配置（不会有人在非Windows环境下使用Powershell吧）</p>
<blockquote>
<p>注意：Win10/11下会同时有<strong>Powershell5</strong>和<strong>Powershell7</strong>两个版本，<code>$HOME\Documents\PowerShell</code>是<strong>Powershell7</strong>的目录，而<code>$HOME\Documents\Windows Powershell</code>是<strong>Powershell5</strong>的目录（<code>system32</code>中自带的Powershell版本）</p>
</blockquote>
<ul>
<li>全局配置（所有用户、所有主机）： <code>$PSHOME\Profile.ps1</code>（在我的电脑上是<code>$PSHOME=C:\Windows\System32\WindowsPowerShell\v1.0</code>）</li>
<li>所有用户，当前主机：<code>$PSHOME\Microsoft.PowerShell_profile.ps1</code></li>
<li>当前用户、所有主机：<code>$HOME\Documents\PowerShell\Profile.ps1</code>（或者直接是<code>$PROFILE</code>）</li>
<li>当前用户、当前主机：<code>$HOME\Documents\PowerShell\Microsoft.PowerShell_profile.ps1</code></li>
</ul>
<h2 id="Powershell-7的更新点">Powershell 7的更新点</h2>
<p>Powershell 6是一个划时代的版本，在此之前Powershell是基于 .NET Framework构建的，只能运行在Windows上；而Powershell 6及其更高版本则可以利用 .NET Core跨平台运行在所有OS上。</p>
<ul>
<li><a class="link"   href="http://xn--6kqu55g.NET" >由于.NET <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> Core是Framework的子集，因此跨平台的Powershell会移除一些针对Windows的cmdlet，<strong>Powershell 7针对此现象做了大量针对Windows的兼容性支持</strong>，但这是针对运维人员的，对我这种只用到终端和基础脚本的开发者没有什么作用。</li>
<li>Powershell 7 作为<strong>脚本工具</strong>增加了许多新内容，特别是面向对象语法这一块比bash这种纯字符串处理在面对复杂任务时可以更加从容</li>
<li>完全拥抱开源，在Github上源码完全公开</li>
</ul>
<p>输入<code>$PSVersionTable</code>可以看到详细版本信息，以下是<strong>Windows Powershell（系统内置）</strong> 的版本信息，可以看到版本是5：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/08/20230806200124.png"
                      alt=""
                ></p>
<p>以下是<strong>Powershell 7（我手动安装的最新版本）</strong> 的版本信息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/08/20230806200135.png"
                      alt=""
                ></p>
<h2 id="改进方案">改进方案</h2>
<p>在新的方案中，我将拥抱两个不同版本的Powershell，而不是像之前那样只使用自带的Windows Powershell，两个版本的Powershell将有自己的作用：</p>
<ul>
<li>Windows Powershell (PS 5.1)：系统终端（替代CMD）
<ul>
<li>语法和功能上支持CMD的全部功能，也可以向下兼容CMD命令</li>
<li>地位上位于系统内部，其他CLI工具或脚本调用Powershell也会默认调用它</li>
<li>需求上要求<strong>快速启动</strong>，保持稳定，有<strong>基础的Prompt展示</strong></li>
</ul>
</li>
<li>Powershell 7：开发终端，Windows Terminal和VS Code默认终端
<ul>
<li>地位上和第三方Shell等同，虽然都叫Powershell，但和上面完全不是一个档次</li>
<li>体验上对标zsh，有自动补全、建议等功能</li>
<li>相较于现有方案改进启动速度</li>
</ul>
</li>
</ul>
<h3 id="Windows-Powershell-的改进">Windows Powershell 的改进</h3>
<p>原来的Windows Powershell使用oh-my-posh进行了Prompt美化，直接在官网使用了默认方案，但启动速度一直不是很理想。</p>
<p>后面才知道oh-my-posh 3用Golang重写了，原因是想用到不同终端上（疯了，别的终端为什么要用powershell的东西），才变得又卡又慢，体积还增大了。</p>
<p>根据上面的速度测试结果，我打算在两个Powershell上都换用starship作为Prompt工具，Windows Powershell就不做过多配置。</p>
<p>首先卸载现在的oh-my-posh，先用<code>(Get-Command oh-my-posh).Source</code> 得到exe的目录，然后找到卸载程序，直接运行即可。</p>
<p>根据官网提示安装starship：</p>
<div class="highlight-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line">scoop install starship</span><br></pre></td></tr></table></figure></div>
<p>然后编辑<code>$PROFILE</code> ：</p>
<div class="highlight-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Invoke-Expression</span> (&amp;starship init powershell)</span><br></pre></td></tr></table></figure></div>
<h3 id="Powershell-7的改进">Powershell 7的改进</h3>
<p>除了在Windows Powershell中的Prompt工具外，Powershell 7 作为开发终端，我还需求一些额外的zsh功能：</p>
<ul>
<li>Bash-like Tab 补全</li>
<li>自动命令建议（IntelliSense）</li>
<li>基于历史记录的搜索</li>
</ul>
<p>经过调研发现，上述这些功能都在Powershell官方提供的PSReadLine包中提供了，更巧的是这个包在Windows Powershell 5.1 和Powershell 7中都已经内置了，只需要使用选项激活即可。</p>
<p>事不宜迟，立刻编辑<code>$PROFILE</code> ：</p>
<div class="highlight-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Invoke-Expression</span> (&amp;starship init powershell)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set-PSReadLineOption</span> <span class="literal">-PredictionSource</span> <span class="built_in">History</span> <span class="comment"># 设置预测文本来源为历史记录</span></span><br><span class="line"><span class="built_in">Set-PSReadLineOption</span> <span class="literal">-Colors</span> <span class="selector-tag">@</span>&#123; InlinePrediction = <span class="string">&#x27;#875f5f&#x27;</span>&#125; <span class="comment"># 增加预测内容在亚克力背景下的可读性</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">Set-PSReadlineKeyHandler</span> <span class="literal">-Key</span> Tab <span class="literal">-Function</span> Complete <span class="comment"># 设置 Tab 键补全</span></span><br><span class="line"><span class="built_in">Set-PSReadLineKeyHandler</span> <span class="literal">-Key</span> Tab <span class="literal">-Function</span> MenuComplete <span class="comment"># 设置 Ctrl+d 为菜单补全和 Intellisense</span></span><br><span class="line"><span class="built_in">Set-PSReadLineKeyHandler</span> <span class="literal">-Key</span> <span class="string">&quot;Ctrl+z&quot;</span> <span class="literal">-Function</span> Undo <span class="comment"># 设置 Ctrl+z 为撤销</span></span><br><span class="line"><span class="built_in">Set-PSReadLineKeyHandler</span> <span class="literal">-Key</span> UpArrow <span class="literal">-Function</span> HistorySearchBackward <span class="comment"># 设置向上键为后向搜索历史记录</span></span><br><span class="line"><span class="built_in">Set-PSReadLineKeyHandler</span> <span class="literal">-Key</span> DownArrow <span class="literal">-Function</span> HistorySearchForward <span class="comment"># 设置向下键为前向搜索历史纪录</span></span><br></pre></td></tr></table></figure></div>
<p>根据我的习惯，我做了以下定制：</p>
<ul>
<li>Tab映射为补全和菜单补全（只有一项时就直接补全）</li>
<li>上下箭头映射为历史记录搜索，没有输入则是默认行为</li>
<li>最重要的是，将预测文本来源为历史记录，提供了命令建议，这个键位是<strong>右箭头</strong></li>
</ul>
<p>最终我们的效果如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/08/20230806200221.gif"
                      alt=""
                ></p>
<h3 id="设置VS-Code默认终端">设置VS Code默认终端</h3>
<p>首先需要自定义一个Terminal Profile，这里直接复制Windows Terminal的参数即可。</p>
<p>然后将默认终端设置成刚刚创建的Profile即可。</p>
<blockquote>
<p>等待补图</p>
</blockquote>
<h1>Unix终端</h1>
<p>在Windows上个人使用终端的主要场景其实是VS Code内置终端，而类Unix系统上GUI相较于Windows更弱，终端的使用场景要远多于Windows，因此地位也更加重要，很多Windows上用GUI解决的都要使用终端解决，如从目录打开VS Code这样一个简单的功能都需要从终端完成。</p>
<p>不过得益于Unix上终端的重要地位，其生态环境和使用体验也整体上优于Windows（也部分得益于Unix优秀的文件系统设计）。</p>
<p>这里以macOS和Ubuntu（WSL）为例配置和完善Unix终端体验，由于时间仓促，以快速构建工作环境为主，加之第一次接触mac，以下内容可能并不完善：</p>
<ul>
<li>Terminal：iterm2（macOS）+ Windows Terminal（WSL）</li>
<li>Shell：zsh</li>
<li>Prompt Engine：oh-my-zsh</li>
</ul>
<h2 id="Shell强化">Shell强化</h2>
<h3 id="iterm2-配置">iterm2 配置</h3>
<p>原生的iterm2和系统自带的终端看起来没有什么区别，我们从配色、字体和Status Bar三个方面对其进行自定义。</p>
<ul>
<li>配色：在这个仓库下载预设，我使用的是 <em>mocha</em> 预设</li>
<li>字体：使用上面提到的 <em>FiraMono Nerd Prop</em> 字体（提供Shell Prompt的字重显示）</li>
<li>Status Bar：要达到下面的效果需要两步自定义
<ul>
<li><code>Preferences-Appearance-General-Theme</code> 中设置为 <code>Minimal</code> 才能像这样隐藏背景</li>
<li>上面的页面中还可以自定义Status Bar的位置</li>
<li>在<code>Preferences &gt; Profiles &gt; Session</code> 中打开Status Bar，然后自定义选择自己想显示的字段</li>
</ul>
</li>
</ul>
<p>注意在设置的时候一定要对Profile进行设置，不然设置就是一次性的，下一次启动就没了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/08/20230806200227.png"
                      alt=""
                ></p>
<h3 id="oh-my-zsh">oh-my-zsh</h3>
<p>oh-my-zsh是一款大名鼎鼎的zsh的Prompt工具，其应用广泛，生态良好，速度也较快。</p>
<p>根据官网指导直接安装即可：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure></div>
<h4 id="主题">主题</h4>
<p>在Github的Wiki上可以查看所有主题：<a class="link"   href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes"  title="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes">https://github.com/ohmyzsh/ohmyzsh/wiki/Themes <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>主题主要决定Prompt的显示模式，这里我选择gozilla主题，效果如上图所示。</p>
<h4 id="插件">插件</h4>
<p>oh-my-zsh的插件生态很丰富，大部分都是缩写Alias型的，这部分就根据自己喜好进行添加就好。这里只介绍几个比较关键的体验核心插件。</p>
<ul>
<li>autojump：需要配合autojump（通过homebrew安装）使用，作用是快速切换到工作目录<br>
原理是将曾用目录存储在一个数据库中，根据输入匹配频率最高的目录，需要在<code>oh-my-zsh</code> 中设置<code>autojump</code> 插件才能使用下面的Alias
<ul>
<li><code>j</code> : 跳转到目录，智能选择频次最高的目录</li>
<li><code>jo</code> : 利用资源管理器打开跳转的目录</li>
</ul>
</li>
<li>zsh-autosuggestions：提供类似Fish的自动补全功能，原理是记忆历史命令来补全，效果就和之前Powershell演示的一样</li>
<li>zsh-syntax-highlight：将命令本身语法高亮，在输入前就可以判断命令是否错误</li>
</ul>
<h3 id="vim">vim</h3>
<p>在Shell中难免遇到一些简单的文本编辑请求，这时调用外部编辑器就有些不太方便，这时使用vim进行编辑就可以快速完成。我对vim的定位就是简易的TUI编辑器，不需要什么异步执行、内置终端等功能。</p>
<h4 id="neovim">neovim</h4>
<p>neovim（<code>nvim</code>）和vim（<code>vim</code>）是两个不同的软件，前者是后者的重构实现，具有以下优势：</p>
<ul>
<li>从头重构的架构，使用Lua JIT替代Vim Script</li>
<li>更好的插件开发环境和生态</li>
<li>提供异步执行和内置终端等功能，使NeoVim作为生产用IDE成为可能</li>
</ul>
<p>但是，我作为一个轻量级用户，我只需要简单的TUI编辑器功能，neovim吸引我的地方只有一点，开箱即用，包括开箱即用的语法高亮和插件系统（几乎不需要修改什么）。</p>
<p>同样打开<code>.zshrc</code> ，neovim和vim不做任何配置的效果区别如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/08/20230806200237.png"
                      alt="" title="neovim"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/08/20230806200240.png"
                      alt="" title="vim"
                ></p>
<p>虽然据说vim8实现了neovim的很多功能，但秉承着省心的原则我选择neovim。</p>
<h4 id="基本概念">基本概念</h4>
<p>vim常用有四个模式：</p>
<ul>
<li>正常模式（normal mode）：正常模式一般用于浏览文件，也包括一些复制、粘贴、删除等操作。在这个模式下，我们可以通过键盘在文本中快速移动光标，光标范围从小到大是字符、单词、行、句子、段落和屏幕。
<ul>
<li>快速移动光标：h,j,k,l 分别对应了方向键的上下左右</li>
<li><code>0</code> 移动到行首</li>
<li><code>^</code> 移动到本行的第一个非空字符</li>
<li><code>$</code> 移动到行尾</li>
<li><code>w</code> 跳过一个单词（移动到下一个单词的开头）</li>
<li><code>e</code> 移动到下一个单词的结尾</li>
<li><code>f&lt;ch&gt;</code> 移动到下一个字符为ch处</li>
<li><code>command+f/b</code> 下一页/上一页</li>
</ul>
</li>
<li>插入模式（insert mode）：通过在正常模式下按下<code>i</code> 键切换，该模式启动以后，就会进入编辑状态，通过键盘输入内容。</li>
<li>命令模式（command mode）：在正常模式中，按下<code>：</code>（冒号）键或者<code>/</code> （斜杠），会进入命令模式。在命令模式中可以执行一些输入并执行一些 VIM 或插件提供的指令
<ul>
<li><code>ls</code> 列出打开的所有文件</li>
<li><code>b&lt;n&gt;</code> 切换到第n个文件</li>
<li><code>&lt;n&gt;</code> 跳转到第n行</li>
<li><code>set nu</code> 显示行号</li>
<li><code>/&lt;str&gt;</code> 查找目标字符串</li>
<li><code>&lt;n1&gt;,&lt;n2&gt;d</code> 删除从第n1行到第n2行的所有字符</li>
<li><code>&#123;作用范围&#125;s/&#123;目标&#125;/&#123;替换&#125;/&#123;替换标志&#125;</code> 替换文本</li>
</ul>
</li>
<li>可视模式（visual mode）：在正常模式按下<code>v, V, &lt;Ctrl&gt;+v</code>，可以进入可视模式。可视模式中的操作有点像拿鼠标进行操作，选择文本的时候有一种鼠标选择的即视感，有时候会很方便。</li>
</ul>
]]></content>
      <categories>
        <category>折腾日志</category>
      </categories>
      <tags>
        <tag>开发环境</tag>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title>初探 Docker - 原理和实践</title>
    <url>/posts/3542760854/</url>
    <content><![CDATA[<p>Docker是一种Go语言编写的容器化隔离的实现，帮助我们快速地将应用打包成<strong>容器</strong>进行发布和部署，也可以方便地运行他人编写的应用。</p>
<blockquote>
<p>一般来说Docker是运行在Unix系统环境上的，本文也是基于Linux环境的。</p>
</blockquote>
<span id="more"></span>
<h2 id="什么是容器">什么是容器</h2>
<p>所谓容器（container），是一种<strong>轻量级</strong>的虚拟化技术，像虚拟机一样，对运行在其中的进程提供隔离的运行环境（如地址空间、文件系统等），运行在其中的应用就像独占了整个物理机一样。</p>
<ul>
<li>
<p>对比OS的虚拟化技术（如虚拟存储器等），虚拟内存虽然<strong>为每个进程提供了独立的地址空间和运行上下文，但进程本身仍是运行在操作系统中的，不能提供完全隔离的进程运行环境</strong></p>
<ul>
<li>进程知道自己运行在操作系统中，接受操作系统的调度</li>
<li>进程能感知到其他进程的存在（<code>pid≠1</code>）</li>
</ul>
</li>
<li>
<p>对比虚拟机技术，虚拟机<strong>为了提供完全的隔离运行环境在宿主环境上还需要模拟一套硬件和操作系统来运行程序，对于只需要隔离运行某个进程的环境来说开销太大</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230712162825.png"
                      alt=""
                ></p>
</li>
</ul>
<h3 id="容器为什么“轻量级”">容器为什么“轻量级”</h3>
<p>如果我们想在宿主环境中轻松地部署多个服务，不考虑每个服务的细节配置（如依赖什么环境、暴露什么端口），最好的方法自然是为每个服务提供隔离的运行环境，就像运行在独立的物理机上一样。</p>
<p>而上面给出的方法都不太适用于这个需求：</p>
<ul>
<li>OS的虚拟内存显然不能满足要求，它仅仅提供了独立的地址空间和运行上下文，其系统资源仍是共享的</li>
<li>虚拟机方案需要为每个服务模拟独立的操作系统和硬件，开销过大</li>
</ul>
<p>为了解决这样的需求，<strong>容器化虚拟技术</strong>就应运而生了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230712162827.png"
                      alt=""
                ></p>
<ul>
<li>一个容器进程<strong>本质上是</strong>一个操作系统中的隔离<strong>进程</strong>，并没有为其建立独立的硬件和OS，开销相比虚拟机小了很多，因此是轻量级的虚拟化</li>
<li>被隔离的进程不能感知其他进程的存在，它就是自己环境中唯一的进程，系统资源也不与其他进程共享</li>
</ul>
<h3 id="如何实现容器隔离">如何实现容器隔离</h3>
<blockquote>
<p>🌟<strong>隔离工作是由Linux系统实现的</strong>，Docker只是帮我们打包和运行一系列隔离操作后启动这个隔离进程</p>
</blockquote>
<p>Linux利用Namespace（隔离容器）和Cgroups（调配资源）为隔离的进程在原有的独立地址空间和运行上下文上实现了进一步的隔离：</p>
<ul>
<li><strong>进程隔离</strong>：利用Linux的Namespace机制实现，结果就是<strong>以隔离方式启动的进程看到的自身进程ID总是1，且看不到系统的其他进程</strong></li>
<li><strong>文件系统隔离</strong>：利用Linux的mount机制给每个隔离进程挂载了一个虚拟的文件系统，使得<strong>一个隔离进程只能访问这个虚拟的文件系统，无法看到系统真实的文件系统</strong>（决定这个文件系统中包含哪些文件就是Docker的工作之一）</li>
<li><strong>网络协议栈隔离</strong>：利用Linux的Namespace机制，类比虚拟机的网络模式中的NAT模式，<strong>每个隔离进程实际上都拥有并运行在自己的子网上</strong>，Docker像NAT一样帮我们将某些端口暴露出来并负责进程内子网到外部端口的转发（<code>-p &lt;source&gt;:&lt;target&gt;</code>）</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230712162830.png"
                      alt=""
                ></p>
<ul>
<li><strong>限制容器资源</strong>：利用Cgroup（Linux Control Group）限制进程组（包括隔离进程）使用的资源上限，<strong>防止容器间由于不知道彼此的存在抢占所有资源导致其他服务无法运行</strong></li>
</ul>
<h2 id="Docker基本概念">Docker基本概念</h2>
<p>谈Docker的使用之前，我们要先了解Docker的三个核心概念：<strong>镜像（image）、容器（container）和仓库（repository）</strong>。</p>
<h3 id="镜像">镜像</h3>
<blockquote>
<p>🌟镜像负责为容器定义内部有什么东西，包括<code>root</code> 文件系统，程序所需要的依赖等，构建镜像就等同于构建应用所需的环境和应用本身的运行步骤。</p>
</blockquote>
<p>Linux中操作系统分为 <strong>内核</strong> 和 <strong>用户空间</strong>。对于 <code>Linux</code> 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。Docker作为容器（隔离进程）管理工具的<strong>核心工作之一就是为隔离的进程提供其所需的文件系统</strong>，而这一过程就是 <strong>镜像</strong> 的工作。</p>
<p>Docker镜像（Image）相当于一个特殊的root文件系统（如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统），除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</p>
<p>由于镜像需要包含一个完整的<code>root</code>文件系统，其体积比较庞大，因此采用了<strong>分层存储（分层构建）</strong> 的方式简化构建。镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</p>
<p>因此，在分层构建镜像时，<strong>每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</strong></p>
<h3 id="容器">容器</h3>
<blockquote>
<p>🌟容器是镜像的实例，就像类和实例一样，其本质就是前文提到的拥有自己命名空间（Namespace）的进程。</p>
</blockquote>
<p>**镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 **<code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p><strong>这里谈到的容器（container）和上面谈到的容器是同一个概念，其本质是操作系统中拥有独立命名空间的隔离进程。</strong></p>
<p>在分层存储中，容器也有自己的存储层，以前面镜像存储层为基础建立自己的<strong>容器存储层</strong>，为容器运行时读写而准备，<strong>在容器启动时生成，在容器关闭后也会清除</strong>（生命周期与容器本身相同)。</p>
<blockquote>
<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <a href="/docker_practice/data_management/volume" title="数据卷（Volume）">数据卷（Volume）</a>、或者 <a href="/docker_practice/data_management/bind-mounts" title="绑定宿主目录">绑定宿主目录</a>，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。<br>
数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>
</blockquote>
<h3 id="仓库">仓库</h3>
<blockquote>
<p>🌟仓库（repository）是用于储藏、发布容器镜像的地方。</p>
</blockquote>
<p>以Docker Repository为例：一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p>
<p>如Ubuntu仓库中<code>ubuntu</code> 是仓库的名字，其内包含有不同的版本标签，如，<code>16.04</code>, <code>18.04</code>。我们可以通过 <code>ubuntu:16.04</code>，或者 <code>ubuntu:18.04</code> 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 <code>ubuntu</code>，那将视为 <code>ubuntu:latest</code>。</p>
<h2 id="使用Docker">使用Docker</h2>
<h3 id="启动容器-docker-run">启动容器 <code>docker run</code> </h3>
<p>启动Docker服务后，在终端运行<code>docker run &lt;image&gt; &lt;...cmd&gt;</code> 指令即可启动容器，其运行流程如下：</p>
<ol>
<li>检查本地是否存在指定的镜像，不存在就从 registry 下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ol>
<p>支持的<strong>参数</strong>如下，无入参的运行参数可以合并，如<code>-it</code>：</p>
<ul>
<li><code>-t</code> 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上</li>
<li><code>-i</code> 让容器的标准输入保持打开，结合<code>-t</code> 可以生成一个交互终端</li>
<li><code>-p &lt;localPort&gt;:&lt;containerPort&gt;</code> 端口映射</li>
<li><code>-d</code> 让容器以后台守护进程（daemon）模式运行，stdout会绑定到Docker Log中，使用<code>docker attach &lt;container&gt;</code> 可以进入容器</li>
</ul>
<p>使用 <code>docker exec [opts] &lt;container&gt; &lt;cmd&gt;</code> 可以执行指定指令</p>
<h3 id="使用Dockerfile定义镜像">使用<code>Dockerfile</code>定义镜像</h3>
<p>Dockerfile 是一个文本文件，其内包含了一条条的 <strong>指令(Instruction)</strong>，每一条指令对应分层存储中的一层，因此每一条指令的内容，就是描述该层应当如何构建，因此又称<strong>分层构建</strong>。<strong>每一层的构建指令都会在原来的层上新建一层，执行命令，然后</strong>**<code>commit</code>这一层的修改。**​</p>
<p>可以说Dockerfile是一个Docker脚本，包含了把每一层修改、安装、构建、操作的命令，使用Dockerfile就可以定制自己的镜像。</p>
<h4 id="使用-FROM-指定基础镜像">使用 <code>FROM</code> 指定基础镜像</h4>
<blockquote>
<p>特殊的镜像——<code>scratch</code> ，指一个空白镜像，在直接运行二进制程序（如Go镜像）时可能会有用，因为所需的一切库都已经在可执行文件里了，并不需要OS提供运行时支持</p>
</blockquote>
<p> 所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制，而<code>FROM</code> 语句就是指定<strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且<strong>必须是第一条指令</strong>。</p>
<h4 id="使用RUN-执行命令">使用<code>RUN</code> 执行命令</h4>
<blockquote>
<p>🌟Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。</p>
</blockquote>
<p><code>RUN</code> 指令是一个强大的指令，其能力和Shell相同，可以执行系统命令或可执行文件，对应的有两种格式：</p>
<ul>
<li><code>RUN &lt;cmd&gt;</code> 系统命令</li>
<li><code>RUN [&lt;filePath&gt; [, arg1, arg2, ...]]</code> 可执行文件，以数组的形式传递参数</li>
</ul>
<p>由于<code>RUN</code> 指令会新建一层新的UnionFS存储，因此请格外注意不要创建额外的<code>RUN</code> 指令，将能合并的指令都尽量合并在一个<code>RUN</code> 中，因为<strong>UnionFS是有层数限制的</strong>（如 AUFS曾经最大不得超过 42 层，现在是不得超过 127 层）。</p>
<div class="highlight-container" data-rel="Docker"><figure class="iseeu highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Wrong: Too many layers</span></span><br><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y gcc libc6-dev make wget</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make -C /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make -C /usr/src/redis install</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Correct: Only 1 layer for `RUN`</span></span><br><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x; buildDeps=<span class="string">&#x27;gcc libc6-dev make wget&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">mkdir</span> -p /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/redis install \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/* \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> redis.tar.gz \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -r /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h4 id="构建镜像-docker-build">构建镜像 <code>docker build</code> </h4>
<p>Shell中运行<code>docker build -t &lt;name&gt; &lt;path&gt;</code> ，如<code>docker build -t test .</code> ，即可构建一个名为<code>name</code> 的镜像。</p>
<p>由于Docker实际上是一个C/S结构的程序，我们使用的<code>docker</code> 指令实际上只是客户端，所有的运行、构建工作都是在服务端进程进行的，二者通过一套REST API进行沟通，所以使用Docker可以方便地管理远程容器服务。</p>
<p>因此我们在运行<code>docker build</code> 时<strong>指定的路径会被整体打包上传给Docker引擎</strong>，因此<strong>不再是本地路径</strong>，而是引入了<strong>上下文路径</strong>这一概念，<strong>在Dockerfile中访问的路径都是上下文路径</strong>，其限制是只能访问上下文路径范围内的文件，如<code>../out.file</code> 是无法在Dockerfile中访问的。</p>
<ul>
<li><strong>其他构建方式</strong>：Dockerfile除了手动指定本地的上下文目录外还支持其他方式
<ul>
<li>从Git仓库构建：<code>docker build &lt;git-url&gt;</code></li>
<li>从tar压缩包创建：<code>docker build &lt;tar-url&gt;</code> </li>
</ul>
</li>
</ul>
<h4 id="其他指令">其他指令</h4>
<ul>
<li><strong>操作上下文目录</strong>
<ul>
<li><code>COPY &lt;src&gt; &lt;target&gt;</code> 指令将从<strong>构建上下文目录</strong>中 <code>&lt;源路径&gt;</code> 的文件/目录复制到<strong>新的一层的镜像</strong>内的 <code>&lt;目标路径&gt;</code> 位置
<ul>
<li><code>源路径</code> 可以有多个，可以是通配符
<ul>
<li>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是<strong>将文件夹中的内容复制到目标路径</strong></li>
</ul>
</li>
<li><code>目标路径</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。
<ul>
<li>目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</li>
</ul>
</li>
<li>选项
<ul>
<li><code>—source &lt;stage&gt;</code> 指定上下文目录为某个阶段</li>
<li><code>—chown</code> 更改文件状态（权限组）</li>
</ul>
</li>
</ul>
</li>
<li><code>WORKDIR &lt;dir&gt;</code> 可以来指定工作目录（或者称为当前目录），<strong>以后各层</strong>的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录<br>
区别<code>RUN cd</code> ：<code>WORKDIR</code> 适用于以后的所有层，<code>RUN cd</code> 只适用于当前层</li>
</ul>
</li>
<li><code>EXPOSE &lt;port&gt;</code> 暴露端口（指内部网络的端口），支持暴露多个端口<br>
在映射时可以手动指定每个端口的映射，也可以自动分配</li>
<li><code>CMD</code> 指定容器启动命令，和<code>RUN</code> 格式类似，但<code>CMD</code> 命令执行后容器将启动</li>
<li><code>SHELL</code> 指令可以指定<code>RUN</code> 和<code>CMD</code> 指令的宿主终端</li>
</ul>
<h3 id="数据管理">数据管理</h3>
<p><strong>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，所有的文件写入操作，都应该使用 数据卷（Volume）、或者 绑定宿主目录。</strong> 具体实现上，Docker使用Linux系统的mount功能来实现将指定目录挂载到特定物理存储区上。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230712162837.png"
                      alt=""
                ></p>
<h4 id="数据卷">数据卷</h4>
<p>数据卷（Volumn）是一个可供一个或多个容器使用的特殊目录，独立于UnionFS外部，提供一片不会随容器终止而丢失的存储空间，其设计目的就是为了<strong>实现容器间的数据共享和持久化存储</strong>。</p>
<ul>
<li><code>数据卷</code> 可以在容器之间共享和重用</li>
<li>对 <code>数据卷</code> 的修改会立马生效</li>
<li>对 <code>数据卷</code> 的更新，不会影响镜像</li>
<li><code>数据卷</code> 默认会一直存在，即使容器被删除</li>
</ul>
<p>使用 <code>docker volumn create &lt;name&gt;</code> 可以创建一个数据卷，后面通过名称来进行调用和绑定。</p>
<p>使用 <code>docker volumn ls</code> 可以查看所有数据卷。</p>
<p>要绑定数据卷可以在运行容器时使用<code>--mount</code> 参数，如下面的指令就把<code>/usr/share/nginx/html</code> 挂载到了<code>my-vol</code> 数据卷上。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    <span class="comment"># -v my-vol:/usr/share/nginx/html \</span></span><br><span class="line">    --mount <span class="built_in">source</span>=my-vol,target=/usr/share/nginx/html \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure></div>
<h4 id="挂载宿主目录">挂载宿主目录</h4>
<p>上面提到的<code>mount</code> 参数除了可以绑定创建的数据卷，也可以绑定到宿主机的某个目录上，只需要指定<code>type=bind</code> 即可。如下所示：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    <span class="comment"># -v /src/webapp:/usr/share/nginx/html \</span></span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/src/webapp,target=/usr/share/nginx/html \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>杂食编程</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 里的 shebang 踩坑记</title>
    <url>/posts/4246005333/</url>
    <content><![CDATA[<p>最近手头有一个 Node 后端项目需要用 Docker 来部署，于是火急火燎地开始学习 Docker ，但在写完 Dockerfile 后却出现了以下错误：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">env: can&#x27;t execute &#x27;node&#x27;: No such file or directory</span><br></pre></td></tr></table></figure></div>
<p>由于我的项目需要依赖本地的 pandoc 环境，因此 Dockerfile 中需要先安装 pandoc。我采用了下载预编译的二进制文件后拷贝到 <code>/usr/bin</code> 的方法进行安装，相关配置如下：</p>
<div class="highlight-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">16</span>-alpine as node</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm i -g pnpm pandoc-filter</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">FROM</span> node as pandoc</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /build</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --no-cache curl</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl -L -o pandoc.tar.gz https://github.com/jgm/pandoc/releases/download/3.1.5/pandoc-3.1.5-linux-amd64.tar.gz</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> tar xvzf pandoc.tar.gz --strip-components=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> node as deps</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package.json pnpm-lock.yaml ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pnpm install</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> node as deploy</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">ENV</span> NODE_PATH=/usr/local/lib/node_modules PATH=<span class="string">&quot;/usr/local/bin:$PATH&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /app/tmp</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=pandoc /build/bin/pandoc /usr/bin/pandoc</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=deps /app/node_modules ./node_modules</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./src .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x ./utils/filter.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;index.js&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure></div>
<p>我初步判断是 <strong>pandoc 在执行 JS Filter 的时候没有检测到 Node 环境的存在</strong>，但奇了怪了，我的<strong>基础镜像明明就是 Node 镜像</strong>，为什么会识别不到呢？</p>
<h2 id="认识-shebang">认识 shebang</h2>
<p>经过了长久的排查（甚至从最开始的官方 pandoc 镜像换成了手动 curl 安装），我确认了不是环境中没有 <code>node</code> 的问题，<code>node</code> 版本和环境变量都一切正常。</p>
<p>最终，我定位到了我的 <code>filter.js</code> 文件上。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /usr/bin/env node</span></span><br><span class="line"><span class="keyword">const</span> pandoc = <span class="built_in">require</span>(<span class="string">&quot;pandoc-filter&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">action</span>(<span class="params">&#123; t: type, c: value &#125;, format, meta</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">&quot;Image&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> src = value[value.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> srcPath = path.<span class="title function_">resolve</span>(src[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> stream = fs.<span class="title function_">readFileSync</span>(srcPath, <span class="string">&quot;base64&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> ext = path.<span class="title function_">extname</span>(srcPath);</span><br><span class="line">    <span class="keyword">const</span> base64 = <span class="string">`data:image/<span class="subst">$&#123;ext&#125;</span>;base64,<span class="subst">$&#123;stream&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> pandoc.<span class="title class_">Image</span>([<span class="string">&quot;&quot;</span>, [], []], [pandoc.<span class="title class_">Str</span>(<span class="string">&quot;image&quot;</span>)], [base64, src[<span class="number">1</span>]]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pandoc.<span class="title function_">stdio</span>(action);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>这是一个简单的用 JS 写的 pandoc filter，功能是读取文档中的图片并转为 base64 格式，在我的 Windows 环境中运行起来没有任何问题，但是在 Docker 中运行就出现了问题，而问题就出在第一行上。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env node</span></span><br></pre></td></tr></table></figure></div>
<p>第一行这个以 <code>#!</code> 开头的东西叫做 <code>shebang</code>（又称 <code>hashbang</code>），用于<strong>指定脚本文件的解释器</strong>。</p>
<blockquote>
<p>在文件中存在 Shebang 的情况下，类 Unix 操作系统的程序加载器会分析 Shebang 后的内容，将这些内容作为解释器指令，并调用该指令，并将载有Shebang的文件路径作为该解释器的参数。</p>
</blockquote>
<p>而 <code>/usr/bin/env</code> 是一个程序，用于<strong>在环境变量（PATH）中查找后面的解释器</strong>，作用是方便脚本在不同机器上可以正常运行。因此上面的 <code>shebang</code> 的意思就是：<strong>在 <code>PATH</code> 中寻找 <code>node</code> 来解释下面的脚本</strong>。</p>
<p>而报错信息：<code>env: can't execute 'node': No such file or directory</code> 实际上是 <code>/usr/bin/env</code> 发出的，表示不能在环境变量中找到 <code>node</code>。</p>
<p>奇也怪哉，我在 Shell 里运行 <code>node</code> 明明好好的，说明环境变量没有问题，为什么会找不到呢？</p>
<h2 id="CRLF-和-LF">CRLF 和 LF</h2>
<p>提到 CRLF（Windows EOL） 和 LF（Linux EOL）大家一定都不陌生，因为一些历史原因，Windows（MS-DOS）和 Unix 系统的各种标准一直都有着某些刻意为之的区别，其中就包括 EOL（End-Of-Line，行尾符）。</p>
<ul>
<li>在 Windows 中，行尾用 <code>\r\n</code> 两个字符来表示</li>
<li>在 Linux 中，行尾用 <code>\n</code>  一个字符表示</li>
<li>在 macOS 中，目前主流是用 <code>\n</code> （LF）来表示</li>
</ul>
<p>此前 CRLF 和 LF 一直没有给我造成太大的困扰，最多也就在 Git 提交时发出一些提示，因此我也没有太在意。</p>
<h3 id="CRLF-和-shebang-的奇妙化学反应">CRLF 和 shebang 的奇妙化学反应</h3>
<p>现在我们在 Windows 下编辑一个 <code>hello.js</code> 脚本文件，目的就是打印 Hello World。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<p>现在我们想让它在 Linux 中直接作为脚本运行，因此上传到了我的 WSL（Ubuntu）中，修改权限后运行：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230712155647.png"
                      alt=""
                ></p>
<p>可以看到这里出现了相似的错误 <code>/usr/bin/env: ‘node\r’: No such file or directory</code> ，因为后面有 <code>\r</code> 导致无法正常识别 node，连错误码都是一样的 127，基本可以锁定就是 <code>\r</code> 的问题了。</p>
<blockquote>
<p>这里由于我使用的是 zsh + Windows Terminal，所以可以正常地打印出错误信息里的 <code>\r</code>，如果是 <strong>Docker 中默认的 Bash 默认是打印不出 <code>\r</code> 的</strong>，这也是我找了这么久才找出问题根源的原因 QaQ。</p>
</blockquote>
<h3 id="如何解决-CRLF-的问题">如何解决 CRLF 的问题</h3>
<p>在 VS Code 下方底栏右侧可以看到当前行尾，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230712161246.png"
                      alt=""
                ></p>
<h4 id="在-Windows-侧管理">在 Windows 侧管理</h4>
<p>首先，在 VS Code （或其他编辑器）中设置 File &gt; EOL 为 <code>\n</code> （LF），保证本地创建的文件都是LF的，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230712160359.png"
                      alt=""
                ></p>
<p>然后再配置 Git 相关配置，与之相关的配置有两项：</p>
<ul>
<li><code>core.autocrlf</code> 控制文件在 Windows 电脑上时是否自动转换 CRLF（Git 内部是 LF ）
<ul>
<li><code>true</code> 提交时转换为 LF，检出时转换为 CRLF</li>
<li><code>input</code> 提交时转换为 LF，检出时不进行转换</li>
<li><code>false</code> 提交和检出时都不进行传唤</li>
</ul>
</li>
<li><code>core.safecrlf</code> 控制文件中不能同时出现 CRLF 和 LF
<ul>
<li><code>true </code> 拒绝提交包含混合换行符的文件</li>
<li><code>false</code> 允许提交混合换行符的文件</li>
<li><code>warn</code> 提交混合换行符文件时发出警告</li>
</ul>
</li>
</ul>
<h5 id="全局设置">全局设置</h5>
<p>如果你想所有代码文件都使用 LF 的话（需要与 Unix 合作的话推荐这样做）可以修改 Git 全局配置如下，配合编辑器让 Windows 处理 LF 行尾。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global core.safecrlf <span class="literal">true</span> <span class="comment"># 不允许混合换行符提交</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global core.autocrlf input <span class="comment"># 仅在提交时将CRLF转为LF，拉取时不转换</span></span></span><br></pre></td></tr></table></figure></div>
<h5 id="设置-gitattributes">设置 <code>.gitattributes</code></h5>
<p>使用 <code>.gitattributes</code> 的好处是可以保证使用这个仓库的每一个人都有相同的 Git 配置，避免协作问题。</p>
<p>以下是 Github 官方的一个模板文件：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Set the default behavior, in case people don&#x27;t have core.autocrlf set.</span><br><span class="line">* text=auto</span><br><span class="line"></span><br><span class="line"># Explicitly declare text files you want to always be normalized and converted</span><br><span class="line"># to native line endings on checkout.</span><br><span class="line">*.c text</span><br><span class="line">*.h text</span><br><span class="line"></span><br><span class="line"># Declare files that will always have CRLF line endings on checkout.</span><br><span class="line">*.sln text eol=crlf</span><br><span class="line"></span><br><span class="line"># Denote all files that are truly binary and should not be modified.</span><br><span class="line">*.png binary</span><br><span class="line">*.jpg binary</span><br></pre></td></tr></table></figure></div>
<p>修改第一行 <code>* text=auto</code> 为  <code>* text=auto eol=lf</code> 即可将所有代码文件的行尾都规定为 LF，如果不符合规范就不能提交。</p>
<h4 id="在-Linux-侧管理">在 Linux 侧管理</h4>
<p>由于 CRLF 和 LF 其实是一个历史悠久的问题，从 DOS 时期就有了，所以 Linux 上也有不少转化工具，如 <code>dos2unix</code> 。</p>
<p>以上面的 <code>hello.js</code> 为例执行转换：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install dos2unix</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dos2unix ./hello.js</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./hello.js</span></span><br></pre></td></tr></table></figure></div>
<p>转化后就可以正确执行，运行结果如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/07/20230712161908.png"
                      alt=""
                ></p>
]]></content>
      <categories>
        <category>杂食编程</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>协变与逆变</title>
    <url>/posts/2729707727/</url>
    <content><![CDATA[<p>协变（covariant）和逆变（contravariant）是对于类型的概念，是类型安全和类型转换中的重要概念，但可能对大多数初学者来说是一个陌生的概念。</p>
<span id="more"></span>
<p>其概念借鉴自范畴论，在C#/Java/Typescript这样强类型安全语言中有较广泛的应用，维基百科上的解释相对复杂，数学意味比较重，令许多人望而生畏。</p>
<p>希望本文能够消除其神秘感，用尽量通俗的语言使大家理解协变和逆变及其在泛型中的应用。</p>
<h2 id="背景知识">背景知识</h2>
<p>首先我们来看一个例子，这是我最近在完成的一个机器学习模型运行平台的UML类图，我们借用其结构来观察类之间的继承关系。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202301241617468.png"
                      alt=""
                ></p>
<p>我们看左边那一列，继承链是这样的，从左到右为子类的父类的<strong>协变</strong>顺序：<code>MLPModel-&gt;NNModel-&gt;MLModel-&gt;ModelBase</code>（这里不需要思考为什么，只需要知道这个序列就行了）</p>
<h3 id="协变与逆变的定义">协变与逆变的定义</h3>
<p>我们都知道，在几乎所有面向对象的语言中，子类型都可以隐式的转为父类型（如上文中<code>PRModel</code>可以隐式转为<code>ModelBase</code>类型而不发生错误）。</p>
<p>我们说A如果可以隐式转化成B，A就是B的子类型（A≤B），如int可以隐式转化为float，则int就是float的子类型。</p>
<p>需要明晰的一点是：<strong>在子类型序列关系的角度上，A≤B（A是B的子类型）；但从实现的角度上，A是B的子类，那么A实现的成员一定涵盖的B的所有成员（可以说是大于等于）。</strong></p>
<p>以上文给出的<strong>子类型序列关系</strong>为例：<code>MLPModel≤NNModel≤MLModel≤ModelBase</code></p>
<p>根据上面的<strong>子类型序列关系</strong>（即从小到大排列的继承链），我们就可以<strong>定义协变和逆变</strong>：</p>
<ul>
<li><strong>协变</strong>（covariant）：变化方向与<strong>子类型序列</strong>相同（如把<code>MLPModel</code>对象变成<code>ModelBase</code>对象）</li>
<li><strong>逆变</strong>（contravariant）：与协变相反，变化方向与<strong>子类型序列</strong>相反</li>
</ul>
<p>在本例的UML图中，其具体放下如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202301241624467.png"
                      alt=""
                ></p>
<p>在绝大多数编程语言中，协变是允许的，而逆变是禁止的，原因显而易见：<strong>协变是类型安全的，而逆变是类型不安全的</strong>。因此逆变的实际应用并不在将基类对象直接转换成子类类型（父类实例可能没有子类的成员，在引用调用时会出现<code>NullReference</code>的类型安全问题），而是在与生产者与消费者函数相关的定义上。</p>
<h3 id="PECS规则">PECS规则</h3>
<p><strong>PECS（Producer Extends Consumer Super）规则</strong>是在Java中广泛应用的一种类设计规则，目的是让生产者和消费者都能在类型安全的前提下处理最大范围的数据类型，具体规则就是<strong>生产者（产生数据）考虑数据类型时应该尽量沿继承树向下，越具体越好；消费者（接收数据）考虑数据类型时应该尽量沿着继承树向上，越抽象越好</strong>。</p>
<p>用协变和逆变的语言来说就是：<strong>生产者逆变，消费者协变</strong>。</p>
<p>为什么这样可以最大范围地接收数据且保证类型安全呢？我们不妨分开思考：</p>
<p>我们假设有一个<code>Animal</code>类，其子类有<code>Cat</code>、<code>Bear</code>等，再往下又按不同颜色有<code>WhiteCat,</code> <code>BlackBear</code>等各自的子类。</p>
<ul>
<li><strong>生产者（producer, out-only）</strong>：现有一个生产动物的类型，返回一个Animal类型的对象
<ul>
<li>先不考虑逆变的协变的问题，仅从类型安全的角度考虑，我们发现该类型其实可以返回Cat, Bear等类型的对象，因为它们都是Animal，是安全的隐式转换。</li>
<li>再回归到协变和逆变的角度，我们发现返回值从Animal类型到Cat类型是<strong>逆变</strong>的，这满足PECS原则；但在其内部的赋值又是协变的（Cat对象赋值给Animal类型是类型安全的）。</li>
</ul>
</li>
<li><strong>消费者（consumer, in-only）</strong>：现有一个收购动物的类型，它接收一个Animal类型的对象
<ul>
<li>这个比较直观，因为Bear、Cat等都是动物，可以直接被接收</li>
</ul>
</li>
</ul>
<h3 id="里氏替换原则">里氏替换原则</h3>
<p><strong>子类对象的行为应该可以完全替代父类对象的行为</strong>，满足里氏替换的类型转换就是类型安全的。</p>
<p>这部分其实相对不那么重要，一时间没想清楚可以跳过。</p>
<p>那么和我们的协变逆变有什么关系呢？我们只需要把继承链倒过来，把原本的子类作为父类，看作一种新的继承，这样就可以把逆变应用到里氏替换中来判断是否类型安全了。</p>
<h2 id="泛型中的协变与逆变限制">泛型中的协变与逆变限制</h2>
<p>理解了协变与逆变的基本概念后，我们来着手看一个例子来理解泛型中为什么要对协变性和逆变性做出限制。</p>
<p>在C#/Java中，有许多基于其他类型的类型，如数组类型，它是允许协变的（允许把string[]隐式转化成object[]），这样做有许多好处，例如可以写出下列代码通用地比较所有对象数组：</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">ArrayEquals</span>(<span class="params"><span class="built_in">object</span>[] a, <span class="built_in">object</span>[] b</span>)</span>;</span><br></pre></td></tr></table></figure></div>
<p>但是我们需要注意，此处类型安全地原因是该函数仅在这次转换中担任消费者的地位，因此允许协变，是类型安全的。</p>
<p>我们再看另一个例子：当允许协变的数组类型作为生产者（需要返回一个新的实例）时，类型安全就会崩溃。</p>
<p>现在我们看下面的代码：</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] a = <span class="keyword">new</span> <span class="built_in">string</span>[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组是允许协变的，因此下列操作是合法的</span></span><br><span class="line"><span class="built_in">object</span>[] b = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向object数组插入一个float类型的值对象</span></span><br><span class="line"><span class="comment">// 对于object类型的数组来说是合法的，但实际上是一个string对象，因此是类型不安全的</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">1.0</span>;</span><br></pre></td></tr></table></figure></div>
<p>在上述例子中，我们看到了允许协变也可能带来类型不安全的问题。</p>
<p>解决方案也很简单，就和大家想的一样，根据PECS原则，对基于其他类型的类型做出如下限制：</p>
<ul>
<li>对于允许协变的类型，我们限制其是只读的，不能改变其值。</li>
<li>对于允许逆变的类型，秉承与协变相反的对称性原则，我们限制其是只写的，不能读取其值（不能确定读出来值类型）</li>
</ul>
<h3 id="C-中in和out关键字">C#中in和out关键字</h3>
<p>C#中使用in和out关键字来允许基于类型的类型（如泛型）的协变和逆变。</p>
<h4 id="使用out来允许协变">使用out来允许协变</h4>
<p>在声明类型参数时加入out关键字来使该类型允许协变，如<code>&lt;out T&gt;</code>。如此，该类型在处理T的继承关系时就允许协变，但代价是与T相关类型的赋值操作是不变的（不允许协变或逆变的赋值操作）。</p>
<p>这样的限制可以规避我们之前提到的类型不安全的状况。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下列语句在没有out时编译器不通过</span></span><br><span class="line"><span class="comment">// 有了out语句，cats列表可以转化为animals列表，因为所有Cat都是Animal（协变）</span></span><br><span class="line">IEnumerable&lt;<span class="keyword">out</span> Cat&gt; cats = <span class="keyword">new</span> ...;</span><br><span class="line">IEnumerable&lt;<span class="keyword">out</span> Animal&gt; animals = cats;</span><br></pre></td></tr></table></figure></div>
<h4 id="使用in来允许逆变">使用in来允许逆变</h4>
<p>逆变的情况总是比协变稍微难解释一些。</p>
<p>在声明类型参数时加入in关键词来允许该类型逆变，如<code>&lt;in T&gt;</code>。</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有了in语句，animals列表可以接收Cat实例，是逆变</span></span><br><span class="line">List&lt;<span class="keyword">in</span> Animal&gt; animals = <span class="keyword">new</span> List&lt;Animal&gt;();</span><br><span class="line"><span class="comment">// 下列语句在没有in时编译器不通过</span></span><br><span class="line">animals.Add(<span class="keyword">new</span> Cat());</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>类型转换</tag>
        <tag>类型安全</tag>
        <tag>oop</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈软件架构：微服务和微前端</title>
    <url>/posts/317388827/</url>
    <content><![CDATA[<p>之前在另一家公司实习的时候就被微服务架构等一系列词汇搞得晕乎乎的，好在最后也没涉及这方面的事情，也就不了了之了。</p>
<p>最近又刷到了这方面的东西，正好现在公司里有一些相关的事情（在架构上），也正好做一个学习了解，捋一捋<strong>微服务（micro-service）</strong>、<strong>微前端（micro-frontend）</strong> 还有一个更摸不着头脑的 <strong>“无服务”（serverless）</strong> 是什么东西。</p>
<span id="more"></span>
<p>当然，因为最近做的一直是前端开发这方面，我的重心自然会放在微前端上，但由于这是个历史发展的概念，只有理解了微服务的发展历史才能更好地理解为什么需要、如何利用微前端架构进行开发。因此我<strong>不会细究微服务的部署，但会尝试微前端的部署过程与实例</strong>。</p>
<h2 id="微服务">微服务</h2>
<p>软件架构分为许多类别，如单体架构、微服务架构、分布式架构等，它们虽有出现的先后顺序之别，但<strong>严格意义上并没有先进与否的区别，只是适用于不同的应用场景项目规模</strong>。</p>
<p>比如你一个小的不能再小的应用，非要上分布式或者微服务，那可能就是脱了裤子放屁，可能RPC开销、管理成本、MapReduce开销等等都会超过你任务本身的开销，因此还是应该按需选择最合适的方案。</p>
<p>要理解微前端本身，我们首先要从软件架构的发展讲起，理解为什么需要微前端架构。</p>
<h3 id="单体架构的发展">单体架构的发展</h3>
<h4 id="单体架构">单体架构</h4>
<p><strong>单体架构</strong>（monolithic software）是一种将所有功能和逻辑写在一个项目（或部署在一个项目/容器）中的写法，一个实例中集成了一个系统的所有功能，并通过负载均衡软件/设备实现多实例调用。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230525005329.png"
                      alt=""
                ></p>
<p>如我们熟知的MVC、MVVM架构严格意义上都属于单体架构，它们虽然在业务逻辑（如视图层、View Model和逻辑层）上做了区分，但本质上仍是单体应用。</p>
<p>区别一个单体应用最好用的方法就是：<strong>你对其中某一个功能进行改动，会不会需要重新编译整个项目？需不需要担心耦合造成的蝴蝶效应？</strong> 如果会，那就是单体应用。</p>
<h4 id="单体架构发展的后期">单体架构发展的后期</h4>
<p>最开始的单体架构是所有功能都耦合在一起，甚至前后端不分离，但随着项目体量的不断扩大，单体模式的弊端逐渐显露出来，如：扩展性差、无法实现复杂业务、技术升级困难等。</p>
<p>为了解决上述问题，人们给单体架构打了一些“补丁”，对代码进行拆分来提高维护性：</p>
<ul>
<li>分层开发：如MVC、MVVM等<strong>设计模式</strong>（是的，算设计模式而不是软件架构），将视图层和逻辑层代码分离开来，但还是放在一个项目中</li>
<li>业务拆分：按照业务对模块进行拆分，但模块之间如何相联就成了下一个问题（如果分开开发，一起部署就仍是单体架构；如果分开部署到Web上，则成了后文提到的<a href="#%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84">SOA架构</a>）</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/gudaoxuri/Microservices-Architecture/master/resources/images/monolithic-split.png"
                      alt=""
                ></p>
<h3 id="面向服务架构">面向服务架构</h3>
<p><strong>面向服务架构（SOA，Service-Oriented Architecture）<strong>伴随着互联网的兴起而兴起，将功能单元拆分出来放在互联网上来提供“服务”，在某些地方也被称为</strong>“分布式架构”</strong>，由于出现的年代也比较久远，一般被看作一种“中型架构”，作为“单体架构的并行拓展”。</p>
<p>具体地说，<strong>面向服务架构或者说分布式架构</strong>，将一个大的系统划分为多个业务模块，业务模块分别部署在不同的服务器上，各个业务模块之间通过接口进行数据交互。数据库也大量采用分布式数据库。通过LVS/Nginx代理应用，将用户请求均衡的负载到不同的服务器上。</p>
<p>所谓服务（service），就是在后台不间断运行、提供某种功能的一个程序。最常见的服务就是 Web 服务，通过80端口向外界提供网页访问，所以我们常见的C/S架构其实也算一种面向服务架构（后端向前端提供某种“服务”）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/gudaoxuri/Microservices-Architecture/master/resources/images/soa.png"
                      alt=""
                ></p>
<p>采用SOA架构有以下优点：</p>
<ul>
<li>每种服务功能单一，相当于一个小型软件，便于开发和测试；</li>
<li>各个服务独立运行，可以单独开发和部署，可以使用不同的语言和工具开发；</li>
<li>鼓励和支持代码重用，同一个服务可以用于多种目的；</li>
<li>扩展性好，可以容易地加机器、加功能，承受高负载；</li>
<li><strong>面向服务架构默认运行在不同服务器上</strong>，每台服务器提供一种服务，多台服务器共同组成一个完整的网络应用，即使一个服务失败了，不会影响到其他服务。</li>
</ul>
<h4 id="通信协议：SOAP和REST">通信协议：SOAP和REST</h4>
<p>既然服务是运行在Web上的，那么如何制定通信标准就是一个棘手且紧急的问题。</p>
<p>早期的SOA多以基于<strong>SOAP (Simple Object Access Protocol)协议</strong>的Webservice实现，因其通过WSDL (Web Service Description Language)实现了严格服务间通讯格式约束，所以它非常适用于对稳定性要求高、不易变、防御式的场景， 这种方式在当下的银行、电信系统中还有很大市场。但SOAP的优势也为其带来了：笨重、不灵活、修改困难、通讯效率低等问题。</p>
<p>我个人是搞前端的，入行的时候也已经REST大行其道了，因此这里也主推RESTful API规范。</p>
<blockquote>
<p>REST（Representational State Transfer, 代表性的状态迁移）是Roy Thomas Fielding博士于2000年在他的博士论文中提出来的一种互联网软件架构风格， 目的是便于不同软件/程序在网络中互相传递信息。 使用上看似简单，但背后有着深厚的理论支持。 <a class="link"   href="https://en.wikipedia.org/wiki/Representational_state_transfer" >详见此处 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>HTTP是REST的一个主要表现协议，但REST本身是协议无关的。在实际开发中，我们可近似地认为REST就是用于HTTP的，使用HTTP的请求头操作字段，如GET/POST/MODIFY等。</p>
</blockquote>
<p>REST的核心特征是<strong>面向资源（Resource Oriented）、可寻址（Addressability）、连通性（Connectedness）、无状态（Statelessness）、统一接口（Uniform Interface）、超文本驱动（Hypertext Driven）</strong>。</p>
<p>RESTful API 将所有服务抽象为资源，资源不仅代表服务器中的文件、数据库中的表等具体的东西，它可以是任何对象。 通过URL定位资源，使用 HTTP 方法（HTTP Method）确定对资源执行什么操作，通俗地说（严格而言有一定问题，见下文说明）所有操作都可以抽象为CRUD（Create-创建，Retrieve-查询，Update-更新，Delete-删除），可分别对应于HTTP的 POST、GET、PUT、DELETE。 由于使用标准的HTTP操作、没有Schema约束，REST成为系统间轻量交互的首选方式。</p>
<p>虽然REST的大道理很多，背后有很多理论支持，但我们使用它只需要遵循简单的规范，并不需要去证明高深的理论，就可以构造出简明易懂且灵活的API，这也是REST的魅力所在。</p>
<h3 id="微服务架构">微服务架构</h3>
<p>说了这么久终于说到主角了啊，介绍了SOA架构后理应就可以满足大部分需求了，为什么还要引入微服务架构呢？</p>
<p>SOA架构有以下缺点，在项目规模被进一步放大后其劣势将被凸显出来：</p>
<ul>
<li><strong>传统SOA拆分的粒度较大</strong> 一般按业务域划分系统，但很少涉及系统内细粒度地拆分。传统SOA只解决了业务层面的划分和系统之间的交互，但<strong>没能从架构层面解决系统内的复杂度</strong>、效率、安全等单体架构所存在的问题</li>
<li><strong>传统SOA多需要集中的服务总线，容易产生性能瓶颈</strong> ESB（Enterprise service bus）几乎是传统SOA必备的，它集通信交互、服务编排、认证授权、质量监控等功能于一身，可十分方便地管理各个零散的系统。而一旦涉及总线，那性能瓶颈就一定会受木桶效应的影响，而这个短板在爆发式高并发场景下一般都是总线本身（学过组原的应该都有所体会）。</li>
</ul>
<p>因此，随着Docker等容器技术的兴起，**微服务（micro-service）**作为SOA架构的进一步延申出现了。</p>
<p>对SOA架构系统内部的功能再进一步进行抽象和解耦，我们就可以得到<strong>一条条独立运行的微服务</strong>。</p>
<p>我们以一个网上商城系统为例，在SOA架构下如下图所示，每个前端都对应了一系列的服务，按业务群进行划分：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230525145429.jpg"
                      alt=""
                ></p>
<p>可以直观地看出，不同系统之间有较多的重复和耦合部分，增加需求和更改现有功能都比较困难，统一的数据库也容易产生性能瓶颈。</p>
<p>这时我们就可以对其进行进一步地抽象，降低系统内部地复杂度，如独立出用户功能、促销活动、商品查询等一系列微服务，彼此独立运行、维护和开发，每个服务也有自己的数据库，并交给一个或多个负载均衡器进行负载分配，这样系统的可维护性和稳定性就大幅增加了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pica.zhimg.com/v2-90388920d31fe35b791c6a92f758db18_r.jpg?source=1940ef5c"
                      alt=""
                ></p>
<p>简单地说：<strong>微服务在开发方面，就是对系统功能的进一步解耦，注重不同服务之间的独立性和隔离性，提高系统整体和功能的可维护性；在部署方面，基于容器技术，使部署更灵活和便利。</strong></p>
<h4 id="SOA与微服务的区别">SOA与微服务的区别</h4>
<p>虽说微服务在发展上是SOA的进一步细化，但二者在设计思路上还是有不少的区别。</p>
<ul>
<li><strong>SOA喜欢重用，微服务喜欢重写</strong>：由于ESB（统一总线）的存在，SOA总是倾向于重用已有的服务；但微服务的应用场景却更多的是修改或重写某个独立的功能而不改动整个系统</li>
<li><strong>SOA喜欢水平服务，微服务喜欢垂直服务</strong>：<strong>SOA</strong>设计喜欢给服务分层(如Service Layers模式)，形成一个金字塔式的层级调用模式；微服务通常是直接面对用户的，每个微服务通常直接为用户提供某个功能。</li>
<li><strong>SOA喜欢自上而下（顶层设计优先），微服务喜欢自下而上（底层隔离优先）</strong>：<strong>SOA</strong>架构在设计开始时会先定义好服务合同(service contract)。 它喜欢集中管理所有的服务，包括集中管理业务逻辑，数据，流程，schema，等等；<strong>微服务</strong>则敏捷得多。只要用户用得到，就先把这个服务挖出来。然后针对性的，快速确认业务需求，快速开发迭代</li>
</ul>
<h4 id="微服务架构的缺点">微服务架构的缺点</h4>
<blockquote>
<p><strong>没有银弹！</strong> ——<em>The Mythical Man-Month</em> By Fred Brooks</p>
</blockquote>
<p>一个老生常谈的问题，任何架构或方案的选择并不存在绝对的优劣，而是针对实际开发场景的trade-off。</p>
<p>最显然的问题就是，当应用规模并不需要微服务这样细粒度的服务划分时，对系统的细分和分布式系统的开销就会超过系统本身，成为累赘。</p>
<p>除此之外，微服务的分布式系统包括分布式数据库、负载均衡还有系统之间复杂的依赖网络等特征显著<strong>提高了系统的复杂度</strong>，最明显的地方就是每年arXiv都有无数和微服务指标诊断和预测还有异常处理的论文产出，个人也在这方面做过一些研究（如AutoMap）。</p>
<p>举个例子，一个庞大的系统内微服务之间的依赖通常是极为复杂的，不仅有直接依赖，还有影响更深远但难以察觉的间接依赖，这就容易导致<strong>雪崩效应</strong>（一个服务崩溃的蝴蝶效应导致整个系统崩溃）。更糟的是，由于复杂的依赖关系，你无法快速地定位到错误产生的源头，导致服务维护时间被延长，产生巨大损失（这也是为什么这个领域频繁产出论文的原因）。</p>
<p>比如说，你的订单系统崩了，你从订单系统出发，一路检查了商品数据库、负载均衡系统等等，始终没有头绪，最终发现是你的订单服务在读取名称时由于XX客户正在修改用户名触发了写保护，而某个服务恰好没有做一致性回退，直接Crash掉了，导致下一个调用这个服务的服务成了幸运儿，一传十十传百，最后整个服务都崩了。（虽然这种东西不太可能发生啦）</p>
<h4 id="Serverless-架构">Serverless 架构</h4>
<p>当我们还在容器的浪潮中前行时，已经有一些革命先驱悄然布局另外一个云计算战场：<strong>Serverless架构</strong>。</p>
<p>不得不说，serverless真的是一个非常容易引起误会的词，第一次遇到这个词还是在论文里，当时以为是一种触发无服务的异常，后来才知道这是一种服务提供的类型。</p>
<blockquote>
<p>Serverless（无服务器计算，或者说no-server）是一种新型云服务提供方式，用户不需要关心基础设施和如何部署，只需要关心服务本身。</p>
</blockquote>
<p>个人感觉serverless更像是一种<strong>商业概念</strong>，它是云服务的一种新型计费方式，也就是说不再按固定的服务器资源计费，而是基于微服务架构更灵活地按量计费。</p>
<p>云计算通常有<strong>基础设施即服务（IaaS），平台即服务（PaaS）和软件即服务（SaaS）</strong> 等计费模式：</p>
<ul>
<li><strong>IaaS和PaaS时期</strong>：云计算主要以虚拟机的形式提供纯粹的硬件资源，并且通过统一化开发平台（PaaS），提供更丰富的计算和开发体验服务。云计算商业模式之所以能够成立，是因为其一直在满足一个基本假设：『<strong>如果把云用作出租的计算基础设施，那么云的弹性部署和集中维护，可以让云服务成本低于拥有成本</strong>』
<ul>
<li>把虚拟机做作为弹性部署资源的单位其实并不合适，即使运维成本已经通过屏蔽硬件细节，让在整体方案中被降到最低，但是它依然是一笔非常庞大的支出，因为开发人员往往需要过度配置来提高冗余</li>
</ul>
</li>
<li><strong>SaaS时期</strong>：在这种基础上，云计算用户不需要考虑更多支撑硬件，不需要考虑很多服务器平台，也不需要考虑部署环境是否一致，暴露在外的只是提供的硬件服务。这类平台有非常多而且非常成功的实现方案。但是同样，虽然云计算减轻了物理计算设施的负担，却留给云计算用户越来越多的虚拟资源需要管理，甚至要考虑更新型的架构设计。</li>
<li><strong>FaaS和BaaS时期</strong>：在微服务和容器化的趋势下，实现了只把代码放在云计算平台上，在被调用时让代码本身按需扩展的服务模式的可能性</li>
</ul>
<p>因此，<strong>「无服务器计算」并不是严格意义上的「无服务器」，因为不论如何抽象或者封装底层设备，程序总是要有一个服务器作为物理载体才能运行</strong>。与服务器相对，「无服务器计算」这个概念其实更加强调计算资源自由扩展，无需人工手动配置，相当于云计算用户把设备资源的缩放管理放置在云端，从而可以很方便地维护或者扩展平台。</p>
<p>这也是我把serverless归入微服务这一栏的原因，因为serverless的兴起很大程度上就是和微服务架构的兴起是一致的，它也仅仅是云服务提供商在部署层基于微服务架构提出的概念而已。</p>
<h2 id="微前端">微前端</h2>
<p>回顾微服务的历史，我们发现<strong>微服务的出现是因为整个服务系统过于厚重，而对其进行进一步的拆分和抽象为更小的服务（微服务），可以独立维护、部署，满足敏捷开发需求</strong>。</p>
<p>然而，越来越重的前端工程也面临同样的问题，自然地想到了将微服务思想应用（照搬）到前端，于是有了「微前端（micro-frontends）」的概念：<strong>将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的小块，而在用户看来仍然是内聚的单个产品</strong>。当然，具有了微服务的优点，自然也有微服务带来的复杂性和缺点。</p>
<p>微前端架构的出现主要可以满足以下需求：</p>
<ul>
<li>代码库更小，更内聚、可维护性更高</li>
<li>松耦合、自治的团队可扩展性更好</li>
<li><strong>渐进地升级、更新甚至重写部分前端功能成为了可能</strong>（主要需求）
<ul>
<li>增量升级：解决了没法大刀阔斧地腾出时间对整个系统进行重构的问题，可以只对某个部分进行重构，部分地解决了尾大不掉的问题</li>
<li>独立部署：大型前端项目的部署时间是很长的（此处痛骂webpack一小时），且不同项目之间可能会产生意想不到的影响；微前端架构下每个微前端都应具备有自己的持续交付流水线（包括构建、测试并部署到生产环境），并且要能独立部署，不必过多考虑其它代码库和交付流水线的当前状态</li>
<li><strong>解锁了不同技术栈并存的可能性</strong></li>
</ul>
</li>
</ul>
<h3 id="实现方案">实现方案</h3>
<p>微前端架构中一般会有个<strong>容器应用（container application）</strong> 将各子应用集成起来，职责如下：</p>
<ul>
<li>渲染公共的页面元素，比如 header、footer</li>
<li>解决横切关注点（cross-cutting concerns），如身份验证和导航</li>
<li>将各个微前端整合到一个页面上，并控制微前端的渲染区域和时机</li>
</ul>
<p>集成方式分为 3 类：</p>
<ul>
<li>服务端集成：如 SSR 拼装模板</li>
<li>构建时集成：如 Code Splitting</li>
<li>运行时集成：如通过 iframe、JS、Web Components 等方式</li>
</ul>
<h4 id="服务端集成">服务端集成</h4>
<p>服务端集成的关键在于<em>如何保证各部分模板（各个微前端）能够独立发布</em>，必要的话，甚至可以在服务端也建立一套与前端相对应的结构：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/v2-0f85595a0f60bc40f7ff9a0c2d0790f3_r.jpg"
                      alt=""
                ></p>
<p>每个子服务负责渲染并服务于对应的微前端，主服务向各个子服务发起请求</p>
<h4 id="构建时集成">构建时集成</h4>
<p>常见的构建时集成方式是将子应用发布成独立的 npm 包，共同作为主应用的依赖项，构建生成一个供部署的 JS Bundle</p>
<p>然而，<strong>构建时集成最大的问题是会在发布阶段造成耦合</strong>，任何一个子应用有变更，都要整个重新编译，意味着对于产品局部的小改动也要发布一个新版本，因此，<strong>不推荐这种方式</strong></p>
<h4 id="运行时集成">运行时集成</h4>
<p>将集成时机从构建时推迟到运行时，就能避免发布阶段的耦合。常见的运行时集成方式有：</p>
<ul>
<li>iframe</li>
<li>JS：比如前端路由</li>
<li>Web Components</li>
</ul>
<p>虽然直觉上用 iframe 好像不太好（性能、通信成本等），但在这里确实是个合理选项，因为 iframe 无疑是最简单的方式，还天然支持样式隔离以及全局变量隔离</p>
<p>但这种<em>原生的隔离性，意味着很难把应用的各个部分联系到一起</em>，路由控制、历史栈管理、深度链接（deep-linking）、响应式布局等都变得异常复杂，因而限制了 iframe 方案的灵活性</p>
<p>另一种最常见的方式是前端路由，每个子应用暴露出渲染函数，主应用在启动时加载各个子应用的独立 Bundle，之后根据路由规则渲染相应的子应用。目前看来，是<strong>最灵活的方式</strong></p>
<p>还有一种类似的方式是<a class="link"   href="http://www.ayqy.net/blog/web-components/" >Web Components <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，将每个子应用封装成自定义 HTML 元素（而不是前端路由方案中的渲染函数），以获得<a class="link"   href="http://www.ayqy.net/blog/web-components/#articleHeader6" >Shadow DOM <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>带来的样式隔离等好处。</p>
<h3 id="你是否真的需要微前端">你是否真的需要微前端</h3>
<p>这个问题其实是微服务中常问的<strong>你真的需要微服务吗</strong> ？，只是作为一个前端我把这部分放在了微前端的部分。</p>
<blockquote>
<p>设计系统的架构受制于产生这些设计的组织的沟通结构。 — M.Conway</p>
</blockquote>
<p><a class="link"   href="https://zh.wikipedia.org/wiki/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B" >康威定律 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>几乎就是微前端（准确来说是微服务架构）的理论基础了。它指出了组织架构越庞大，其系统间沟通成本越高的问题。而解决这一问题的有效手段就是，将大的系统拆分成一个个微小的，可以独立自治的子系统。一旦系统的依赖限制在了内部，功能上更加内聚，对外部的依赖变少，那么就能显著的减少跨系统之间的沟通成本了。</p>
<blockquote>
<p>微前端（微服务）的假设是，所有大型系统都逃不过熵增定律，所有大型系统都将从有序变为无序，他们背后的 codebase 的归宿都将是「屎山」</p>
</blockquote>
<p>基于此，微前端很多时候是「悲观主义工程师」在工程上的妥协，是一种防御性，有时候甚至是「掩耳盗铃」式的架构策略。当然，微前端倡导的不是消极的、投降主义的去回避系统中的历史遗留问题，而是告诉我们，很多时候我们可以通过分而治之的手段，让「上帝的归上帝，凯撒的归凯撒」。</p>
<p>基于以上两个观点，我们可以概括出，存在以下场景时，你可能就不需要微前端：</p>
<ol>
<li>你/你的团队 具备系统内所有架构组件的话语权；简单来说就是，系统里的所有组件都是由一个小的团队开发的。</li>
<li>你/你的团队 有足够动力去治理、改造这个系统中的所有组件，直接改造存量系统的收益大于新老系统混杂带来的问题。</li>
<li>系统及组织架构上，各部件之间本身就是强耦合、自洽、不可分离的，系统本身就是一个最小单元的「架构量子」，拆分的成本高于治理的成本。</li>
<li>极高的产品体验要求，对任何产品交互上的不一致零容忍，不允许交互上不一致的情况出现，这基本上从产品上否决了渐进式升级的技术策略</li>
</ol>
<h3 id="微前端框架实践">微前端框架实践</h3>
<p>现在流行的微前端框架为<a href="">micro-app</a>, <a href="">qiankun</a>和<a href="">single-spa</a>，我将采取<strong>在现有Vue3 SPA中嵌入React 18的页面和组件的方式</strong>来测试这些微前端的架构、性能和使用体验。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/v2-54f479648cb64932eb0d5d449cec714f_r.jpg"
                      alt=""
                ></p>
<div class="note info"><p>这部分将在公司项目实践后完成</p>
</div>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a class="link"   href="https://www.ruanyifeng.com/blog/2022/04/microservice.html" >微服务是什么？ - 阮一峰的网络日志 (ruanyifeng.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://docshome.gitbook.io/microservices/" >Introduction - 微服务：从设计到部署 (gitbook.io) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://gudaoxuri.gitbook.io/microservices-architecture/" >微服务架构设计 - 微服务架构设计 (gitbook.io) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247490615&amp;idx=1&amp;sn=1a8c7126bf46a3cf1add60119803f220#wechat_redirect" >微服务 2.0 技术栈选型手册 (qq.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://cloud.tencent.com/developer/news/841137" >微服务架构超强讲解，通俗易懂，写得太好了！ - 腾讯云开发者社区-腾讯云 (tencent.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.zhihu.com/question/65502802" >微服务架构是什么？ - 知乎 (zhihu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.zhihu.com/question/55511712" >什么叫做微服务？它和传统的项目之间有什么区别？ - 知乎 (zhihu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://crimsonromance.github.io/2019/03/23/%E5%9B%9B%E7%A7%8D%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E3%80%81Serverless%E6%9E%B6%E6%9E%84/" >四种软件架构：单体架构、分布式架构、微服务架构、Serverless架构 | 戴树谦的博客 (crimsonromance.github.io) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/96464401" >微前端到底是什么？ - 知乎 (zhihu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/391248835" >你可能并不需要微前端 - 知乎 (zhihu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/480796762" >微前端框架哪个好？QianKun还是MicroApp - 知乎 (zhihu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/453011497" >微前端x重构实践落地总结 - 知乎 (zhihu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>微前端</tag>
        <tag>软件架构</tag>
      </tags>
  </entry>
  <entry>
    <title>20岁的碎碎念</title>
    <url>/posts/2736955906/</url>
    <content><![CDATA[<p>小时候总是觉得大人说的时间一晃眼就过了，就像门口会捡小孩的流浪汉一样是骗小孩的拙劣谎言。</p>
<p>幼时的阳光在课后懒洋洋地撒下，细碎地铺在我家店铺那条街后的小山上。一地的红色碎石还有从中挤出长到半个小孩高的小草，童年就像从那夹杂着泥土和碎石的山坡上一次次地滑下，把妈妈新买的衣服裤子弄得稀脏，再腆着脸讨要每日份的冰淇淋。</p>
<p>这样的日子怎么会有尽头呢？每天都是那么漫长，下课抄完作业后就有用不完的时间，大人们真是太坏了，就连这么浅显的道理都要骗我们。</p>
<p>那时的我懒洋洋地躺在簇草包围的红土地上，一边盘算着周末快乐的CF时光，一边对撒谎的大人不屑一顾。</p>
<p>再到后来，奥数课本爬上了我的课桌，我坐上了远赴他乡的轿车。甚至，我下次回来的时候，那个衣衫褴褛却乐得逍遥的流浪汉也不见了踪影。</p>
<p>可是，时间还是很慢，哪怕是被绑在书桌前，也要在我的笔尖下不停绕转，不肯溜走一刻。</p>
<hr>
<p>有一天晚上，周考数学没及格，被老师用扇子打了手心，那股钻心的疼让我差点没忍住眼泪。我透过一层薄薄的水膜盯着那张鲜红的试卷，一道一道地抄下错题，再一道一道地看着我的大绿皮教材，试图背下每一个知识点。</p>
<p>下课铃响了，我怔怔地看着起身走散的人群，有些不知所措。那是我第一次感受到的时间的快进，真的就像大人说的一晃眼就过了。我觉得我长大了，却并没有收获成长的喜悦。</p>
<p>就像今日的冬夜一样，那一天应该也很冷，我披着略显单薄的大衣，提着我的小水杯，一愣一愣地走在操场边的路上。</p>
<p>头上的路灯一盏一盏地接力，我在这所他乡的寄宿制学校里第一次想念家里沙发的柔软。</p>
<p>可能是从小就没有什么人抱过我吧，我最怀念的也只是柔软的沙发，空调的暖风吹到墙面再轻轻扑到脸上的温暖，再看着电视机里日复一日的动画片沉沉睡去的自由。</p>
<p>可能我真的挺不一样，从小学就被家里人送了出来，一个人在相距数百公里的城市上学，只有周末才能见到爸爸妈妈一面。这个决定同时也给我爸妈的生活带来了难以言喻的负担，他们不仅要用小县城的收入撑起我在省城的支出，还要每周往返近千公里的长途跋涉。我不知爸爸的肾病是什么因素造成的，但也应该和这几年的劳累脱不开干系。</p>
<p>初中的三年，高中的三年，也是在这个城市，这所学校，也不争气地没有考到奖学金，也是一样地和考试相伴。</p>
<hr>
<p>正儿八经的情感萌芽也是从初中开始的，大概是初一还是初二吧，那是我第一次真正的喜欢一个人。白天也时不时地想看着她又怕被发现，晚上也想着自己这么拉跨肯定配不上别人，我要好好用功，每天都痛斥自己的没用，然而第二天还是一样的没用。虽说喜欢一个人确实可能可以催人奋进，但对于我来说可能真的只停留在了心理层面。</p>
<p>就这样过了一学期多吧，她依然还是我心里的秘密，除了我没有别人知道。为了不让别人知道我甚至还非常孩子气地虚构了一个朋友，在心里和她说话。没人能想到吧，居然有人初中了还在序构朋友。</p>
<p>后来，我交到了第一个真正的朋友，大概是因为都很喜欢数码科技而认识的吧。总之我的秘密很快在他那里瞒不住了，他就撺掇我搞快行动，但我这个怂货只敢等到放假在网上偷偷表白。</p>
<p>当时我转发了一条微博，是关于喜欢的人的，还配了一句“对方肯定不会看到”的文案。但冥冥之中我觉得她一定会出现在这里。抱着这不切实际的希望，一直蹲守在屏幕前，在回学校的路上又期待又害怕地等待。</p>
<p>果不其然，她很快就如约出现在了我的评论区，好奇地问我是谁。我在屏幕前，在发送和删除键之间反复徘徊，最终还是敲出了那句“是你”。</p>
<p>当然，像大多数的青春而不是青春文学一样，我被拒绝了。毕竟，这个世界上能遇到自己喜欢的人刚好也喜欢自己，那应该是几千年才能修到的福分。</p>
<p>其实，后来也有不少的回忆吧，也有很多其他人的笑脸，但是最终也都只是成了回忆。</p>
<p>但其实我挺庆幸当初的事情只是停留在了这一步，让我们都在彼此的记忆中保持了体面，因为对于我而言，只要事情跨越了那个界限，结果一定会变得无比糟糕，甚至连最初美好的回忆也会慢慢地腐烂掉，最后被丢弃在脑海的角落不愿再拾起。</p>
<p>这也是从我后面几次一塌糊涂的恋爱中获得的为数不多的教训吧。</p>
<p>我的恋爱还真挺不一样的，也可能大家都一样吧。每次有人问我什么择偶标准，我都会说我喜欢的样子就行，他们就会说我高情商钓鱼大师，可是我真的没有任何准则。我喜欢的任何一个人，她们都是那么的不一样，我几乎找不出可以通用的标准出来。</p>
<p>但是，转念一想，好像我们走到一起的原因也是一样，最后走散的原因也是大同小异。我喜欢一个人就会疯狂地献出自己地一切，热情褪去后当我感受不到对方回馈的爱意，我就会悻悻离场。这可能有点残忍，但是我也确实无法对着已经感觉冰凉的东西再次燃起爱意，这甚至有些令我作呕。</p>
<p>这不正常，我知道我处理不好亲密关系中的距离感，我也知道这是一次次地往火坑里跳，因此从今往后我也不愿再拉着别人一起跳这个火坑。如果真的喜欢一个人，那就停留在喜欢的层面吧，让我们都保持着自己的独立和美好，最后再奔向各自想要的未来，在对方的回忆中留下最美的一面，忘记也好，至少不要称为彼此回忆的伤痕就好。我想，这是对于我来说最好的结局了吧。</p>
<p>伤情的话就说到这里吧，我也不是那么伤春悲秋的人，也没有写的那么儿女情长，这本是跨二奔三的大喜之日，也应少说些丧气话。</p>
<hr>
<p>我感觉我中学的生活简单的可怕，无非是恋爱、学习、游戏和篮球。</p>
<p>倒不是说谈过很多恋爱，但是恋爱脑的时间几乎充斥着我那时的生活，也曾非常滑稽地因为对方一个和自己完全无关的动作自己在宿舍大喜大悲，一瓶二锅头下肚沉沉睡去。</p>
<p>游戏和篮球倒是印象比较深刻，这些项目真正的起步也是高中的时候了，像是兄弟篮球的习惯，还有LOL的习惯也都是那时养成的。说来也惭愧，因为打得太菜了，别人都很喜欢女生来看打球，我就非常害怕。虽然我知道她们肯定不是来看我的的，也通常会非常快乐地给被看的那位兄弟搭建表演舞台，像是表演一个被晃倒之类的，但谁心中又没有想过自己想要的那个人目光在自己身上多停留一下呢。就像我前几天总在说的一句话，一个人抱怨没有人喜欢，那只是在抱怨，自己喜欢的人并不喜欢自己罢了。</p>
<p>至于占比最多的学习吧，我倒是没什么印象。人总是趋利避害般地有意去淡忘那些痛苦的回忆，毕竟留着晚自习刷题到愁容满面的回忆也对未来的生活没有任何帮助。</p>
<p>我总是说我的高中生活有多精彩，像是一个人的竞赛生活，周末出去蹦迪网吧通宵，还是高三大家一起闯荡学校法律禁区，出生入死德育处，还有成绩起起落落的悲喜，在宿舍Lemon配二锅头的延时自习（其实我现在也听着lemon），但其实更多的是回忆有很多朋友的快乐吧。</p>
<hr>
<p>高中时朋友的归属感是无可比拟的。我大一刚入学时还因为生活中一些受气的小事而心情非常低落，我那时正在食堂吃饭，我在群里说我昨天好难过，甚至都没有说发生了什么。我进了群语音，听到他们的声音，还有熟悉的口音，也没有多说什么，可是泪腺就像触电一样不受控制，眼泪拼命地向外挤。我狼狈地逃离了食堂，一个人跑回宿舍大哭。</p>
<p>我小时候一直以为自己感情太麻木了，别人潸然泪下的时候我仍不为所动，甚至觉得自己的泪腺可能出了问题，可是年岁越来越大了才发现泪点越来越低。以前看到过一句话，千万不要跟委屈的人说，没事的，我知道你很委屈，哭也没事的。可是那个时候听到他们的声音，真的就像看到了他们站在那里，他们什么都不用说，我就觉得很安心，这里是很安全的地方，即使哭一场也无所谓。</p>
<p>我对思想交流的态度也是受他们的影响而养成的。我对思想碰撞这种东西真的非常着迷，那种彼此都强势而不强硬的争辩的魅力是不言而喻的。高中的时候也很喜欢写随笔，不过那时想的更多的是当下和未来，是想要解决眼下的困惑而作的。可能是对自己的未来感到迷茫，可能是感情上遇到了挫折，也可能是对现在的学习感到不满，但是写下那几页纸也只是为了说服自己继续前进。</p>
<p>我写的长文都在家里的活页本上，也不曾发表，最多也只是和室友交换他的随笔，我觉得我的东西写出来就是给自己看的。有一句很中二但是我依然相信的话，我觉得也适用于我：诗人之所以写诗是因为在这个空间里没有人与他对话，于是他诉诸于笔，诉诸于时间，希望在遥远的未来能有人拾级而上，与他对话。</p>
<p>已经很久没有写过随笔类的长文了，可能也确实没有那么多思考的时间了。回到开头所说的，中学这六年，大学也过了这一年，逐渐也让我感觉到时光的流逝是毫无重量的，也让我慢慢变成了在酒精中感叹时光飞逝的成年人。也并非完全无所想，但所虑的也大都是一些读研和工作的俗事了，关于人生，我也多少有了自己的答案。</p>
<p>今天的写作也算是临时起意了，写得比较乱，可能连散文都算不上了。一开始还会害怕在电脑上写会无划痕可说，但看来是我多虑了。我也希望我的人生除了照片日记外也有一些思考性和回忆性的文字记录，在获得了电脑写作这个技能后，我希望我也能把高中这个习惯继承下去直到老去吧。</p>
<p>最后，我本意是不想发表这篇文章的，但如果真的发出去了，可能是我有向要给某个人看的欲望在作祟吧。</p>
<p><strong>【补充于2023年4月17日：现在觉得没什么不能发的就发出来了】</strong></p>
<p>希望我可以一直做自己。</p>
<p>祝自己生日快乐！</p>
<p>作于 2021.12.2 凌晨</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>生日</tag>
      </tags>
  </entry>
  <entry>
    <title>评《不能继续助长部分中国大学生的好逸恶劳思潮》</title>
    <url>/posts/3608690255/</url>
    <content><![CDATA[<p>原文请见：<a class="link"   href="https://www.cxyinfo.com/cms/show-8717.html" >不能继续助长部分中国大学生的好逸恶劳思潮 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<span id="more"></span>
<hr>
<p>大过年的，又是大晚上的，在 QQ 空间刷到了这篇文章的部分&quot;金句&quot;和同龄人对其的口诛笔伐，但一时间竟不知对这篇文章有什么话可讲。</p>
<p>作为一个学生，我的本能驱使我去辩经，去讲道理，可这种行为就像同牙牙学语的婴儿讲高数一样荒诞不经。此时，我的生活经验又占据了上风——当一个人指着我的鼻头骂我的时候，我不应该去辩解我有什么成就，而是应该揪着他的领口，加倍奉还。</p>
<p>可是，我终究是来迟了。要讲，我实在是没法把道理翻译成作者能听懂的语言；要骂，网友们的语言组织能力已经登峰造极。蓦然回首，似乎已无落脚之处，却终是不吐不快，这篇文章就权当是写给自己消遣娱乐之用吧。毕竟原文的作者和受众，他们早已登上顶峰，一览众山之小，我这小小文章之愚见，自然是难入其法眼。</p>
<p>作为一名罪恶的如文中所述的大学生，我竟完全没有对这篇文章对如我本人的辱骂和歪曲感到愤怒，反倒是内心升起一种荒诞的可悲。</p>
<p>悲从何来？悲其向资本权贵极尽谄媚的嘴脸，悲其行文漏洞百出的逻辑推理，更悲我泱泱华夏在新文化运动百余年后，竟还有如此之多跪着的，睁不开眼的人。</p>
<p>国际共运的先驱们，抗议军阀的青年们，中国共产党的前辈们，不知你们看到这篇文章，还有这些舆论，你们的内心该作何感想呢？百年来轰轰烈烈的社会主义伟大实践，甚至还不能断绝&quot;没有资本家就没有工作&quot;的可笑论调吗？</p>
<p>接下来，请备好足量降压药和氧气瓶，即将迫降至作者指明的思想和道德高地。</p>
<hr>
<p>文章标题开门见山，不能继续助长部分中国大学生的好逸恶劳思潮，可谓字字笔力千钧，一下子就将文章的高度拔到了大气层上空；其下上海房地产研究的身份更是灼灼耀眼，彰显其不仅道德之高，地位也是至尊无上，短短几个蓝字却似有鎏金之效，炫目万分，难以直视，令吾辈青年自当伏首贴耳以感其教诲。<br>
果不其然，开篇便迅速升华，从国内最近的腾讯加班一事谈起，再说及中国近现代的复兴之路，又推及日本战后经济腾飞的奇迹，其时间空间跨度之大，令人叹为观止。</p>
<p>想必作者口中这份 996 和 007，必然是包括了周树人先生废寝忘食以笔医治黎明百姓，也包括了周恩来总理夜以继日理大国万机，但是否包括哪些那些在工厂里连死活都无人过问的包身工呢？谈日本经济的腾飞，又是否考虑过打在志愿军上的每一颗炮弹给日本经济带来了多少提振呢？</p>
<p>正如马克思曾说过的那样，是劳动创造了人类。但这里还剩下了一个关键的问题没有回答，那就是，什么是劳动？<br>
我们确实需要劳动，或者说需要努力和奋斗，为的是实现自己的价值，实现共同的愿景。而资本家和其奴仆竟堂而皇之地直接将工作和劳动，加班和奋斗划了等号。<br>
不妨让我们回顾一下每个罪恶的大学生都学过或者将要学习的马克思主义基本原理，工作是为了换取自身生存必须的资料，也就是说工作只与基本的生存需求有必要关联，它可以是自己喜欢的事业，也可以只是一种谋生手段，故不能和劳动划等号。</p>
<p>为什么各国的工作法令都只是叫促进&quot;就业&quot;法案而不是促进&quot;劳动&quot;法案，就连顶上的资本家都知道就业和劳动完全是两码事，这些油嘴滑舌的资本家喉舌还试图混淆大众视听，将资本家压榨剩余价值的手段正当化甚至奉若圭臬。<br>
社会主义工人运动的&quot;8 小时工作，8 小时休息，8 小时休闲&quot;被你们置于何处？我国的基本制度被你们置于何处？宪法赋予了每一个公民自由生活的权利，我愿意在 8 小时里提升自我还是放松休闲，哪一样又是不利于伟大复兴。你们格局很大，但还不够大，要跳出资本家压榨剩余价值的条条框框，格局才能打开。君可知，内循环经济滔滔流水，提振内需乃活水之源。国家都变着法子凑出假期让人民消费，你们却还想着把无产阶级都拴在工位上一整天，还口口声声地说为了国家，不能说是南辕北辙，也只能说是<strong>同床异梦</strong>。我也像作者一样，站在道德制高点上，给诸君进言几句：你不消费，我不消费，明天循环就崩溃；你不加班，我不加班，世界老大就可攀。</p>
<p>我向来对每一个劳动者都抱有朴素的敬意，对每一种劳动都怀有真诚的尊重，也觉得所有形式的劳动本质上都是平等的，每一个人都对社会有着独一无二的奉献。但作者似乎因为其站在了巨人的肩膀上，而无法看见那些将这个巨人抬到此处的千千万万的人民，用一句轻描淡写的&quot;没有代表国家&quot;就抹杀了万千人民作出的贡献，而将这些劳动的结晶全部都划给了他口中&quot;精锐部队&quot;的&quot;加班&quot;和千歌万颂的资本家老板身上。</p>
<p>千回百转，我想是时候回答劳动的问题了，我的答案很简单，就是实现自己的价值，同时也为创造价值。<br>
如果马化腾和马云之流没有把生产资料掌握在自己手里，还会有夜以继日做出来的 OICQ 和 1688 吗？<br>
如果没有技术和模式创新，这些企业又怎能在国外企业雄踞的格局下站稳脚真？</p>
<p>而将加班和这些案例绑定起来，就好像把工业革命和牛顿的神学研究绑定起来一样可笑。<br>
加班这种恶性压榨，有一个更合适的热词来形容它——内卷。</p>
<p>从作者的格局来看，自己竭力美化加班，延长工人劳动时间，资本家割取更多剩余价值，从而攫取更多利润，这自然也就有自己的一份功劳和奖赏，这种内卷对自己无疑是有百利而无一害的。</p>
<p>但我们还是要格局打开，这种内卷在整个行业内是不可持续的，由于没有技术壁垒的存在，该模式极易复制，最终只会导致利润空间被无限压缩，随着工业化进程的不断发展最终被取缔至无利可图，近代不断的产业升级和淘汰就是最好的例证。</p>
<p>所以问题又更深了一层，如何才能拿到真正的优势，形成所谓技术壁垒呢？</p>
<p>我翻遍了文章，字里行间也没有看见丁点痕迹，我想应该是触及了作者的思维盲区，或者是这个思维盲区还未能摸到作者的脚尖也很有可能。</p>
<hr>
<p>这里我有一个故事要讲——瓦坎达的一堂课上，有三个孩子，老师给他们布置任务，让他们算从 1 加到 2^10000是多少。</p>
<p>第一个孩子上某，他觉得自己一直数，加班加点地数，废寝忘食地数，肯定能够数完加出最后结果，还用以前数学家的事迹来激励自己，告诉自己他们一定是花了加倍的时间才能算出那么牛的结果。</p>
<p>第二个孩子高某，他灵机一动，发现了一个公式，这大大简化了计算量，虽然用了一会儿，但还是得到了结果。</p>
<p>第三个孩子谷某，他想起来前几天他搞出来一个叫量子计算机的东西，直接多线程同时运算，瞬间就出了结果，开开心心地继续玩自己的量子计算机去了。</p>
<p>想必即便是作者也能看出答案了吧，那就是所谓技术与创新和加班八竿子打不着，强制让人加班还不如栓条狗在那，毕竟狗还不会找你要加班费。</p>
<p>伟大的想法不是来源于打工，而是来源于那所谓的休闲八小时。如果刘慈欣在娘子关电厂加班就不会有三体，如果谷歌没有 20% 自由就没有 AOSP，如果爱因斯坦在银行点钞到半夜 4 点也不会有相对论。</p>
<p>还工人阶级自由的八小时，把自我提升和放松的时间还给我们，而不是交给资本家。</p>
<p>毕竟，虽人人生而平等，但人的出身是不平等的，故我们也不在意你的房有多大，车有多快，床有多宽，但请你们至少保留和尊重我们真正为这个社会作出贡献的权利。</p>
<hr>
<p>文已至此，也差不多接近了尾声。</p>
<p>自知很久没有提笔了，仅仅是个人强烈的情感抒发，语言想必也多少磕磕巴巴，有劳大家看到这里了，就让我最后再引用知乎上的一个故事作结吧。</p>
<p>美国南方的种植园上有两种奴隶。</p>
<p>第一种奴隶，他们穿着主人丢弃的衣服，吃着主人吃剩的饭食，住着主人搬走的房子，&quot;监管&quot;着种植园的工作，他们不但不恨主人，还爱戴主人，歌颂主人，帮着主人压迫自己的同胞。</p>
<p>还有一种奴隶，他们衣不蔽体，食不果腹，每天被绳鞭叫醒，枕着冰雪入眠，甚至死活都无人顾问。</p>
<p>当后一种奴隶跳起来反抗的时候，第一个跳脚的不是他们的主人，却是前一种奴隶。</p>
<p>彼时彼刻……</p>
<p>希望我们青年都向上吧，有一份光便发一份光，有一份热便发一份热。若没有炬火，就让我们成为最后的微光。</p>
<p>毕竟在黎明前，总有人需要稍稍照亮黑暗。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试 - JS 基础部分</title>
    <url>/posts/3318771591/</url>
    <content><![CDATA[<p>本篇文章着重于讨论 JavaScript 语言一些原始的特性（颇有”祖宗之法不可变“的意味的一些语言设计），不过分地关注其实现细节和设计初衷。</p>
<p>注意，这里<strong>只讨论 JavaScript 语言本身的特性</strong>，而不关心具体实现上的差别（如 V8 引擎的具体实现或 Node 环境与浏览器环境的 API 差别）。</p>
<span id="more"></span>
<p><strong>其他面试相关文章</strong></p>
<ul>
<li>webpack和其他打包工具（esbuild, bun, vite, turbopack）</li>
<li>现代状态管理</li>
<li>浏览器缓存与网络（http2.0和https）</li>
<li>react-fiber机制</li>
<li>state刷新机制</li>
<li>git原理和ci-cd部署</li>
<li>vue2&amp;3和react16+&amp;18的区别</li>
</ul>
<h2 id="基本数据类型">基本数据类型</h2>
<p>JS 中有8种（ES6）基础数据类型，包括：</p>
<ul>
<li>7种基础数据类型（存储在栈中）：<code>number</code>, <code>string</code>, <code>boolean</code>, <code>undefined</code>, <code>null</code>, <code>BigInt</code>, <code>Symbol</code>
<ul>
<li>其中<code>BigInt</code>和<code>Symbol</code>是ES6引入的新类型
<ul>
<li><code>BigInt</code> 用于存储 <code>number</code> 的双精度浮点数无法存储的大整数</li>
<li><code>Symbol</code> 用于存储独一无二、不会改变的值，每个值都有一个唯一的指针（就算是两个一样的字面量），主要是为了解决可能出现的全局变量冲突的问题</li>
</ul>
</li>
</ul>
</li>
<li>1种引用类型（存储在堆中，实际上是指针）：<code>object</code>
<ul>
<li><code>object</code> 有许多衍生类型，如 <code>Array</code>, <code>Map</code>, <code>Set</code> 等，他们的原型都是 <code>Object</code> -&gt; <code>Function</code></li>
</ul>
</li>
</ul>
<h3 id="null-和-undefined"><code>null</code> 和 <code>undefined</code></h3>
<p><code>null</code> 和 <code>undefined</code> 是特殊的基本类型，它们没有任何拓展方法。</p>
<ul>
<li><code>null</code> 相当于一个卷纸盒里没有卷纸的情况，至少这里还有一个卷纸盒（声明了一个变量，且赋予了null初值）</li>
<li><code>undefined</code> 相当于连卷纸盒都没有的情况（声明了变量，但并没有初始化）</li>
</ul>
<p>除此之外，还有一种情况是 <strong>undeclared</strong>，它并不是一种数据类型，它代表着<strong>已经存在于作用域种但没有初始化的变量</strong>，常见于局部死区。</p>
<h2 id="原型与原型链继承">原型与原型链继承</h2>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305160032776.png"
                      alt=""
                ></p>
<p>JavaScript 是基于<strong>原型</strong>的而不是基于类的，面向对象<strong>用原型链实现继承而不是类的派生</strong>。</p>
<h3 id="基本概念">基本概念</h3>
<p>JavaScript 对象是动态的属性“包”（指其自己的属性），对象又分为<strong>普通对象</strong>和<strong>函数对象</strong>两种。</p>
<ul>
<li><strong>每个对象</strong>都有 <code>__proto__</code> 属性，它指向这个对象的<strong>原型对象（prototype）</strong></li>
<li><strong>只有函数对象有 <code>prototype</code>（原型对象）属性</strong>，它有<strong>默认</strong>拥有两个属性：<code>constructor</code> 和 <code>__proto__</code>（默认表示在 <code>log</code> 时不会显示出来）
<ul>
<li><code>constructor</code> 属性用于记录实例是由哪个<strong>构造函数</strong>创建，函数对象的 <code>prototype</code> 的 <code>constructor</code> 默认是它自己，普通对象则是它的构造函数。</li>
<li><code>__proto__</code> 属性指向对象的父类（对象）的原型对象（prototype），直到 <code>Object</code> 的 <code>prototype</code> 属性为 <code>null</code>，原型链结束.</li>
<li><code>construtor</code>代表自身（子类自己），<code>__proto__</code>代表父类（原型链）</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230531221550.png"
                      alt=""
                ></p>
<ul>
<li><strong>任何函数都可以作为构造函数</strong>，但是并不能将任意函数叫做构造函数，<strong>只有当一个函数通过 <code>new</code> 关键字调用的时候才可以成为构造函数</strong>。</li>
<li>当试图访问一个对象的属性时，它<strong>不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索</strong>，直到找到一个名字匹配的属性或到达原型链的末尾。</li>
<li>需要注意的是，<strong>当继承的函数被调用时，this 指向的是当前继承的对象，而不是继承的函数所在的原型对象。</strong></li>
<li>要检查对象是否具有自己定义的属性（即这个属性在 <code>this</code> 里而不是 <code>__proto__</code> 中），而不是其原型链上的某个属性，则必须使用所有对象从 <code>Object.prototype</code> 继承的 <code>hasOwnProperty</code> 方法。</li>
</ul>
<blockquote>
<p>在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要。另外，试图访问不存在的属性时会遍历整个原型链。</p>
</blockquote>
<h4 id="Fun-Facts">Fun Facts</h4>
<p>以下事实均可以在浏览器环境或Node环境中验证。</p>
<ul>
<li>由于 JS 会递归地查询原型链上的属性，因此在对象中可以直接访问直接父类的 <code>constructor</code> 属性，其他顶层的未被遮蔽的父类属性也可以被直接访问，但修改会直接赋值到 <code>this</code> 中，并掩蔽 <code>prototype</code> 中的属性</li>
<li>如果你使用普通对象作为 <code>prototype</code> 赋值给 <code>__proto__</code> 时，它寻找 <code>constructor</code> 时会调用它的 <code>__proto__.constructor</code>，实际上就是 <code>Object</code>（因为普通对象的<code>__proto__</code>属性就是<code>Object.prototype</code>）。</li>
<li>修改构造函数的 <code>prototype</code> 和修改实例的 <code>__proto__</code> 在行为上是等价的（因为<strong>同一构造函数的所有实例的<code>__proto__</code>都指向同一个对象</strong>，即构造函数的 <code>prototype</code>）</li>
<li>由于原型对象中<code>constructor</code>代表自身，<code>__proto__</code>代表父类，因此任何<strong>构造函数</strong>（或者说任何函数）的<code>constructor</code>是<code>Function()</code>，<code>__proto__</code>则指向<code>Object.prototype</code>（MHY面试题）</li>
</ul>
<h3 id="JavaScript-如何实现继承">JavaScript 如何实现继承</h3>
<p>明白了原型（<code>__proto__</code> 和 <code>prototype</code>）的概念和原型链的原理后，我们应该如何编写代码来实现继承呢？</p>
<h4 id="直接继承">直接继承</h4>
<ul>
<li>使用 <code>Object.create(obj)</code> 创建对象，允许你指定一个将<strong>被用作新对象原型的对象</strong>，即将 <code>obj</code> 赋值给 <code>__proto__</code></li>
<li>使用<strong>构造函数</strong>，通过 <code>new</code> 关键字指定对象的 <code>__proto__</code> 属性为对应函数的 <code>prototype</code> 属性
<ul>
<li><code>new</code> 首先会创建一个新的空对象</li>
<li>它将新生成的对象的 <code>__proto__</code> 属性赋值为构造函数的 <code>prototype</code> 属性，使得通过构造函数创建的所有对象可以共享相同的原型</li>
<li>使用 <code>constructor.apply(obj, args)</code> 运行构造函数，并使其绑定到创建的对象中</li>
</ul>
</li>
<li>直接修改 <code>__proto__</code> 属性或者使用 <code>Object.setPrototypeOf(obj, prototype)</code></li>
<li>也可以直接给 <code>__proto__</code> 或者 <code>prototype</code> 属性赋值来增加原型上的属性</li>
</ul>
<blockquote>
<p>注意：原生原型<strong>不应该</strong>被扩展，除非它是为了与新的 JavaScript 特性兼容。</p>
</blockquote>
<h4 id="继承链">继承链</h4>
<p>上面这些方法都只能执行<strong>一层的继承</strong>，如果我想像其他OOP语言一样拥有很长的继承链要怎么办呢？</p>
<blockquote>
<p>最好的办法是使用ES6+提供的 <code>class</code> 语法糖，这里仅作为原型链的训练使用。</p>
</blockquote>
<p>比如说我们有三个类，继承关系是：<code>PrimaryStudent</code>-&gt;<code>Student</code>-&gt;<code>Person</code>。</p>
<p>首先想到的方法如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, gender</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">gender</span> = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age, gender, score</span>) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age, gender);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">score</span> = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">PrimaryStudent</span>(<span class="params">grade, ...props</span>) &#123;</span><br><span class="line">  <span class="title class_">Student</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, props);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">grade</span> = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> <span class="title class_">PrimaryStudent</span>(<span class="number">2</span>, <span class="string">&#x27;小明&#x27;</span>, <span class="number">9</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">92</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(xiaoming);</span><br></pre></td></tr></table></figure></div>
<p>但我们需要注意一点：<strong>调用了<code>Student</code>构造函数不等于继承了<code>Student</code></strong>，而只是在 <code>PrimaryStudent</code> 中运行构造函数添加了对应的属性。</p>
<p>现在创建的对象的原型链是：<code>this</code> -&gt; <code>PrimaryStudent.prototype</code> -&gt; <code>Object.prototype</code> -&gt; <code>null</code>。</p>
<p>而我们想要的原型链是：<code>this</code> -&gt; <code>PrimaryStudent.prototype</code> -&gt; <code>Student.prototype</code> -&gt; <code>Person.prototype</code> -&gt; <code>Object.prototype</code> -&gt; <code>null</code>。</p>
<p>是的，想必你也想到了，我们可以直接修改 <code>prototype</code> 属性来得到正确的原型链，只是我们必须<strong>借助中间对象来实现正确的原型链</strong>。</p>
<p>我们将这个过程包装在一个函数中，函数中定义了一个<strong>空壳函数F</strong>来作为原型链的中间一环（F的<code>constructor</code>是子类的<strong>构造函数</strong>，而<code>__proto__</code>指向父类的<strong>原型</strong>）：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inherits</span>(<span class="params">Child, Parent</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">  <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这样就可以用下面的代码还原正确的原型链：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">inherits</span>(<span class="title class_">Student</span>, <span class="title class_">Person</span>);</span><br><span class="line"><span class="title function_">inherits</span>(<span class="title class_">PrimaryStudent</span>, <span class="title class_">Student</span>);</span><br><span class="line"><span class="comment">// PrimaryStudent -&gt; Student -&gt; Person -&gt; Object</span></span><br></pre></td></tr></table></figure></div>
<h2 id="this-指针">this 指针</h2>
<p><code>this</code> 是 JS 的关键字之一，是 <code>object</code> 类型自动生成的一个内部对象，<strong>只能在内部使用</strong>，虽然大体上指的是本身及其所处环境，但<strong>根据调用的位置不同实际指向的地方是不同的</strong>。</p>
<p>众所周知 <code>function</code> 也是一个特殊的对象，而 <code>this</code> 其实也主要用于函数内部。</p>
<h3 id="绑定规则">绑定规则</h3>
<p>在看下面这些例子的时候很难不想到上面原型链中的<code>this</code>指向哪里，等看完了自然就有了答案。</p>
<h4 id="默认绑定">默认绑定</h4>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">20</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">&#125;</span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 10</span></span><br><span class="line"><span class="title function_">doSomething</span>() <span class="comment">// 20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure></div>
<p>若函数<strong>调用的位置</strong>直接位于顶级作用域，就像“光杆司令”，就只能执行<strong>默认绑定，绑定到全局环境中</strong>（在浏览器中是<code>window</code>，Node环境中则是<code>global</code>，严格模式中则是<code>undefined</code>）</p>
<h4 id="隐式绑定">隐式绑定</h4>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">doSomething</span>: doSomething</span><br><span class="line">&#125;</span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="title function_">doSomething</span>() <span class="comment">// 10</span></span><br><span class="line">obj.<span class="title function_">doSomething</span>() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></div>
<p>函数调用的位置<strong>在对象内部</strong>时，函数就有了<strong>上下文对象</strong>，此时 <code>this</code> 就指向了上下文对象。需要注意的是，这里的上下文指的是<strong>直接上下文</strong>。</p>
<p>我们回忆使用 <code>new</code> 创建实例的原理，实际上也是 <code>new</code> 内部新建了对象，并把这个对象作为上下文对象调用构造函数，也就是说构造函数中的 <code>this</code> 指向我们创建的对象。</p>
<p>需要注意的，<strong><code>this</code> 指向的上下文和词法作用域产生的闭包是两个不同的概念</strong>。</p>
<h4 id="显式绑定">显式绑定</h4>
<p>显式绑定可以通过一些方法强制给函数设置 <code>this</code> 指向的对象，这些方法定义在 <code>Function</code> 这个构造函数的<strong>原型</strong>中。</p>
<ul>
<li><code>Function.call(this, thisArg, ...args)</code>
<ul>
<li>定义在原型中的函数的 <code>this</code> 参数会在实例调用该方法时自动填入，和 Python 中的 <code>self</code> 很像</li>
<li><code>thisArg</code> 用于指定函数的 <code>this</code> 指针</li>
<li><code>...args</code> 为变长参数列表</li>
</ul>
</li>
<li><code>Function.applay(this, thisArg, argArray)</code>
<ul>
<li>与 <code>call</code> 的区别是参数列表是数组形式</li>
</ul>
</li>
<li><code>Function.bind(this, thisArg, ...args)</code>
<ul>
<li>与 <code>call</code> 的区别是它会<strong>返回一个函数</strong>以供调用，而不是直接执行</li>
</ul>
</li>
</ul>
<h4 id="箭头函数（Lambda-表达式）">箭头函数（Lambda 表达式）</h4>
<p>ES6中引入的 <code>=&gt;</code> 函数不受上述规则影响，而是<strong>完全由外部环境决定 <code>this</code> 的指向</strong>，且<strong>不能被手动修改</strong>（即对箭头函数使用<code>call</code>、<code>bind</code> 和 <code>apply</code> 是<strong>无效</strong>的）。但是它的<strong>外部环境（父作用域）仍受制于上述的 <code>this</code> 规则</strong>。</p>
<p>简单地说：<strong>箭头函数没有自己的 <code>this</code>，内部的 <code>this</code> 完全等价于外层的 <code>this</code>，通过查找作用域链来确定 <code>this</code> 的值</strong>。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">say1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">say2</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">say3</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ext = obj.<span class="property">say1</span>;</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line">obj.<span class="title function_">say1</span>(); <span class="comment">// 1</span></span><br><span class="line">obj.<span class="title function_">say2</span>(); <span class="comment">// undefined, this=&#123;&#125;</span></span><br><span class="line">obj.<span class="title function_">say3</span>()(); <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">ext</span>(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></div>
<h2 id="闭包与作用域">闭包与作用域</h2>
<p><strong>词法作用域</strong>（Lexical Context）就是定义在<strong>词法分析阶段</strong>的作用域。</p>
<p>这个叙述可能不是很清晰，我们换一个说法：词法作用域又称静态作用域，与之相对的是动态作用域。静态作用域在程序编译（词法分析）阶段，变量的作用域就已经按照代码层级确定了；而动态作用域会在代码执行阶段动态地从调用栈的作用域中搜索变量。</p>
<p>举个例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    <span class="title function_">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是 1</span></span><br></pre></td></tr></table></figure></div>
<p>上述例子很清晰地说明了 <strong>JS 是静态作用域（词法作用域）语言</strong>，即函数的作用域在函数定义的时候就决定了，查找时根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。（否则的话会按照调用栈查 <code>bar</code> 中的变量，打印 2）。</p>
<p>词法作用域给 JS 带来了以下规则：</p>
<ul>
<li>函数可以访问当前函数作用域外部的变量</li>
<li>整个代码结构中只有函数可以限定作用域（也就是说在ES6以前的JS中一个文件内只存在**全局作用域（Global Scope）和函数作用域（Function Scope）**两种作用域，其中函数作用域可以嵌套、重复地存在）</li>
<li>作用规则首先使用<strong>提升规则</strong>分析（即<strong>变量提升</strong>现象）</li>
<li>如果当前作用域中有了名字了，就不考虑外面的名字</li>
</ul>
<p>知道了词法作用域的基本概念后，我们来看看词法作用域在 JS 中具体体现在了哪些地方吧。</p>
<h3 id="闭包（closure）">闭包（closure）</h3>
<blockquote>
<p>在计算机科学中，<strong>闭包（英语：Closure）</strong>，又称<strong>词法闭包（Lexical Closure）或函数闭包（function closures）</strong>，是在支持头等函数的编程语言中实现词法绑定的一种技术。</p>
<p>闭包在实现上是一个结构体，它存储了一个函数（通常是其入口地址）和一个关联的环境（相当于一个符号查找表）。环境里是若干对符号和值的对应关系，它既要包括约束变量（该函数内部绑定的符号），也要包括自由变量（在函数外部定义但在函数内被引用），有些函数也可能没有自由变量。闭包跟函数最大的不同在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样<strong>即便脱离了捕捉时的上下文，它也能照常运行。</strong></p>
<p>最开始闭包被广泛地用于函数式编程语言如 LISP，后来很多命令式编程语言也逐渐开始支持闭包（如<s>臭名昭著的</s> Javascript）</p>
</blockquote>
<p>闭包对于初学者难以理解的地方其实仅仅在于这个著名的”翻译谬误“，将 closure 这个还算形象的名称翻译成了 ”闭包&quot; 这个相对晦涩的汉语名称。闭包实际上就是用来指代某些其开放绑定（自由变量）已经由其语法环境完成闭合（或者绑定）的lambda表达式，从而形成了<strong>闭合</strong>的表达式，就像关上了访问其中元素的大门一样。</p>
<p>简而言之，闭包让开发者<strong>可以从内部函数访问外部函数的作用域</strong>。在 JavaScript 中由于<strong>词法作用域</strong>的存在，闭包会随着函数的创建而被同时创建。</p>
<p>举个例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Mozilla&quot;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">displayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> displayName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myFunc = <span class="title function_">makeFunc</span>();</span><br><span class="line"><span class="title function_">myFunc</span>();	<span class="comment">// Mozilla</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h4 id="闭包的实际作用">闭包的实际作用</h4>
<p>闭包允许将函数与其所操作的某些数据（环境）关联起来，这显然类似于<strong>面向对象编程</strong>。</p>
<p>在面向对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。因此，通常你使用只有一个方法的对象的地方，都可以使用闭包。</p>
<p>更抽象的说，<strong>闭包象征着一种封装思维</strong>，将某些属性和方法打包封装起来，可以隐藏细节和保护数据，这样来说如自定义 Hook 等都属于广义的闭包。</p>
<p>以下是一些闭包的用处：</p>
<ul>
<li>模拟 OOP 中的私有成员和方法</li>
<li>隐藏变量，避免全局作用域污染</li>
</ul>
<p>以下是实际应用场景：</p>
<ul>
<li>模块化开发（以前没有模块作用域的时候用闭包封装模块的命名空间）</li>
<li><strong>高阶函数</strong>、科里化、节流防抖等需要内部判断状态的函数</li>
</ul>
<h4 id="性能开销">性能开销</h4>
<blockquote>
<p>总结：如果没有绑定作用域的特殊需求，请不要使用闭包！</p>
</blockquote>
<p>如果不是某些特定任务需要使用闭包，在其他函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。</p>
<p>例如，在创建新的对象或者类时，<strong>方法通常应该关联于对象的原型，而不是定义到对象的构造函数中</strong>。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是说，对于每个对象的创建，方法都会被重新赋值）。</p>
<p>需要注意的是，使用原型定义也会引入额外的原型链查找开销，因此这其实是一种 trade-off，只是一般单层查找开销略低于反复构造的开销。</p>
<p>除此之外，闭包的滥用还会导致<strong>变量不会随着函数退栈被垃圾回收机制回收</strong>，可能导致<strong>内存泄漏</strong>问题。</p>
<p>比如下面的代码：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用闭包定义公有方法：每次构造新对象都会重新赋值一次方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyObjectClosure</span>(<span class="params">name, message</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name.<span class="title function_">toString</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">message</span> = message.<span class="title function_">toString</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getMessage</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用原型继承定义公有方法：所有对象共用一个地址（但会带来原型链查找的开销）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyObject</span>(<span class="params">name, message</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name.<span class="title function_">toString</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">message</span> = message.<span class="title function_">toString</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">MyObject</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">MyObject</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getMessage</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h3 id="变量提升和局部死区">变量提升和局部死区</h3>
<p>在 JS 的<strong>执行过程</strong>（具体地说是函数运行栈帧的创建过程，这就涉及到 V8 引擎的实现了）中，所有<strong>标识符</strong>（包括函数和变量）的声明部分会被添加到名为<code>Lexical Environment</code> 的结构体（这实际上就是词法作用域的实际载体，也是作用域链的结点）中，这看起来就像是<strong>提升到当前作用域的最前面</strong>，所以这些变量和函数能在它们真正被声明之前使用。</p>
<p>而根据变量类型的不同，具体的提升行为也不同，但大体上都是<strong>只提升声明部分</strong>。</p>
<ul>
<li>函数提升：因为函数本身就是一个指针，当JavaScript引擎遇到函数时，它会从<strong>词法环境</strong>中找到这个函数并执行它。</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">sayHi</span>() <span class="comment">// Hi there!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi there!&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>var</code> 变量提升：JavaScript在编译阶段会找到 <code>var</code> 关键字声明的变量会添加到词法环境中，并初始化一个值 <code>undefined</code> （而不是用户定义的赋值初始化行为），在之后执行代码到赋值语句时，会把值赋值到这个变量</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name    <span class="comment">// 声明变量</span></span><br><span class="line">name = <span class="string">&#x27;John Doe&#x27;</span> <span class="comment">// 赋值操作</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>let</code> &amp; <code>const</code> 变量提升：只有使用 <code>var</code> 关键字声明的变量才会被初始化 <code>undefined</code> 值，而 <code>let</code> 和 <code>const</code> 声明的变量则不会被初始化值，因此在 JavaScript 引擎在声明变量之前，无法访问该变量。这就是我们所说的 <strong>Temporal Dead Zone（局部死区）</strong>，即变量创建和初始化之间的时间跨度，它们无法访问。</li>
<li><code>class</code> 提升：ES6中的新关键字，同样会被提升，但在实际声明前是不能调用的（这点与构造函数不同），也存在局部死区问题。</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> peter = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Peter&#x27;</span>, <span class="number">25</span>) <span class="comment">// ReferenceError: Person is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> john = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;John&#x27;</span>, <span class="number">25</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(john) <span class="comment">// Person &#123; name: &#x27;John&#x27;, age: 25 &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h3 id="作用域链">作用域链</h3>
<p>根据规则2：只有函数才能制造作用域结构，那么只要是代码，至少有一个作用域，即全局作用域。</p>
<p>凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域，那么将这样的所有作用域列出来，可以有一个结构：函数内指向函数外的链式结构。</p>
<p>举个（相同的）例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="title function_">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="title function_">bar</span>();</span><br></pre></td></tr></table></figure></div>
<p>这段代码的作用域链如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305160032129.png"
                      alt=""
                ></p>
<p>在搜索变量时，只会按照作用域链向上搜索，而词法作用域（静态作用域）又决定了其只与在代码中定义的地方有关，所以无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。</p>
]]></content>
      <categories>
        <category>面试经验</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>2023春招</tag>
        <tag>面试</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试 - 网络基础部分</title>
    <url>/posts/3837669316/</url>
    <content><![CDATA[<h2 id="常见考点">常见考点</h2>
<h3 id="HTTP-状态码">HTTP 状态码</h3>
<ul>
<li>信息响应 (100–199)
<ul>
<li><code>100</code> - Continue：多用于 <code>POST</code> 请求先发送 HEADER 部分，服务器会响应 <code>100 - Continue</code> 让客户端继续发送 BODY 部分</li>
</ul>
</li>
<li>成功响应 (200–299)
<ul>
<li><code>200</code> - OK</li>
</ul>
</li>
<li>重定向消息 (300–399)</li>
<li>客户端错误响应 (400–499)
<ul>
<li><code>400 </code> - Bad Request：由于被认为是客户端错误（例如，错误的请求语法、无效的请求消息帧或欺骗性的请求路由），服务器无法或不会处理请求。</li>
<li><code>403</code> - Forbidden：客户端没有访问内容的权限；也就是说，它是未经授权的，因此服务器拒绝提供请求的资源。与 <code>401 Unauthorized</code> 不同，服务器知道客户端的身份。</li>
<li><code>404</code> - Not Found：服务器找不到请求的资源。在浏览器中，这意味着无法识别 URL。在 API 中，这也可能意味着端点有效，但资源本身不存在。服务器也可以发送此响应，而不是 <code>403 Forbidden</code>，以向未经授权的客户端隐藏资源的存在。这个响应代码可能是最广为人知的，因为它经常出现在网络上。</li>
</ul>
</li>
<li>服务端错误响应 (500–599)</li>
</ul>
<h3 id="TCP-三次握手与四次挥手">TCP 三次握手与四次挥手</h3>
<h4 id="三次握手">三次握手</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305180035130.png"
                      alt=""
                ></p>
<p>前提条件：TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时<strong>服务器就进入了LISTEN（监听）状态</strong>；</p>
<ol>
<li><strong>TCP客户进程</strong>也是先创建传输控制块TCB，然后<strong>向服务器发出连接请求报文</strong>，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</li>
<li><strong>TCP服务器</strong>收到请求报文后，如果同意连接，则<strong>发出确认报文</strong>。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li>
<li><strong>TCP客户进程</strong>收到确认后，还要<strong>向服务器给出确认</strong>。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，<strong>客户端进入ESTABLISHED（已建立连接）状态</strong>。TCP规定，<strong>ACK报文段可以携带数据，但是如果不携带数据则不消耗序号</strong>。</li>
<li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li>
</ol>
<p><strong>Q：为什么是三次握手？两次不行吗？</strong></p>
<blockquote>
<p>两次握手会省略最后一次客户端重复发送的确认请求，表示服务端<strong>收到一个报文就建立连接状态</strong>，这可能导致一些问题：</p>
<ul>
<li>假如客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，客户端会自动重传该报文，这样服务器就会收到两份报文且建立两份连接，导致不必要的错误和资源的浪费。</li>
<li>如果发生了服务端回传的ACK报文发生了丢包，会导致服务端建立连接但客户端未建立连接，服务端发送的报文将被丢弃</li>
</ul>
</blockquote>
<h4 id="四次挥手">四次挥手</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305180035322.png"
                      alt=""
                ></p>
<ol>
<li><strong>客户端进程发出连接释放报文</strong>，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li>
<li><strong>服务器收到连接释放报文，发出确认报文</strong>，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，<strong>这时候处于半关闭状态，即客户端已经没有数据要发送了</strong>，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li>
<li><strong>客户端收到服务器的确认请求</strong>后，此时，<strong>客户端就进入FIN-WAIT-2（终止等待2）状态</strong>，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li>
<li><strong>服务器</strong>将最后的数据发送完毕后，就<strong>向客户端发送连接释放报文</strong>，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，<strong>服务器就进入了LAST-ACK（最后确认）状态</strong>，等待客户端的确认。</li>
<li><strong>客户端收到服务器的连接释放报文后，必须发出确认</strong>，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。<strong>注意此时TCP连接还没有释放</strong>，必须经过 2xMSL （最长报文段寿命）的时间后，<strong>当客户端撤销相应的TCB后，才进入CLOSED状态</strong>。</li>
<li><strong>服务器只要收到了客户端发出的确认，立即进入CLOSED状态</strong>。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li>
</ol>
<p><strong>Q：为什么握手只需要三次，而挥手需要四次？</strong></p>
<blockquote>
<p>因为必须要确定双方都没有报文要发送时才能关闭连接，因此必须要 (FIN+ACK)x2=4 份报文。</p>
</blockquote>
<p><strong>Q：为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</strong></p>
<blockquote>
<p>如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。</p>
</blockquote>
<h3 id="浏览器中的-Session-和-Cookie">浏览器中的 Session 和 Cookie</h3>
<p>由于 HTTP 是无状态协议，即不维护连接的历史信息，你就算连续发送两条报文它也不会连着处理，和分开发也没有任何区别，这在处理一般网页请求时自然没有什么问题，但在涉及一些连续操作如账号管理、购物车等场景时就显得有些力不从心。这时，就需要引入 <code>cookie</code> 来记录状态信息。</p>
<p><strong>cookie</strong> 是客户端保存用户信息的一种机制，将服务器发送到浏览器的数据保存在本地（放在 <code>document.cookie</code> 中），下次向同一服务器再发起请求时被携带发送（报文首部里的 <code>With-Credential</code> 字段）。主要用于以下场景：</p>
<ul>
<li>会话状态管理(如用户登录状态、购物车、游戏分数或其它需要记录的信息)</li>
<li>个性化设置(如用户自定义设置、主题等)</li>
<li>浏览器行为跟踪(如跟踪分析用户行为等)</li>
</ul>
<h4 id="引入-Session">引入 Session</h4>
<p>由于 cookie 都是明文存储在 <code>document.cookie</code> 属性中的（如下图所示），就不能避免被篡改带来的安全风险，这时我们就需要引入 <strong>Session</strong>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305180035133.png"
                      alt=""
                ></p>
<p><strong>Session</strong> 代表服务器和客户端一次会话的过程，是一种持久网络协议，在用户(或用户代理)端和服务器端之间创建关联，从而起到交换数据包的作用机制。对照Cookie，Session是一种在服务器端保存数据的机制，用来跟踪用户状态的数据结构，可以保存在文件、数据库或者集群中。</p>
<p>也就是说，我们不仅要在客户端存储连接信息，在服务端也要存一份（注意这和 HTTP 的无状态并没有什么关系）。</p>
<p>只要是来自同一用户的请求都在同一个 Session 中处理，这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。</p>
<p>当客户端关闭会话，或者 Session 超时失效时会话结束。</p>
<p>除此之外，Session还有更自由的存储结构，不必受 cookie 的格式、大小限制。</p>
<blockquote>
<p>目前大多数的应用都是用Cookie结合SessionId实现跟踪的。第一次创建Session时，服务端会通过在HTTP协议中返回给客户端，在Cookie中记录SessionID，后续请求时传递SessionID给服务，以便后续每次请求时都可分辨你是谁。</p>
<p>为了防止sessionId被修改，还需要附上一些额外的加密信息如时间戳加密。</p>
</blockquote>
<h4 id="禁用-Cookie-的解决方案">禁用 Cookie 的解决方案</h4>
<ul>
<li>拼接SessionId参数：在GET或POST请求中拼接SessionID，GET请求通常通过URL后面拼接参数来实现，POST请求可以放在Body中。无论哪种形式都需要与服务器获取保持一致。</li>
<li>基于Token (令牌)：在APP应用中经常会用到Token来与服务器进行交互。Token本质上就是一个唯一的字符串，登录成功后由服务器返回，标识客户的临时授权，客户端对其进行存储，在后续请求时，通常会将其放在HTTP的Header中传递给服务器，用于服务器验证请求用户的身份</li>
</ul>
<p>这里对<strong>token</strong>稍微展开说说：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/05/20230522223344.webp"
                      alt="img" style="zoom:67%;" 
                >
<ul>
<li>token本质上就是一个独特的字符串，需要服务端兼容</li>
<li><strong>每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里</strong></li>
<li><strong>基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库</strong></li>
</ul>
<h4 id="同源和跨域">同源和跨域</h4>
<p>CORS 问题真的是折磨前后端萌新的法宝，我当年就被这玩意儿折磨的不轻。</p>
<p>所谓的“同源”指的是“三个相同”：<strong>协议相同、域名相同、端口相同</strong>。只有这三个完全相同，才算是同源。</p>
<p>同源策略的目的：是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>
<h2 id="HTTPS-协议">HTTPS 协议</h2>
<p>在传统 HTTP 协议中，所有数据都是明文传输的，包括敏感信息如用户密码等。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305180036194.png"
                      alt=""
                ></p>
<p>有人或许可以说，我可以在前端进行 Hash+Salt 处理不就可以的吗。但是 Hash 算法如 MD5 是取模运算，是不可逆的，因此在服务端如果不能提前知道取模因子就只能直接拿这个加盐后的值作为密码，这就失去了加密的意义（黑客直接拿到这个明文的加密值也可以登录）。</p>
<p>又有人说了，那我提前把这个取模因子当作“密钥”发过去不就好了？但这个密钥也是明文传输的，因此还是逃不开黑客的魔爪。但是，能想到这一层的话，恭喜你已经摸到了 HTTPS 提出者的思路了。</p>
<h3 id="加密算法">加密算法</h3>
<p>HTTPS 采用了<strong>混合加密算法</strong>，具体来说就是<strong>对称式加密和非对称式加密混合使用</strong>。</p>
<p>为什么要这么干呢？一句话来说就是为了<strong>兼顾速度和安全性</strong>。</p>
<ul>
<li>对称加密：加密和解密都是使用同一个密钥，常见的对称加密算法有 DES、3DES 和 AES
<ul>
<li>优点：算法公开、<strong>计算量小、加密速度快、加密效率高</strong>，适合加密比较大的数据</li>
<li>缺点：
<ul>
<li>无法避免密钥的传输，而密钥在传输过程中无法保证不被截获，因此对称加密的安全性得不到保证</li>
<li>在公网交流所有人都需要在同一网络空间使用唯一密钥，这会引起密钥数量的急剧增长</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305180036491.png"
                      alt=""
                ></p>
<ul>
<li>非对称加密：加密和解密需要使用两个不同的密钥——公钥（public key）和私钥（private key）
<ul>
<li>优点：算法公开，加密和解密使用不同的钥匙，私钥不需要通过网络进行传输，安全性很高。</li>
<li>缺点：计算量比较大，加密和解密速度相比对称加密慢很多。</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305180036377.png"
                      alt=""
                ></p>
<h3 id="实现原理">实现原理</h3>
<p>HTTPS 在 HTTP 的基础上增加了 <strong>SSL (安全套接层) /TLS (安全传输层协议)</strong>，在建立连接前需要<strong>额外的握手协议</strong>，在握手过程中将确立双方加密传输数据的密码信息。</p>
<p>值得注意的是，之所以是<strong>混合加密</strong>，是因为 HTTPS <strong>在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段</strong>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305180036555.png"
                      alt="HTTP和HTTPS的关系.png" style="zoom: 50%;" 
                >
<h4 id="SSL-和-TLS">SSL 和 TLS</h4>
<p>SSL/TLS是一个安全通信框架，上面可以承载HTTP协议或者SMTP/POP3协议等。</p>
<blockquote>
<p>SSL(Secure Socket Layer)安全套接层，是1994年由Netscape公司设计的一套协议，并与1995年发布了3.0版本。</p>
<p>TLS(Transport Layer Security)传输层安全是IETF在SSL3.0基础上设计的协议，<strong>实际上相当于SSL的后续版本</strong>。</p>
</blockquote>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305180036418.jpg"
                      alt="img" style="zoom:67%;" 
                >
<h5 id="TLS-协议">TLS 协议</h5>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305180036310.jpg"
                      alt=""
                ></p>
<p>TLS主要分为两层：</p>
<ul>
<li>上层是<strong>TLS握手协议</strong>，主要分为握手协议，密码规格变更协议和应用数据协议4个部分
<ul>
<li>握手协议：在客户端和服务器端<strong>商定密码算法和共享密钥</strong>，包括<strong>证书认证</strong>，是4个协议中最最复杂的部分</li>
<li>密码规格变更协议：向通信对象传达变更密码方式的信号</li>
<li>警告协议：发生错误的时候将错误传达给对方</li>
<li>应用数据协议：将TLS承载的<strong>应用数据</strong>传达给通信对象的协议</li>
</ul>
</li>
<li>下层是TLS记录协议，主要负责使用<strong>对称</strong>密码对消息进行加密</li>
</ul>
<p>这里对 TLS 的详细实现细节不再叙述。</p>
<h5 id="握手协议">握手协议</h5>
<p>我们把证书原本的内容生成一份“签名”，比对证书内容和签名是否一致就能判别是否被篡改。这就是数字证书的“防伪技术”，这里的“签名”就叫<strong>数字签名</strong>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305180036254.jpg"
                      alt="img" style="zoom: 25%;" 
                >
<h5 id="SSL-证书">SSL 证书</h5>
<p>SSL 证书，或者说 SSL/TLS 证书是 HTTPS 握手的关键所在。</p>
<ul>
<li>SSL 证书有多种类型，都可以从证书颁发机构处获取</li>
<li>SSL 证书<strong>一定会过期</strong>，官方规定证书<strong>有效期不得超过 27 个月</strong></li>
</ul>
<h4 id="握手步骤">握手步骤</h4>
<ol>
<li>客户端请求 HTTPS 端口 443（不是 HTTP 的 80 端口），将自己支持的一套加密规则发送给网站</li>
<li>服务器从中选出一组加密算法与HASH算法，并<strong>将自己的身份信息以证书的形式发回给浏览器</strong>。证书里面包含了<strong>网站地址，加密公钥，以及证书的颁发机构等信息</strong></li>
<li>客户端检查服务器的<strong>数字 CA（Certification Authority）证书</strong>
<ul>
<li>验证证书的合法性（颁发机构、地址是否一致、是否过期等）</li>
<li>如果证书<strong>不是可信机构颁布</strong>，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信</li>
<li>如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码（这是后面对称式加密的密钥），并<strong>用证书中提供的公钥加密</strong></li>
<li>使用约定好的HASH算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站</li>
</ul>
</li>
<li>浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，<strong>之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密</strong>。</li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305180036230.jpeg"
                      alt="img" style="zoom:80%;" 
                >
<h3 id="HTTPS-的漏洞">HTTPS 的漏洞</h3>
<p>HTTPS 真的绝对安全吗？显然不是的，毕竟天下没有不透风的墙。举一个简单的例子，如果没有公认的证书颁发机构，我们甚至根本无法确认证书是不是来自我们想要访问的网站！</p>
<p>一些常见的 HTTPS 漏洞如下：</p>
<ul>
<li>SSL 劫持：一种典型的中间人攻击，攻击者需要伪造一个SSL证书发给浏览器，但这个时候由于伪造的SSL证书不受信任，浏览器会给出提示，因此需要注意浏览器安全提示</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305180036957.jpeg"
                      alt="img" style="zoom:80%;" 
                >
<h2 id="HTTP-2-0">HTTP 2.0</h2>
<p>http2.0 是一种安全高效的下一代 http 传输协议。安全是因为 http2.0 建立在 https 协议的基础上，高效是因为它是通过<strong>二进制分帧</strong>来进行数据传输。</p>
<h4 id="二进制分帧（Binary-Format）">二进制分帧（Binary Format）</h4>
<p>HTTP 1.1最大的槽点之一就是使用<strong>明文</strong>对头部进行编码而非二进制，这造成了空间的浪费，毕竟有些一个标志位就能解决的东西非要用几十个字节的字符串来描述，对于寸土寸金的 TCP 报文实在是有些浪费。</p>
<p>除了<strong>二进制</strong>外，<strong>分帧</strong>也是很重要的一个特性 —— <strong>HTTP 2.0把所有传输的信息分割为更小的消息（message），并把消息进一步细分为更小的帧（frame）</strong>，并对它们<strong>采用二进制格式的编码</strong>。</p>
<p>比如， HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面，具体如下图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305180036171.jpg"
                      alt=""
                ></p>
<h3 id="多路复用-Multiplexing-和连接共享">多路复用 (Multiplexing) 和连接共享</h3>
<p>多路复用对于搞信号的同学来说肯定不陌生，我们先来看看原本的 HTTP 1.x 的 TCP 请求风格吧。</p>
<h4 id="HTTP-1-x">HTTP 1.x</h4>
<p><strong>HTTP 1.0</strong> 中是没有连接持久化这个概念，首先根据浏览器的解析顺序，我们不能一次性得到完整的 HTML 页面，而是会遇到资源后再进行新的请求。而在 HTTP 1.0 中，我们<strong>每次请求都需要建立新的 TCP 连接</strong>，重复握手和挥手过程！</p>
<p><strong>HTTP 1.1</strong> 中引入了持久连接和管道的概念，这样不用每次请求都去重新开启和新建连接，HTTP默认底层的TCP连接是open的，除非手动告诉它要去关闭。在这种情况下，客户端可以使用同一个连接去和server进行交互，从而极大的提升HTTP的效率。</p>
<p>虽然在HTTP1.1中可以使用同一个连接进行数据传输了，但是对于这个连接来说，其中的请求是一一响应的，他们是有顺序的。<strong>如果最前面的请求被阻塞了，后面的请求也得不到响应</strong>。这种情况被称为 <strong>head-of-line (HOL) blocking</strong>。</p>
<p>为了解决这个问题，可以在 client 和 server 端<strong>建立多个连接</strong>，这样就可以利用多个 connection 并行进行数据的传输，从而提升传输效率。</p>
<h4 id="HTTP-2">HTTP 2</h4>
<p>HTTP1.1需要建立多个TCP连接从而解决并行传输的问题，但是在HTTP/2 中<strong>只需要建立一个连接</strong>就够了。</p>
<p>得益于新的<strong>分帧机制</strong>，在这个连接中可以传输多个数据流，每个数据流中又包含多个message包，每个message又被切分为多个数据frame，这些数据帧可以<strong>乱序发送</strong>，并<strong>在接收端根据帧首部信息重新组装</strong>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305180036170.webp"
                      alt=""
                ></p>
<h3 id="头部压缩">头部压缩</h3>
<p>http1.x的头带有大量信息，而且每次都要重复发送。http/2使用<strong>本地索引表+映射</strong>机制来减少需要传输的header大小，即双方各自缓存一份头部字段表，在<strong>报文头部只存储字段表的索引</strong>，同时<strong>只在头部更新时传输需要更新的字段</strong>。这样既避免了重复header的传输，又减小了需要传输的大小。</p>
<p>http/2使用的是专门为首部压缩而设计的HPACK②算法，<strong>使用一份索引表来定义常用的http Header</strong>，把常用的 http Header 存放在表里，请求的时候便只需要发送在表里的索引位置即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305180036350.webp"
                      alt=""
                ></p>
<h3 id="其他特征">其他特征</h3>
<h4 id="请求优先级（Request-Priorities）">请求优先级（Request Priorities）</h4>
<p>把http消息分为很多独立帧之后，就可以通过优化这些帧的交错和传输顺序进一步优化性能。每个流都可以带有一个31比特的优先值：0 表示最高优先级；2的31次方-1 表示最低优先级。</p>
<p>服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。高优先级的流都应该优先发送，但又不会绝对的。绝对地准守，可能又会引入首队阻塞的问题：高优先级的请求慢导致阻塞其他资源交付。</p>
<p>分配处理资源和客户端与服务器间的带宽，不同优先级的混合也是必须的。客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。</p>
<ul>
<li>
<p>优先级最高：主要的html</p>
</li>
<li>
<p>优先级高：CSS文件</p>
</li>
<li>
<p>优先级中：js文件</p>
</li>
<li>
<p>优先级低：图片</p>
</li>
</ul>
<h4 id="服务端推送（Server-Push）">服务端推送（Server Push）</h4>
<p>服务器可以对一个客户端请求发送多个响应，服务器向客户端推送资源无需客户端明确地请求。并且，服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。</p>
<p>正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。Server Push 让 http1.x 时代使用内嵌资源的优化手段变得没有意义；如果一个请求是由你的主页发起的，服务器很可能会响应主页内容、logo 以及样式表，因为它知道客户端会用到这些东西，这相当于在一个 HTML 文档内集合了所有的资源。</p>
<p>不过与之相比，服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305180036406.webp"
                      alt=""
                ></p>
<p>注意两点：</p>
<ul>
<li>
<p>推送遵循同源策略；</p>
</li>
<li>
<p>这种服务端的推送是基于客户端的请求响应来确定的。</p>
</li>
</ul>
<p>当服务端需要主动推送某个资源时，便会发送一个 Frame Type 为 PUSH_PROMISE 的 Frame，里面带了 PUSH 需要新建的 Stream ID。意思是告诉客户端：接下来我要用这个 ID 向你发送东西，客户端准备好接着。客户端解析 Frame 时，发现它是一个 PUSH_PROMISE 类型，便会准备接收服务端要推送的流。</p>
<h2 id="WebSocket-协议">WebSocket 协议</h2>
<p>WebSocket 是 HTML5 开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。</p>
<p>对大部分web开发者来说，上面这段描述有点枯燥，其实只要记住几点：</p>
<ol>
<li>WebSocket可以在浏览器里使用</li>
<li>支持双向通信</li>
<li>使用很简单</li>
</ol>
]]></content>
      <categories>
        <category>面试经验</category>
      </categories>
      <tags>
        <tag>websocket</tag>
        <tag>2023春招</tag>
        <tag>前端</tag>
        <tag>计算机网络</tag>
        <tag>http</tag>
        <tag>https</tag>
        <tag>cookie</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title>前端工具链之包管理器 - 过去与未来的npm</title>
    <url>/posts/1582998169/</url>
    <content><![CDATA[<p>本篇文章是前端工具链系列文章的开篇之作，本来是打算写一篇很长很长的文章，来详尽阐述2023年的前端工具链的全貌的。但奈何篇幅实在太长，不便发布和阅读，而且有些部分完成度已经较高，但由于其他部分的完成度几乎为0导致这些内容不能发布出来 <s>（可以预见的由于工作原因另一部分可能拖更较久）</s>  。</p>
<p>最终选择了分段分章节的形式，将每个部分单独提出来说，最终在一个目录中汇总，这样阅读体验更好，每个部分也能说得更详细一点。</p>
<p>本篇主要讲述npm的发展历史（历史渊源和各个版本的改动），组织node_modules方式的变动以及<code>package.json</code>的详细介绍（并发布一个自己的npm包）；除此之外，还会介绍node官方提出的现代包管理器愿景，并介绍<strong>corepack</strong>工具（包管理器的管理器）。</p>
<span id="more"></span>
<blockquote>
<p><em>npm</em>(Node Package Manager) 不仅是一个包管理器，更是<strong>前端的项目管理器</strong>，它除了<strong>管理依赖</strong>，还定义了项目的信息、脚本和行为，这些信息都被<em>npm</em>存储在<code>package.json</code>中。</p>
<p>可以说<em>npm</em>是一切前端项目，包括其他包管理器的基础，其他包管理器均必须实现npm的基础功能，<strong>你可以没有其他包管理器，但你必须有且理解npm</strong>。</p>
</blockquote>
<p>上面一段是我在*《前端工具链》*草稿中写的原文，虽然这一段在新的组织形式下已经不再合适作为部分总结，但仍很好地概括npm的地位——理解了npm你才能理解其他包管理器（或者说为什么需要更现代的解决方案），也是为什么我们已经有yarn和pnpm等更现代的解决方案，连node官方都打算不再完整内置npm的今天我们仍需要学习npm的原因，而不仅仅是出于一些兼容性的原因才学习和使用npm（当然学习了npm的机制也能更好地解决出现在其他包管理器中出现的兼容性问题）。</p>
<h2 id="npm的诞生">npm的诞生</h2>
<p>如果你用过C++，也用过Python或者Rust，那你在 <strong>如何快速地调用他人写好的代码</strong> 这件事上，对二者的效率有深刻的认识。是的，Python/Rust有自己的<strong>包管理器</strong>（pip/cargo），但C++却没有一个统一的包管理器方案（vcpkg或许是一个选择），这导致你调用别人代码的门槛显著提高，也不利于库作者的版本管理。</p>
<p>程序员群体从最初开始就强调一个社区文化、开源精神~~（Bill Gates除外）~~ ，复用别人的代码和让别人能复用自己的代码自然也是社区的头号需求，在现代前端开发中node环境已经普及的今天（或者说昨天），一个对应node环境的包管理器自然会产生，是的，这就是npm。</p>
<blockquote>
<p>拿Python作对比的话：JavaScript是语言本身，类似于python；node是语言运行环境，类似于cpython；npm是包管理器机制，类似于pip（和PyPi）。</p>
<p>其实在项目管理这一点上，node.js和npm更像Rust于Cargo的关系 <s>但是说爸爸像儿子总是不合适的</s></p>
</blockquote>
<h3 id="前npm时代如何共享代码">前npm时代如何共享代码</h3>
<p>毕竟JS和Web的历史远比Node和npm更悠久，那么在更为原始的web开发年代，大家是如何共享代码的呢？</p>
<p>对于直接使用代码来说，有两种方法：</p>
<ul>
<li>直接共享代码：在Github上共享代码库，直接下载源码，也就是最直接的使用方式</li>
<li>使用CDN分发：现在的网页开发中仍存在这种方法，即用<code>&lt;script src=&quot;xxx&quot;/&gt;</code>直接引用线上的JS资源</li>
</ul>
<h3 id="JS模块化">JS模块化</h3>
<p>如果我们采用上面提到的两种方法对他人的代码进行复用，在项目规模不断扩大后，新的问题就出现了：<strong>全局变量污染</strong>。</p>
<p>假如说我们用<code>&lt;script&gt;</code>引入了<code>a.js</code>和<code>b.js</code>两个JS脚本，但两个脚本中都定义了一个名称相同的全局变量，或者都使用了隐式的全局<code>this</code>指针去给同一个属性赋值，这时的变量行为就不再可控了，彼此覆盖的顺序通常由<code>&lt;script&gt;</code>的执行顺序决定，这可能会给整个页面的效果造成毁灭性的破坏。</p>
<p>一个比较简单粗暴的解决方案是给每个全局变量都加上模块名前缀，并禁止使用全局<code>this</code>，但这显然是一个治标不治本的方法，只有从根本上解决全局作用域的问题才能维持项目的健康，这里就需要引入“<strong>模块化</strong>”的概念。</p>
<blockquote>
<p><strong>模块化</strong>：把复杂的系统分解到多个模块以方便编码</p>
<p>在<strong>模块化编程</strong>中，开发者将程序分解成离散功能块（discrete chunks of functionality），并称之为<strong>模块</strong>。</p>
<ul>
<li>将一个复杂的程序依据一定的规则（规范）封装成几个块（文件），并进行组合在一起</li>
<li>块的内部数据相对而言是私有的，只是向外部暴露一些接口与外部其他模块通信</li>
</ul>
<p>每个模块具有比完整程序更小的接触面，使得校验、调试、测试轻而易举。 精心编写的<em>模块</em>提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。</p>
</blockquote>
<p>JS的所谓模块化就是<strong>包装一个模块内部的所有代码，使其标识符不向外暴露，而仅仅暴露声明（导出）的标识符，以避免全局污染</strong>。为了实现模块化的这些功能，Web界提出了不同的解决方案：</p>
<ul>
<li>原始的<code>&lt;script&gt;</code>方案 + 开发规范：这种方案并不能称得上严格意义的模块化，仅仅是引用了不同的JS文件，并遵守了一定规范
<ul>
<li>仍可能<strong>污染全局作用域</strong>，script会直接存在在根DOM下，全局有效</li>
<li>仅适用于Web页面开发，在node环境中无效</li>
<li>在大型项目中各种资源难以管理依赖、版本和加载顺序</li>
</ul>
</li>
<li><strong>CommonJS</strong>系列方案：Node的主流方案，使用<strong>模块作用域</strong>来解决全局污染，都使用<code>require</code>来引用模块</li>
<li><strong>ESM</strong>方案：采用**“编译时输出接口”**的策略，是一种静态的、异步的、底层的模块化方案</li>
</ul>
<h4 id="CommonJS-家族">CommonJS 家族</h4>
<p>CommonJS方案有CJS、AMD和CMD三个分支方案，<strong>这里推荐只了解CJS方案即可</strong>。由于CJS目前最主流的平台实现是NodeJS，因此大部分特性将依照Node的实现机制进行理解。</p>
<blockquote>
<p><strong>CommonJS（CJS）方案</strong>：在ECMA Module（ESM）方案出来前最流行的方案，<strong>现在NodeJS仍采用这种方案作为主流</strong>，但Node 12后也官方支持了ESM，只是需要一些手段来启用其支持（如<code>.mjs</code>后缀名或指定<code>type: module</code>）</p>
<p>AMD和CMD是CJS方案<strong>在浏览器端的异步实现</strong>，这里不再介绍。</p>
</blockquote>
<ul>
<li>
<p>CJS是一种<strong>同步加载</strong>方案，模块的加载顺序，按照其在代码中出现的顺序进行加载</p>
</li>
<li>
<p>CJS添加了一种<strong>模块作用域</strong>（类似于C语言中的单文件作用域），每个文件就是一个模块，所有代码运行在模块作用域中，不会污染全局作用域</p>
<ul>
<li>通常情况下模块内声明的变量不会污染全局作用域，除非意外声明了全局变量（没有用<code>var</code>, <code>let</code>, <code>const</code>关键字而直接声明）</li>
<li><code>&quot;use strict&quot;</code>模式可以避免上述情况，但可以通过<code>global.XXX</code>显式地声明全局变量</li>
<li>Node中<strong>使用包装函数为每个文件提供了一个独立的函数作用域</strong>，以此来实现了模块作用域，详见<a class="link"   href="https://zhuanlan.zhihu.com/p/25916585" >这篇文章 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li>
<p>使用<code>require(package)</code>加载模块（即被依赖模块的<code>module.exports</code>对象）</p>
<ul>
<li>通过按顺序查找PATH去加载模块</li>
<li>模块可以加载多次，第一次加载时会运行模块，<strong>模块输出结果会被缓存，再次加载时，会从缓存结果中读取输出模块</strong></li>
<li><strong>缓存机制可以通过先创建缓存再载入文件的顺序避免循环引用产生的死锁</strong>
<ul>
<li>当<code>app.js</code>调用<code>a.js</code>时，发现第一行是加载 <code>b.js</code>，它会检查缓存中有没有 <code>b.js</code>，发现没有，于是 new 一个 <code>b.js</code> 模块，并将这个模块放到缓存中，再去加载 <code>b.js</code> 文件本身</li>
<li>在加载 <code>b.js</code> 文件时，Module 发现第一行是加载 <code>a.js</code>，它会检查缓存中有没有 <code>a.js</code>，发现存在，于是 <code>require</code> 函数返回了缓存中的 <code>a.js</code></li>
<li>这个时候 <code>a.js</code> 根本还没有执行完，还没走到 <code>module.exports</code> 那一步，所以 <code>b.js</code> 中 <code>require('./a.js')</code> 返回的只是一个默认的空对象。所以最终会报 <code>setA is not a function</code> 的异常</li>
</ul>
</li>
</ul>
</li>
<li>
<p>使用<code>module.exports</code>对象暴露当前模块对外的接口（是的，<code>module.exports</code>是一个对象）</p>
<ul>
<li>直接将一个对象赋值给<code>module.exports</code>，<code>require</code>时就可以直接获取这个对象</li>
<li>也可以给<code>module.exports</code>添加属性或方法，如<code>module.exports.foo = 'foo'</code></li>
<li>为了方便，Node为每个模块提供一个<code>exports</code>变量，即在开头隐式地提供了<code>exports=module.exports</code>这样一句话</li>
</ul>
</li>
<li>
<p>每个模块内部都包含一个<code>Module</code>对象（自动生成）</p>
<ul>
<li><code>id</code>：模块的标识符</li>
<li><code>filename</code>：模块的文件名，带有绝对路径</li>
<li><code>loaded</code>：表示模块是否已经完成加载，用于缓存加载</li>
<li><code>parent</code>：一个数组，表示调用该模块的模块</li>
<li><code>children</code>：一个数组，表示该模块要用到的其他模块</li>
<li><code>exports</code>：一个对象，表示模块对外输出的值</li>
</ul>
</li>
<li>
<p><strong>由于CJS需要Node的支持，在浏览器端需要转译为<code>&lt;script&gt;</code>标签才能使用，但其模块作用域将得到保留，全局污染的问题得到了解决</strong></p>
</li>
<li>
<p>由于CJS的所有功能都是用JS已有特性实现的，因此你也可以实现自己的CJS函数</p>
</li>
</ul>
<p>在本地跑了一个demo，一个空文件的<strong>CJS Module</strong>变量如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230602172113.png"
                      alt=""
                ></p>
<h4 id="ESM-模块">ESM 模块</h4>
<p>在CommonJS家族中：<strong>CJS是同步加载</strong>，主要用于<strong>服务器端（Node）<strong>的模块化实现；<strong>AMD、CMD是异步加载</strong>，二者处理依赖的方式不同，主要用于</strong>浏览器端</strong>的模块化实现。但他们都有一个共同点：他们都只是<strong>在JS现有功能基础（如闭包）之上实现的模块化，而不是语言层面的模块化</strong>，因此也有很多因此而生的缺点：</p>
<ul>
<li><code>module</code>和<code>exports</code>并非JS关键字，而仅仅是对象或函数，其实现由具体的运行时或者库决定（如Node），并非统一的语言标准</li>
<li>CJS为了保证加载顺序的可控，采用同步加载（即<strong>同步地执行模块内部全局作用域地代码来初始化模块</strong>），可能造成阻塞和性能瓶颈</li>
<li>最重要的一点：由于实现机制的原因，CJS的<code>require</code>返回的是值的<strong>拷贝</strong>（执行代码直接将对应值赋给<code>exports</code>对象）</li>
</ul>
<p>其中最难的是<strong>如何理解CJS的<code>require</code>返回的是值的拷贝</strong>，请参考下面的代码——由于拷贝了值，无论如何<code>setVal</code>始终都不能改变<code>val</code>的值（具体过程详见<a class="link"   href="https://segmentfault.com/a/1190000041396029" >这篇文章 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">let</span> val = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">setVal</span> = (<span class="params">newVal</span>) =&gt; &#123;</span><br><span class="line">  val = newVal</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  val,</span><br><span class="line">  setVal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; val, setVal &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(val); <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">setVal</span>(<span class="number">101</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(val); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></div>
<p>为了解决上述问题，ECMA出手了，<strong>在ES6标准中提出了ESM模块规范</strong>，它在CJS规范上更进一步，在语法层次上为模块化提供了支持，并有自己的语法：</p>
<ul>
<li>使用<code>import</code>语句进行模块导入，<code>export</code>语句进行模块导出</li>
<li><code>export</code>分为<strong>默认导出</strong>和命名导出两种
<ul>
<li><code>export</code>只能导出一个默认（含有<code>default</code>）值，这个默认值可以用任意名称导入，如<code>import AnyName from './moduleWithDefault'</code></li>
<li>使用<strong>命名导出</strong>可以导入若干个模块内的变量，可以批量命名导出，如：<code>export &#123;a,b,c&#125;</code></li>
<li>命名导出和默认导出可以一起使用</li>
</ul>
</li>
<li><code>import</code>语句支持不含后缀名的写法（因为不同后缀名可以代表不同的标标准，如<code>.mjs</code>和<code>.cjs</code>）</li>
<li>ESM默认采用<strong>严格模式</strong>，即全局<code>this</code>是<code>undefined</code>的，这彻底杜绝了全局污染的可能性（实际上是ES6要求）</li>
<li><strong>ESM模块的是静态的、编译期的，同时也是直接引用而非拷贝</strong>，这解决了CJS最大的一个痛点</li>
</ul>
<p>要理解为什么需要ESM模块，我们就要知道ESM和CJS的根本区别——<strong>CJS是对象拷贝，ESM是符号链接</strong>，是更底层的东西。</p>
<p>对比CJS和ESM，它们最主要的区别如下：</p>
<ul>
<li>ESM是语言标准，<code>import</code>和<code>export</code>是JS语言关键字，可以<strong>在编译期直接输出模块接口</strong>，因此说ESM是<strong>静态</strong>的</li>
<li>ESM是<strong>异步</strong>加载的，在<strong>执行模块前</strong>有一个独立的模块依赖的解析阶段</li>
<li>ESM中<code>import</code>返回的是模块的<strong>引用</strong>而非拷贝，任何对原模块的改动都会即刻反映到所有调用它的地方</li>
</ul>
<p>在理解ESM的实现之前，我们要先了解一些JS解释器运行JS代码的过程才能更好地理解ESM：</p>
<blockquote>
<p>在V8引擎中，JS的执行过程被分为了两个步骤：</p>
<ol>
<li><strong>编译阶段</strong>：将文本代码翻译成更贴近机器的<strong>字节码</strong>，但仍需要Runtime来执行（解释型语言，非机器码）
<ul>
<li>词法分析：将语句化成一个个Token，这一步可以检出错误的标识符</li>
<li>语法分析：注意<strong>词法作用域</strong>实际上是在语法分析中形成的，这一步可以检测语法错误</li>
<li>字节码生成（在编译型语言中这一步是IR或机器码生成）</li>
</ul>
</li>
<li><strong>执行阶段</strong>：JS解释器会模仿系统调用和任务队列，为语句和函数创建<strong>执行上下文</strong>（execution context）并推入执行栈
<ul>
<li>创建阶段
<ul>
<li>绑定this</li>
<li>为函数和变量分配内存空间</li>
<li>初始化作用域中所有变量（注意es6中<code>let</code>和<code>const</code>不会被赋初值<code>undefined</code>）</li>
</ul>
</li>
<li>执行阶段：将执行上下文推入执行栈，并开始运行代码</li>
</ul>
</li>
</ol>
</blockquote>
<p>所以，ESM之所以是**“编译时输出接口”**，正是因为它是ECMA的亲儿子，可以对编译期本身做手脚。</p>
<blockquote>
<p>由于我确实没有查到“编译时解析引用”相关的资料，以下几点是我<strong>个人的理解</strong>，并不保证正确。</p>
<p>这里需要明确一点：JS是解释型语言，严格意义上并不存在所谓“编译期”，只有将代码解析生成“字节码”的过程。</p>
</blockquote>
<ul>
<li>在模块作用域方面，可以理解为和CJS没有区别（没有找到相关资料）</li>
<li>在<strong>编译期</strong>（词法、文法分析阶段）ESM的特殊之处在于它在语法层面为<code>import</code>和<code>export</code>提供了支持，在<strong>语法分析</strong>阶段会检查顶层规则
<ul>
<li>当你违反了<code>import</code>或<code>export</code>的语法规则，它会在<strong>编译阶段</strong>就报错而根本不会进入执行阶段（不会生成执行上下文）</li>
<li>在遇到正确的<code>import</code>和<code>export</code>时会生成对应的<strong>符号链接</strong>（并不是真的在编译期就解析了引用），并在后续的<strong>创建阶段</strong>才将这些符号连接起来，这也是ESM能真正引用模块的原因</li>
</ul>
</li>
<li>实际解析引用的阶段应该是运行阶段中的<strong>创建阶段</strong>，而非<strong>执行阶段</strong>，这也是ESM被称为“静态引用”或者“编译时引用”的原因，因为它<strong>确实在运行阶段之前就解析了引用</strong></li>
<li>在创建阶段解析的顺序大概是这样：<strong>创建词法作用域-&gt;变量声明提升-&gt;检查变量中的<code>import</code>-&gt;进行引用解析</strong>。因此在循环引用时原模块的词法作用域是已经声明好的</li>
<li><strong>解析模块引用</strong>的过程与CJS相似（先创建缓存实例再加载代码）：检查缓存-&gt;新建Module实例放入缓存-&gt;加载模块代码</li>
</ul>
<p>下面这段代码证明了ESM确实在编译期为<code>import</code>和<code>export</code>提供了语法支持：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Wrong Import&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&quot;path&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// out:</span></span><br><span class="line"><span class="comment">//   import &#123; resolve &#125; from &#x27;path&#x27;;</span></span><br><span class="line"><span class="comment">//          ^</span></span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token &#x27;&#123;&#x27;</span></span><br></pre></td></tr></table></figure></div>
<p>如上面的代码，在报错时根本不会打印log的“Wrong Import”，而是直接显示错误信息，因为程序在编译阶段就报错并Panic了，根本不会进入运行阶段。</p>
<p>而下面这段代码则用<strong>循环引用</strong>演示了ESM的加载过程，顺带证明了ESM确实是<strong>在运行阶段之前进行了模块解析</strong>：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.mjs</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./a.mjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="comment">// 注意这里的运行顺序，如果先运行了这句再运行b中语句就代表是动态加载</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;running a.mjs&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; b, setB &#125; <span class="keyword">from</span> <span class="string">&#x27;./b.mjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b val&#x27;</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setB to bb&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">setB</span>(<span class="string">&#x27;bb&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">setA</span> = (<span class="params">newA</span>) =&gt; &#123;</span><br><span class="line">  a = newA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  a,</span><br><span class="line">  setA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; a, setA &#125; <span class="keyword">from</span> <span class="string">&#x27;./a.mjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;running b.mjs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a val&#x27;</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setA to aa&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">setA</span>(<span class="string">&#x27;aa&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">setB</span> = (<span class="params">newB</span>) =&gt; &#123;</span><br><span class="line">  b = newB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  b,</span><br><span class="line">  setB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上面这段代码证明了EMS的加载过程，注意由于<strong>上下文的创建阶段</strong>会提升内部所有变量构建词法环境，因此这里可能会<strong>发生局部死区或者变量提升问题</strong>，但这<strong>避免了循环引用导致的死锁</strong>。</p>
<p>但当我们直接运行<code>index.mjs</code>可以发现它报错信息如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230602231053.png"
                      alt=""
                ></p>
<p>这并不是由循环引用造成的，而是变量提升造成的局部死区，我们将<code>a.mjs</code>顶层变量的声明从<code>let</code>改成<code>const</code>就可以让其获得初始值<code>undefined</code>，并用<code>function</code>替代变量初始化（因为变量提升会初始化<code>function</code>），让这个例子成功的跑起来。（是的，只用改a，因为只有b在调用a时会产生死区）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230602231455.png"
                      alt=""
                ></p>
<p>由上面的例子，我们来分析一下整个模块的解析过程：</p>
<ol>
<li><code>app.mjs</code>导入了<code>a.mjs</code>这个模块，检查缓存不存在，创建一个<code>Module</code>实例放入缓存中，并加载<code>a.mjs</code>的代码到实例中</li>
<li>编译<code>a.mjs</code>的代码，创建执行上下文，在过程中发现了<code>b.mjs</code>的引用，以同样的方式加载<code>b.mjs</code>的代码
<ul>
<li>编译期会检测ESM规则和错误，但并不会实际执行导入工作</li>
</ul>
</li>
<li>在<code>b.mjs</code>代码的开头发现了<code>a.mjs</code>的引用，返回<code>a</code>的缓存，由于此时<code>a</code>的缓存中模块的执行上下文已经初始化完毕，也就是说变量声明已经提升
<ul>
<li>如果是<code>var</code>变量就会得到初始值<code>undefined</code></li>
<li>如果是<code>function</code>声明的函数就会提前声明和定义</li>
<li>如果是<code>let</code>、<code>const</code>和箭头函数变量，就只会提升定义，并不会得到初始化，出现局部死区错误</li>
</ul>
</li>
<li>如果没有发生错误，<code>b</code>中将会使用<code>a</code>中的执行上下文环境变量继续执行</li>
<li><code>b</code>的<em>全局执行上下文</em>（不属于任何函数的语句的上下文）执行完毕后退栈，轮到<code>a</code>继续执行，此时<code>b</code>的所有变量都已经正确声明且初始化，因此不会发生任何错误</li>
<li><code>a</code>执行完毕，退栈，控制权还给<code>app</code>，代码执行完毕，程序结束</li>
</ol>
<h3 id="如何管理模块">如何管理模块</h3>
<p>现在我们有了完善的<strong>模块化方案</strong>（CJS和ESM），并将模块的概念进一步扩大：若干源码文件（模块）组成一个代码集合，这个集合可能实现了一组逻辑或功能，我们将这个集合封装起来，并<strong>定义一个入口文件，这样整个集合对外就成了一个模块，内容就是入口文件的内容</strong>，再在入口文件内选择对外暴露的接口，<strong>这个“大模块”内部的组织结构并不会向外暴露，只有“入口模块”向外暴露</strong>，这样就形成了<strong>包（package）</strong>。</p>
<p>npm（Node Package Manager）就是这样一个管理基于NodeJS开发的包的工具，它提供了两项基本功能：</p>
<ul>
<li>项目管理：开发的项目本身作为包应该如何发布和管理</li>
<li>依赖管理：当前项目依赖的其他包如何从统一的地方下载和管理</li>
</ul>
<p>当然，npm-v1中的依赖管理思路是非常简单粗暴的：每个包都声明自己需要哪些依赖，在安装依赖的时候就递归地为所有包安装它的依赖，直到所有包都安装完毕，最终形成了一个嵌套的<code>node_modules</code>结构：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305050105265.jpg"
                      alt=""
                ></p>
<p>这样做的好处是简单粗暴，不会出问题；坏处就是可能会存在大量重复的依赖，浪费空间，同时在项目复杂度不断增长后路径深度过大可能产生错误。</p>
<h2 id="npm的进化史">npm的进化史</h2>
<h3 id="粗犷的嵌套目录（v1-v2）">粗犷的嵌套目录（v1-v2）</h3>
<p>在v1和v2版本，npm一直采用刚刚提到的完全嵌套式的目录结构来管理依赖，产生了大量的空间浪费和过深的目录。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305050105265.jpg"
                      alt=""
                ></p>
<h3 id="扁平化目录（v3-v4）">扁平化目录（v3-v4）</h3>
<p>在v3版本中，npm为我们带来了<strong>扁平化的依赖关系树</strong>，把嵌套的目录完全拍扁成一层，解决了重复依赖和目录深度问题：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305050105809.png"
                      alt=""
                ></p>
<p>但扁平目录的更新并没有解决全部的问题，它也带来了一些新的问题：</p>
<ul>
<li><strong>扁平化的目录不能正确反映包之间的依赖关系</strong>。因此npm必须首先遍历所有的项目依赖关系<strong>生成依赖树</strong>，再决定如何生成扁平的node_modules目录结构（即在install安装时，会不停的往上级node_modules中寻找，如果找到同样的包，就不再重复安装），而这个<strong>依赖分析是一个很耗时的操作</strong>，也是<a class="link"   href="https://github.com/npm/npm/issues/8826" >npm安装速度慢的一个很重要的原因 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</li>
<li><strong>依赖结构是不确定的</strong>。当两个包依赖了同一个包的不同版本，这在依赖解析时的行为就是无法确定的。如<code>B</code>依赖了<code>F@1.0.0</code>，而<code>C</code>依赖了<code>F@2.0.0</code>，若在<code>package.json</code>中<strong>B在C前面就会采取B的依赖</strong>（即<code>F@1.0.0</code>），否则就会采取C的依赖。</li>
<li>由于间接依赖也会放在顶级目录中，因此<strong>项目中可以非法访问没有在<code>package.json</code>中声明过依赖的包</strong></li>
</ul>
<h3 id="固定化依赖（v5-）">固定化依赖（v5+）</h3>
<p>受到了yarn-v1（Classic Yarn）的冲击，npm-v5终于引入了固定化依赖树的文件结构：<code>package-lock.json</code>，它在<code>npm install</code>时会<strong>自动生成</strong>，比<code>package.json</code>记录了更多的额外信息，可以加快<code>npm install</code>的速度和稳定性。</p>
<blockquote>
<p>其实在此之前，npm也有类似的lock文件去记录依赖树信息，叫做<code>npm-shrinkwrap.json</code>，但并不会自动生成，需要使用<code>npm shrinkwrap</code>指令去生成，且向下兼容npm-v2~4，在v5+的优先级也高于lock文件。</p>
</blockquote>
<h4 id="lock文件记录了什么">lock文件记录了什么</h4>
<p>首先，我们先随便打开一个项目的<code>package-lock.json</code>看看里面有什么：</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hr-manage-system&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;lockfileVersion&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;requires&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;packages&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hr-manage-system&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          ...</span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          ...</span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;node_modules/@ampproject/remapping&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;resolved&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.2.0.tgz&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;integrity&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sha512-qRmjj8nj9qmLTQXXmaR1cck3UXSRMPrbsLJAasZpF+t3riI71BXed5ebIOYwQntykeZuhjsdweEc9BxH5Jc26w==&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;@jridgewell/gen-mapping&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;@jridgewell/trace-mapping&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.3.9&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;engines&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;node&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&gt;=6.0.0&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>
<p>可以看出，lock文件里的依赖信息显然比<code>package.json</code>更丰富，如<strong>指定了明确的版本号、下载地址等信息</strong>，最重要的是<strong>指定了依赖项的依赖项</strong>，这避免了反复查询，节省了大量时间，同时也起到了固定依赖的作用。lock文件的出现，一口气解决了npm-v3中<strong>安装构建慢、依赖版本不确定、依赖树不确定</strong>的问题。</p>
<blockquote>
<p>总结：</p>
<ul>
<li>lock 文件可以指定依赖的版本号、下载地址和依赖情况，<strong>保证其他人在<code>npm install</code>时大家的依赖能保证一致</strong>并节约安装时间</li>
<li>需要保证所有人使用同一份lock文件才能提高效率，避免冲突</li>
<li><strong>每次添加新包需要运行一次<code>npm install</code>才能更新lock文件</strong>，特别是在其他包管理器和npm共同使用的时候这点非常关键</li>
</ul>
</blockquote>
<h4 id="npm-install时发生了什么"><code>npm install</code>时发生了什么</h4>
<p>要真正理解lock文件是如何起到固定依赖树的作用的，我们就需要知道<code>npm install</code>时究竟发生了什么。之所以放到这里才讲而不是开头，是因为v5这里基本确定了现代包管理器的安装方式，放在这里讲就避免了重复叙述。</p>
<p>首先，我们看一张<code>npm install</code>的总体流程图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305031454782.png"
                      alt=""
                ></p>
<p>一般来讲，<code>npm install</code>按照上图工作，大致可以分为5个流程：</p>
<ol>
<li>若<strong>未找到<code>package-lock.json</code></strong>，就依次向<strong>cache</strong>和registry（线上源）查询包信息；若找到<code>package-lock.json</code>则直接使用其记录的依赖树信息，免去了查询和构建的过程，直接下载对应包（或调取缓存）</li>
<li>下载依赖包，存放在cache目录</li>
<li>解压下载的压缩包到<code>node_modules</code>目录</li>
<li>将所有<strong>已安装的包信息存放到<code>package-lock.json</code>中，以供下次安装使用</strong></li>
<li>递归地处理依赖的依赖，直至所有依赖都完成安装</li>
</ol>
<p>从上面的流程中我们不难看出，lock文件描述的是<strong>npm应该从哪里找到、怎么构建依赖的行为集合</strong>，如果有lock文件作为指导npm就不用挨个查询，而是一步到位节省很多时间。</p>
<p>但是，<strong>如果lock文件和<code>package.json</code>产生了冲突，安装过程就无法顺利进行</strong>：</p>
<ul>
<li>npm 5.0.x版本，不管<code>package.json</code>怎么变，<code>npm install</code>都会根据lock文件下载。</li>
<li>npm 5.1.0 - 5.4.1版本，<code>npm insall</code>会无视lock文件，去下载<strong>semver兼容的最新的包</strong>。</li>
<li>npm 5.4.2版本之后，如果手动改了<code>package.json</code>，且<code>package.json</code>和lock文件不同，那么执行<code>npm install</code>时npm会根据package中的版本号和语义含义去下载最新的包，并更新至lock。</li>
</ul>
<h4 id="npm的全局缓存">npm的全局缓存</h4>
<p>相信细心的同学已经发现上述的<code>npm install</code>中有<strong>调取缓存</strong>这个操作，但在传统印象中不是yarn才有缓存吗（网络性能优化）？其实不然，其一n是npm很早之前就有了本地下载缓存机制（但一直到v5才支持offline-mode）；其二网络性能优化和下载缓存不是同一个概念，并不能相提并论。</p>
<blockquote>
<p>这里仅讨论<strong>npm-v5后引入的cacache机制</strong>。</p>
</blockquote>
<p>npm从registry下载任何package时，都会存储到本地的缓存目录：<code>$NPM_PATH$/_cacache</code>里（可以试试用Everything搜索），里面又有三个文件夹：</p>
<ul>
<li>content-v2：实际存储tar包的地方（下载缓存）</li>
<li>index-v5：存放meta信息用于索引</li>
<li>tmp：临时文件</li>
</ul>
<p>npm在安装依赖的时候，根据具体包的version, name和integrity信息（通常是直接用lock文件中的）按如下步骤进行计算：</p>
<ol>
<li>按<code>pacote:range-manifest:&#123;url&#125;:&#123;integrity&#125;</code>的格式生成唯一key</li>
<li>通过SHA256计算Hash，去<code>_cacache/index-v5</code>里找对应的索引文件（前4位分目录，分两层），得到<strong>meta信息</strong>如下：</li>
</ol>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="number">14</span>da5c6cbf56513e6c9a015428e7a2e967770958	<span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;security-advisory:rc:lY0T7yQCamSwv6XrfkWFkNC52rORUpy+EA52ZHNPnNx68d9GVbTXrEorrxRr7Rp5o2tBSHDK27ayPcgCQX8IrQ==&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;integrity&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sha512-rE2QtaXAtFkff+ggY34B7Dned+y7u6eAhuMa19j7MdZe/02nmZLBbgx2lsVHny3KhWUPz367HGA1UMIKzoc2iw==&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="number">1664882561084</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">881</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>
<p>可能还有<code>metadata</code>字段，描述了这个缓存的源信息和Hash值用于比对，这里我随便打开了一个没有这个字段。</p>
<ol start="3">
<li>利用<code>metadata</code>中的<code>_shasum</code>字段去<code>_cacache/content-v2</code>中匹配gzip缓存</li>
<li>如果缓存命中，就会向远程仓库确认是否过期（304检查）检查，如果均通过，就会直接使用缓存；否则就会向registry请求包，并更新缓存。（与浏览器缓存机制类似）</li>
</ol>
<blockquote>
<p>这里有个问题，<strong>为什么需要使用两级缓存机制（索引+SHA寻址）而非直接缓存</strong>，留待解答。</p>
</blockquote>
<p>值得注意的是，<strong>npm5中也引入了yarn中的<code>offline-mode</code>特性</strong>，在此之前是不支持离线安装的</p>
<ul>
<li>使用<code>--prefer-offline</code>后将<strong>优先</strong>使用本地缓存</li>
<li>使用<code>--offiline</code>后将<strong>强制</strong>使用本地缓存，若本地缓存中没有请求的包将会报错</li>
</ul>
<h3 id="lock-文件再升级（v7-）">lock 文件再升级（v7+）</h3>
<p>npm-v7中提出了许多现代npm中至关重要的更新，但大多围绕着<strong>更严格的依赖锁定</strong>来开展：</p>
<ul>
<li><strong>提升<code>package-lock.json</code>的语法版本到v2</strong>，提供更确定、更全面的依赖树锁定支持
<ul>
<li>安装时<strong>支持解析<code>yarn.lock</code>文件</strong>，并在更新<code>package.json</code>时同时更新<code>yarn.lock</code></li>
<li><code>package-lock.json</code>仍然会生成，且优先级高于<code>yarn.lock</code>，因为yarn本身不同的版本对<code>yarn.lock</code>有不同的解析策略，而<code>package-lock.json</code>则对项目的确定性构建有决定性的作用（不受npm版本的影响）</li>
<li>在具有 v1 锁文件的项目中使用 npm 7 运行 <code>npm install</code> 会将该锁文件替换为新的 v2 格式。若要避免这种情况，可以运行 <code>npm install --no-save</code></li>
</ul>
</li>
<li><strong>修改<code>peerDependencies</code>的安装逻辑</strong>：当<code>peerDependencies</code>的版本冲突无法解决时，npm将会阻止安装行为（详见<a href="#%E4%B8%8D%E5%90%8C%E7%A7%8D%E7%B1%BB%E4%BE%9D%E8%B5%96%EF%BC%88deps%EF%BC%89%E7%9A%84%E5%BA%94%E7%94%A8">下方</a>）
<ul>
<li>当A和B都在<code>peerDependencies</code>中声明了要和某个版本的C一起使用，但这个版本互不兼容，npm-v7就会阻止安装并抛出错误</li>
<li>如果你使用<code>--legacy-peer-deps</code>选项就会使用之前的安装策略，即仍采用默认的安装顺序去安装依赖，在遇到冲突时只会显示警告而不会阻止安装</li>
</ul>
</li>
<li>官方的<strong>monorepo和workspace支持</strong>（虽然一般不使用npm来管理monorepo）</li>
</ul>
<h2 id="npm如何管理项目">npm如何管理项目</h2>
<p>npm通过根目录下的<code>package.json</code>管理项目，其中定义了当前项目的基本信息（包信息）、自动化脚本和项目依赖，随着npm版本的发展，<code>package.json</code>也变得越来越复杂。</p>
<h3 id="package-json的正确使用姿势"><code>package.json</code>的正确使用姿势</h3>
<p>相信写过一些项目的同学都对package.json不会感到陌生，对其大概的理解就是包含了一些包名、命令脚本和依赖包等信息，处于一个知之但不甚的阶段。如果仅仅是开发简单的项目，调用别人写好的包，自然也不需要深究；但如果你的项目体量较大（或者时间跨度较久），抑或你要发布自己的包，那仔细研究 package.json和npm管理项目的机制就很有必要了。</p>
<p>npm工作机制的变迁在上面的部分已经说得比较清楚了，到了v9这一代，除了依赖管理方案外和其他现代包管理器（yarn2和pnpm）其他已经基本接轨了，在项目管理上也是大同小异，因此主要在npm中介绍了项目管理相关后，<strong>后面的包管理器介绍中就会主要关注其依赖管理机制和对npm的改进</strong>，而不会重复讲述项目管理的知识。</p>
<p>个人看来，package.json中主要说了三件事：</p>
<ul>
<li><strong>别人如何调用我的包</strong></li>
<li><strong>我如何开发自己的包</strong></li>
<li><strong>我引用了别人的哪些包</strong></li>
</ul>
<h4 id="当前包信息">当前包信息</h4>
<p>所谓当前包信息就是“别人如何调用我的包”和“我引用了别人的哪些包”，其中“别人如何调用我的包”代表性的属性如下，指明了当前包发布到npm所需的信息：</p>
<p>需要注意的是，以下信息如果不发布到npm<strong>都是可选的</strong>；如果需要发布到npm则只有<strong>name和version是必须的</strong>。</p>
<ul>
<li><code>name</code>: 当前包名，必须是唯一的
<ul>
<li>可以有作用域，如@org/packageA</li>
<li>不应有大写字母，也不应有URL中不安全的字符</li>
</ul>
</li>
<li><code>version</code>: 版本号，<strong>与name一起构成npm包最重要的两个属性</strong>
<ul>
<li>如果不发布包到npm的话，name和version其实是可选的</li>
<li>遵循semver（语义化版本规范），详见后文</li>
</ul>
</li>
<li><code>description</code>: 描述信息，可选，列在 <code>npm search</code> 中</li>
<li><code>keywords</code>: 关键字，和描述信息一样是可选的，也列在 <code>npm search</code> 中</li>
<li><code>homepage</code>: 项目主页，可选</li>
<li><code>repo</code>: 仓库地址，可选</li>
<li><code>bugs</code>: 反馈bug的地址，接收一个联系方式对象，可选</li>
</ul>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;url&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;https://github.com/owner/project/issues&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;project@hostname.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>license</code>: 开源证书，可选</li>
<li>people fields: 开发者相关，接收<code>author</code>, <code>contributor</code>两个字段，可选</li>
<li><code>files</code>: 决定哪些文件会发布到npm，可选
<ul>
<li>npm会寻找根目录下 .npmignore文件，如果没有就用.gitignore代替，他们不会覆盖files字段</li>
<li>无论如何始终会包含：<code>package.json</code> ，<code>README</code> ，<code>LICENSE</code> ，main字段中的文件</li>
<li>还有一些文件始终被忽略，这里不再列举</li>
</ul>
</li>
<li><code>main</code>: 标识包的入口模块，一般用于Node模块而非浏览器
<ul>
<li><strong>这里前面JS模块化的知识就派上了用场</strong>，在整个模块作为包被引用（import或require）时，<code>main</code>字段标识的文件将作为目标模块被引用（export）</li>
<li>在Node（或者说CJS）中，即main指向的js文件（模块）的exports对象会作为整个包的exports</li>
<li>在ESM中，即外部import的引用会指向main指定的js文件的export标识</li>
</ul>
</li>
<li><code>bin</code>: 告诉npm哪些是可执行文件，<strong>在制作CLI工具时尤为有用</strong>
<ul>
<li>需要在CLI命令相关JS文件第一行添加如下声明告诉系统这个脚本由Node执行：<code>#!/usr/bin/env node</code></li>
<li>声明bin时尽量使用<strong>相对路径</strong>（. 开头）</li>
<li>bin接收一个对象，其键值对格式为 <code>alias: path-to-script</code> ，当值不是对象时只接收<code>path-to-script</code> ，且alias默认是包名（name）</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-program&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.2.5&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;bin&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;my-program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./path/to/program&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>
<h4 id="依赖包信息">依赖包信息</h4>
<p>虽然“我引用了别人的哪些包”严格来说也是<strong>当前包信息</strong>的一部分，但由于当前包信息只在发布npm包时才有作用，而依赖包在任何项目管理中都会出现，且其复杂度要更高一些，因此这里单独拿一部分来讨论。</p>
<p>一般来说，项目的依赖（dependencies）在npm中被分为了以下几类：</p>
<ul>
<li><code>dependencies</code>：无论开发环境还是生成环境都需要依赖的包，通常是一些库模块（如<code>axios</code>,<code>dayjs</code>等），可以使用<code>npm i &lt;pkg&gt; --save</code>在安装包时就记录下来（实际上安装任何包时都会默认记录到<code>dependencies</code>中）</li>
<li><code>devDependencies</code>：在开发时需要，生产环境中需要的包，通常是一些打包器（如<code>webpack</code>）和转译器（如<code>ts-node</code>），可以使用<code>npm i &lt;pkg&gt; --save-dev</code>来保存到这个part中</li>
<li><code>optionalDependencies</code>：表示这个包是可选的，<strong>如果安装失败不会终止安装过程</strong>，但需要在应用程序中做相应处理（否则会产生找不到模块的报错），可以使用<code>--save-optional</code>或<code>-O</code>来添加</li>
<li><code>peerDependencies</code>: 表示工程需要和这个依赖（的指定版本）配套使用，<strong>一般用于插件开发</strong>而非项目开发，是为了解决本项目作为包被引入的时候与主项目（或其他依赖）依赖版本冲突的问题（如<code>vuex@4.1.0</code>表明了自己需要<code>vue@^3.2.0</code>配套使用），可以使用<code>-P</code>选项来添加。</li>
<li><code>bundleDependencies</code>：表示工程<strong>在发布时会携带这些modules</strong>，而不是每次使用插件时都需要重新使用<code>npm install</code>下载一遍，可以使用<code>--save-bundled</code>或<code>-B</code>来添加</li>
</ul>
<h5 id="SemVer-规范">SemVer 规范</h5>
<p>在继续讨论依赖管理之前，我们先了解一下npm和其他很多包管理器（项目管理）都采用的版本管理规范：<strong>SemVer（SEMantic VERsioning，语义化版本规范）命名规范</strong>。</p>
<p>不仅你在调用别人的包时需要考虑semver来划定版本范围，在你开发自己的包时也要根据semver来更新版本号。</p>
<p>semver一般由以下四部分组成：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230605193403.png"
                      alt=""
                ></p>
<ul>
<li><code>major</code>位：发生了<strong>无法向下兼容的API修改</strong></li>
<li><code>minor</code>位：<strong>新增了向下兼容的功能</strong></li>
<li><code>patch</code>位：做了<strong>向下兼容的问题修复</strong></li>
<li><code>tags</code>标签：用于<strong>标记某些先行版本</strong>（pre-releases），如<code>alpha.1</code>, <code>beta.2</code>等</li>
</ul>
<p>遵照semver规范，合法的版本命名有：<code>2.1.0</code>, <code>3.1.4-beta.2</code>等</p>
<blockquote>
<p>如果遵照conventinal commit规范，许多工具都可以根据Git Log中的commit messages自动生成CHANGELOG和更新版本号，如lerna这样的monorepo管理工具。详见我的另一篇博客：</p>
</blockquote>
<p>在使用他人的包时，我们也可以使用<code>~, &gt;, &lt;, =, &gt;=, &lt;=, -, ||, x, X, *</code>等符号来锁定和描述版本，以下是常用符号说明。</p>
<ul>
<li><code>^</code>是缺省时的默认情况，表示只锁定<code>major</code>，<code>minor</code>和<code>patch</code>取最新版本</li>
<li><code>~</code>表示锁定<code>major</code>和<code>minor</code>，<code>patch</code>取最新版本</li>
<li><code>=</code>表示锁定全部版本</li>
<li><code>&gt;=</code>表示指定一个最低版本，尽可能取最新版本</li>
<li><code>x, X, *</code>表示通配符，如<code>3.4.*</code></li>
</ul>
<h5 id="不同种类依赖（deps）的应用">不同种类依赖（deps）的应用</h5>
<p>一般来说一般的网页开发中比较常用的就是<code>dependencies</code>和<code>devDependencies</code>，区别在上面也说的比较清楚了。</p>
<p>下面就是一份比较简单的<code>dependencies</code>声明（摘自Vite+React的练手项目），可以看到除了运行时需要用到的库都被放在了<code>devDependencies</code>中，比较典型的有代码格式化工具（ESLint）、TypeScript相关工具还有打包器（如Vite）。</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;axios&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.4.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^18.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;react-dom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^18.2.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@types/react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^18.0.37&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@types/react-dom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^18.0.11&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@typescript-eslint/eslint-plugin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.59.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@typescript-eslint/parser&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.59.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@vitejs/plugin-react-swc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eslint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^8.38.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eslint-plugin-react-hooks&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.6.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eslint-plugin-react-refresh&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.3.4&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;typescript&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.0.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vite&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.3.9&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>
<p>这里说一个不太重点的冷知识：<strong>CRA（create-react-app）会默认把所有依赖都一股脑安装到dependencies里，而不会区分devDependencies</strong>，这是为什么呢？</p>
<p>大家不妨想一想一个CRA网页应用的构建过程：安装依赖→调用依赖→通过Webpack打包和发布网页。</p>
<p>这个过程全程是不是除了依赖管理没有关系，应用也不会发布到npm中，别的应用也不会调用这个包，发布是靠的webpack依赖解析和tree-shaking生成目标JS文件，而如果你要跑这个网页又一定需要安装所有的依赖，因此其实这种不会发布的项目区分<code>devDpendencies</code>的意义不大，只能算一个良好习惯，当然无论如何还是希望能保持一个良好的习惯（毕竟Vite是默认区分了的）。</p>
<p>其他的依赖类型中，<code>bundleDependencies</code>和<code>optionalDependencies</code>在日常开发中几乎不使用，而<code>peerDependencies</code> 则多用于版本冲突问题的解决。</p>
<ul>
<li>在npm-v2版本中就引入了<code>peerDependencies</code> 字段，但其含义与现在完全不同，而是更贴近原意“对等依赖”，即安装的这些依赖和我是<strong>平级的而不是我的子模块</strong>，表达的是：“<strong>如果你安装我，那么你最好也安装X,Y和Z</strong>”
<ul>
<li>由于v2中是嵌套依赖结构，依赖的依赖会放在对应的目录中，而不是扁平的node_modules中</li>
<li>声明在<code>peerDependencies</code> 中的包会安装在根目录而非当前包的依赖目录中</li>
</ul>
</li>
<li>npm-v3版本改变了依赖组织的形式，变成了扁平依赖项模式，这样就使得v2的<code>peerDependencies</code>字段显得毫无用处，但扁平依赖又有依赖树版本不确定的问题，因此npm又为它赋予了新的含义：“<strong>我需要这个版本的X，构建完成后请检查一下版本对不对</strong>”
<ul>
<li><code>peerDependencies</code>声明的依赖并<strong>不会被安装，而仅仅是在安装过程结束后检查是否安装正确</strong></li>
<li>如果<code>peerDependencies</code> 没有被正确安装，仅仅会<strong>发出警告</strong>，而<strong>不会中止安装</strong></li>
<li>从语义上来说，这个版本的peerDependencies更像是“<strong>默认使用者使用此包就一定会安装的那些其他包</strong>”，如redux包就可以默认使用者一定安装了react，vuex就可以默认一定安装了vue@^2.0.0</li>
<li>理解了<code>peerDependencies</code>只是一个检查，而不是安装，就可以理解其他所有dependencies的优先级都高于<code>peerDependencies</code>和可以重复声明的原因了</li>
</ul>
</li>
<li>在npm-v7中，peerDependencies的语义被再次增强，它仍表示那些<strong>默认使用者已经安装的包</strong>，但<strong>当包没有被正确安装时会报错并终止安装</strong>，这导致了许多项目在v7以后产生无法安装的错误，使用<code>—legacy-peer-deps</code>即可回退到v6以前的安装模式</li>
</ul>
<h4 id="项目管理信息">项目管理信息</h4>
<p>所谓的项目管理信息就是“<strong>我如何开发自己的包</strong>”，这其中主要就是使用<code>scripts</code>字段去定义一些脚本（命令组合），快速地对项目进行调试、打包等操作，使用<code>npm run &lt;script&gt;</code>或者对于某些特殊脚本直接<code>npm &lt;script&gt;</code>即可运行对应脚本。</p>
<p>使用<code>scripts</code>定义脚本比直接运行有以下优势：</p>
<ul>
<li><code>scripts</code>脚本往往更加简洁，一个单词就可以让npm为你执行一大串指令</li>
<li><code>scripts</code>脚本往往遵循某些约定俗成的规范，可以让不同项目保持一致性，如<code>start</code>, <code>dev</code>, <code>build</code>等</li>
<li>使用<code>scripts</code>脚本可以更方便地封装行为，保持项目跨平台的可运行</li>
<li>使用<code>scripts</code>脚本可以直接使用对应包管理器调用相应包并执行对应指令，而不用手动定义包管理器PATH和启动行为</li>
</ul>
<blockquote>
<p>这里涉及到了一些npm-CLI相关知识，在后文会详细提到。</p>
</blockquote>
<p>npm scripts是强大且自由的，它可以组合和定义你能想到的几乎任何功能。它的原理很简单，npm在每次执行脚本时会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令，且<strong>在新建过程中会把 <code>./node_modules/.bin</code> 加入环境变量</strong>（这也是为什么它可以直接使用对应包管理器调用相应包）</p>
<p>一个普通前端项目一般会包括以下脚本：</p>
<ul>
<li>start：启动脚本，可以直接使用<code>npm start</code>调用</li>
<li>dev：开发环境脚本，一般在不区分生产环境时与start相同（就不重复创建），区分开发环境时则多用于本地环境</li>
<li>test：测试脚本</li>
<li>lint：代码检查脚本，可以添加后缀如<code>lint:es</code> 或 <code>lint:prettier</code></li>
</ul>
<p>除了上述的基础脚本外，npm还提供了一些<strong>基于生命周期Hooks的脚本</strong>，使用<code>pre*</code>或<code>post*</code>前缀定义，如<code>postinstall</code> ，会在对应生命周期的前/后自动执行。npm默认提供以下Hooks：</p>
<ul>
<li>prepublish，postpublish</li>
<li>preinstall，postinstall</li>
<li>preuninstall，postuninstall</li>
<li>preversion，postversion</li>
<li>pretest，posttest</li>
<li>prestop，poststop</li>
<li>prestart，poststart</li>
<li>prerestart，postrestart</li>
</ul>
<blockquote>
<p>需要注意的是，<strong>自定义脚本也支持添加Hooks</strong>。</p>
</blockquote>
<h3 id="npm-CLI">npm-CLI</h3>
<p>npm除了在package.json中记录了项目相关的信息，还提供了一系列CLI命令来帮助我们管理项目，自动化包管理流程，在上面的内容或日常使用中我们已经接触到了一些命令，如 <code>npm install</code>, <code>npm start</code>等。</p>
<p>由于npm-CLI实际上是一个比较繁杂的系统，一次性讲完既不现实，也没有必要，这里更推荐的是遇到需求或问题再去文档中查找相关内容。对应地，这里仅仅介绍我日常开发中常用的一些指令：</p>
<ul>
<li><code>npm install</code>：安装所有依赖</li>
<li><code>npm install &lt;pkg&gt;</code>/<code>npm i &lt;pkg&gt;</code>：安装指定包</li>
<li><code>npm uninstall &lt;pkg&gt;</code>：删除包</li>
<li><code>npm run &lt;script&gt;</code>：运行指定指令（<code>npm start</code>和<code>npm test</code>不需要<code>run</code>）</li>
<li><code>npm cache clean</code>：清除下载缓存</li>
</ul>
<h4 id="npm-link的使用"><code>npm link</code>的使用</h4>
<p><code>npm link</code>的本质是创建一个<strong>软链接</strong>，用于将本地的包添加到另一个项目中，多用于开发中的包的调试。</p>
<p>工作原理是：将其链接到全局node模块安装路径中。为目标npm模块的可执行bin文件创建软连接，将其连接到全局node命令安装路径中。</p>
<ol>
<li>在需要调试的项目（正在开发的插件）中运行<code>npm link</code>，将当前包链接到全局</li>
<li>在调试环境中运行<code>npm link &lt;pkg-name&gt;</code>来创建到指定包的软链接</li>
</ol>
<h4 id="npx指令"><code>npx</code>指令</h4>
<p>设想一个场景，比如你要使用 webpack 来打包，你一般有两个选择：</p>
<ul>
<li>全局安装 webpack，直接使用命令行 <code>webpack</code> 直接调用，但这样需要手动更新版本，且不同项目使用同一个版本可能出现冲突和兼容性问题</li>
<li>使用本地 webpack，就需要 <code>./node_modules/@webpack-cli/xxx</code> 这样的格式，很是麻烦</li>
</ul>
<p>npx 想要解决的主要问题，就是<strong>调用项目内部安装的模块</strong>，<strong>避免全局安装模块</strong>。</p>
<p>使用 npx 后，再调用 webpack 就可以使用下面的格式</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npx webpack run</span></span><br></pre></td></tr></table></figure></div>
<p>npx 的原理很简单，就是运行的时候，会到<code>node_modules/.bin</code>路径和环境变量<code>$PATH</code>里面，检查命令是否存在。</p>
<p>由于 npx 会检查环境变量<code>$PATH</code>，所以系统命令也可以调用。</p>
<blockquote>
<p>这里有个小技巧，如果你使用yarn或pnpm，在<code>scripts</code>中写<code>npx &lt;cmd&gt;</code>就会使用全局npm去执行这条指令。</p>
</blockquote>
<h3 id="npm配置">npm配置</h3>
<p>上面都一直在讲npm如何配置项目，这里也讲讲npm本身应该如何配置。</p>
<p>npm的默认配置文件是<code>.npmrc</code>，在<code>~/.npmrc</code>默认有一份用户配置文件，所有项目共享。在运行npm时项目中<code>.npmrc</code>的覆盖优先级高于用户默认值（普通的系统环境变量逻辑）。</p>
<p>使用<code>npm config</code>命令可以读取当前环境下的npm配置文件，我这里没有给项目单独配置<code>.npmrc</code>，因此得到的是全局配置文件（<s>忽略我的7890</s>）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230605201247.png"
                      alt=""
                ></p>
<p>修改配置文件常用的方法有：</p>
<ul>
<li>使用<code>npm config edit</code>可以直接编辑用户配置文件</li>
<li>在项目根目录创建<code>.npmrc</code>也可以直接覆写设置</li>
<li>使用<code>npm config set &lt;item&gt; &lt;value&gt;</code>修改单项配置</li>
</ul>
<p>常用的配置项有：</p>
<ul>
<li><code>proxy</code>: 代理设置，所有请求都将通过代理请求</li>
<li><code>registry</code>：镜像源设置，替代默认的npm源（详见：<a class="link"   href="https://npmmirror.com/" >npmmirror 镜像站 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）</li>
</ul>
<blockquote>
<p>说到这里就不得不提到一个Z国特色产品：<strong>cnpm</strong>，具体功能就是默认将镜像源替换为淘宝源。</p>
<p>虽然免费为国内维护一个高频更新的镜像源确实是功德一件，但个人觉得使用一个没有任何技术特色的包管理器去替代npm实在是没有必要的，如果一定要使用镜像源我个人建议使用<code>registry</code>设置而不是安装cnpm。或者说，我个人更推荐7890方案，如果你还不能精通网络建议重修计网。</p>
</blockquote>
<h3 id="发布自己的第一个npm包">发布自己的第一个npm包</h3>
<p>最好的学习就是实践，不要认为发布npm包是一个很有门槛的事，这是一个开源、自由的仓库，每个人都可以在上面发布自己的代码。</p>
<p>下面，我们就从0开始使用npm开发一个自己的NodeJS工具库，并发布到npm中。</p>
<p>它的第一个功能就是<strong>检测一个用户是否在本地JSON数据库中注册</strong>：</p>
<ul>
<li>如果已经注册则返回true，未注册则返回false并添加该用户</li>
<li>提供用于添加和删除/清空用户的接口</li>
</ul>
<p>首先，我们需要在<a class="link"   href="https://www.npmjs.com/" >npm官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>注册一个账号，验证邮箱并开启2FA，这些过程就不再赘述。</p>
<ol>
<li>创建一个目录，运行<code>npm init</code>命令，这里推荐命名为<code>yourname-utils</code>（将yourname替换为你的名字，注意为英文）</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230605232049.png"
                      alt=""
                ></p>
<ol start="2">
<li>初始化完成后会生成一个<code>package.json</code>，除此之外没有别的文件。此时输入<code>git init</code>初始化Git仓库，然后初始化提交。</li>
<li>编写简单的代码来实现功能：分为入口<code>index.js</code>和功能<code>myDb.js</code></li>
</ol>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// myDb.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> filePath = <span class="string">&#x27;./myDb.json&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!name) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;name is required&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> name !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;name must be a string&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!fs.<span class="title function_">existsSync</span>(filePath)) &#123;</span><br><span class="line">    <span class="keyword">const</span> obj = [name]</span><br><span class="line">    fs.<span class="title function_">writeFileSync</span>(filePath, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> data = fs.<span class="title function_">readFileSync</span>(filePath, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(data)</span><br><span class="line">  <span class="keyword">if</span> (obj.<span class="title function_">includes</span>(name)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  obj.<span class="title function_">push</span>(name)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">remove</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!name) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;name is required&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> name !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;name must be a string&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!fs.<span class="title function_">existsSync</span>(filePath)) &#123;</span><br><span class="line">    fs.<span class="title function_">writeFileSync</span>(filePath, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>([]))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> data = fs.<span class="title function_">readFileSync</span>(filePath, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(data)</span><br><span class="line">  <span class="keyword">const</span> result = obj.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item !== name)</span><br><span class="line">  fs.<span class="title function_">writeFileSync</span>(filePath, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(result))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (fs.<span class="title function_">existsSync</span>(filePath)) &#123;</span><br><span class="line">    fs.<span class="title function_">removeSync</span>(filePath)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  check,</span><br><span class="line">  remove,</span><br><span class="line">  clear</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">&#x27;./myDb.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">db</span> = db;</span><br></pre></td></tr></table></figure></div>
<ol start="4">
<li>按照上述流程再创建一个项目用于测试，先在原项目运行<code>npm link</code>，再在测试环境中运行<code>npm link yourname-utils</code>创建软链接</li>
<li>在测试环境中编写<code>index.js</code></li>
</ol>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; db &#125; = <span class="built_in">require</span>(<span class="string">&#x27;@kiritoking/my-utils&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = db.<span class="title function_">check</span>(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> b = db.<span class="title function_">check</span>(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b) <span class="comment">// false, true</span></span><br></pre></td></tr></table></figure></div>
<ol start="6">
<li>运行<code>node index.js</code>，输出如下，并在根目录创建了<code>myDb.json</code></li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230605234136.png"
                      alt=""
                ></p>
<ol start="7">
<li>
<p>本地测试通过，现在来上传npm包，就两步，非常简单</p>
<ol>
<li><code>npm login</code>登录npm（注意这一步必须是<strong>官方源</strong>），会打开浏览器来登录</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230605234328.png"
                      alt=""
                ></p>
<ol start="2">
<li>
<p>直接运行<code>npm publish</code>就可以发布该包的当前版本，仍需要打开浏览器认证</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230605234741.png"
                      alt=""
                ></p>
</li>
</ol>
</li>
<li>
<p>在测试环境运行<code>npm unlink yourname-utils</code>取消软连接，运行<code>npm install yourname-utils</code>从在线安装，再次运行表示成功</p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230605234843.png"
                      alt=""
                ></p>
<h2 id="npm的没落">npm的没落</h2>
<p>在2023年的前端圈，陪我们走过10多年的npm已经垂垂老矣（2010年1月12日发布），逐渐退出历史舞台，越来越多的后起之秀起了替代它的势头。但npm仍是那座历史上的高峰，可以说没有npm就没有前端圈的繁荣，它是这个庞大帝国的基石。</p>
<p>即使有一天，npm已经不再任何场合被推荐使用，它的思想、它的概念仍会在其他包管理器、所有开发者的实践中不断传扬，因此，在2023年的今天，学习npm的历史和思想仍是值得的，这让我们知道为什么会有后面的解决方案，这些解决方案改进了哪些方面，我们才能对项目的工程化有更深刻的认识。就像学习C语言一样，时至今日你可能并不会用大一学习的C语言去开发实用程序，但它教给你的计算机思维将一直伴随你的开发。</p>
<h3 id="更现代的新兵：yarn2和pnpm">更现代的新兵：yarn2和pnpm</h3>
<p>尽管npm在迭代中解决了重复依赖、依赖树不确定等诸多问题，但扁平依赖的结构一定是最优解吗？诸如幽灵依赖、难以删除等问题仍萦绕在npm上空。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202304270103999.jpg"
                      alt=""
                ></p>
<p><strong>yarn2</strong>提出了PnP（Plug’and’Play，即插即用）结构，直接抛弃了庞大的<code>node_modules</code>目录；<strong>pnpm</strong>重新搬出了新的<strong>嵌套目录+硬链接</strong>结构，解决了”幽灵依赖“（项目可以引用自身没有声明的间接依赖）的问题，提高了速度。</p>
<p>这些解决方案将在后面的系列文章中详细解析，它们的出现都撼动了npm的地位。<strong>时至2023的今日，它们都是比npm更好的启动新项目的选择</strong>，越来越多的项目也选择了拥抱新技术栈和新特性。</p>
<h3 id="corepack-面向未来">corepack: 面向未来</h3>
<blockquote>
<p>官方介绍来自：<a class="link"   href="https://github.com/nodejs/corepack" >nodejs/corepack (github.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>Corepack is a zero-runtime-dependency Node.js script that acts as a bridge between Node.js projects and the package managers they are intended to be used with during development. In practical terms, <strong>Corepack will let you use Yarn and pnpm without having to install them</strong> - just like what currently happens with npm, which is shipped by Node.js by default.</p>
</blockquote>
<p>Corepack是一个<strong>实验性工具</strong>，在 Node.js v16.13 版本中引入，它可以<strong>指定项目使用的包管理器以及版本</strong>。</p>
<p>简单来说，Corepack 会成为 Node.js 官方的内置 CLI，用来管理『包管理工具（yarn、pnpm）』，在管理 Packges 时会直接调用 Corepack 指定的包管理器进行管理，即『<strong>包管理器的管理器</strong>』。</p>
<p>新版的 pnpm 和 yarn 文档中，都推荐使用 corepack 来安装和管理包管理器，而非全局方式。</p>
<p>需要注意的是：<strong>corepack 仅支持yarn和pnpm，并不支持cnpm</strong>。</p>
<h4 id="安装并启用-corepack">安装并启用 corepack</h4>
<p>由于 Corepack 是实验性工具，它并不是默认启动的，需要手动开启，开启后全局有效</p>
<ul>
<li>对于16.13+版本：直接运行<code>sudo corepack enable</code>（需要管理员/root权限）</li>
<li>对于更低版本：需要手动安装
<ul>
<li>首先，需要<strong>卸载已经全局安装的yarn和pnpm</strong></li>
<li>然后，<strong>全局安装 corepack</strong>：<code>npm i -g corepack</code></li>
</ul>
</li>
</ul>
<h4 id="使用-corepack">使用 corepack</h4>
<ul>
<li>可以直接使用<code>yarn</code>、<code>pnpm</code>来进行安装而无需任何配置
<ul>
<li>若指令与项目指定的包管理器符合，<code>corepack</code>会静默下载对应的包管理器并执行你的指令</li>
<li>若指令与项目指定的包管理器不一致，<code>corepack</code>会拒绝你的指令</li>
<li>若本地未配置包管理器，<code>corepack</code>会下载对应的 <em>good-release</em> 版本的包管理器并执行你的指令</li>
</ul>
</li>
<li>需要注意的是，corepack 目前还<strong>不支持屏蔽 npm</strong>（也就是说你无论你的包管理器指定的是什么，都能运行npm），但<strong>node在后续版本中计划逐渐去除 npm集成，改用corepack作为默认的包管理器</strong>，放弃npm的太子地位</li>
<li>可以在<code>package.json</code>中指定 <code>packageManager</code> 字段来指定包管理器，值按<code>packageManager@x.y.z</code>格式编排，后面<strong>可选</strong>地附加一个Hash值来确认安全下载，下面的代码就指定了Yarn 3.2.3版本作为包管理器：</li>
</ul>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;packageManager&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yarn@3.2.3+sha224.953c8233f7a92884eee2de69a1b92d1f2ec1655e66d08071ba9a02fa&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>可以使用 <code>corepack prepare packageManager@x.y.z</code> 来<strong>下载并安装某个版本的包管理器</strong>，也可以<strong>直接使用<code>latest</code>下载最新版</strong>；增加 <code>--activate</code> 选项可以将当前下载的版本作为 corepack 的 best-release 版本。
<ul>
<li>这个操作可以替代 <code>npm i &lt;package&gt; -g</code></li>
<li>比如 <code>corepack prepare yarn@latest</code> 就会全局安装最新版yarn，所以我电脑上现在的全局yarn版本就是v3.5.1，pnpm是v8.4.0</li>
</ul>
</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/25489604" >JS全局变量污染和模块化 - 知乎 (zhihu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.cnblogs.com/echoyya/p/14577243.html" >一文彻底搞懂JS前端5大模块化规范及其区别 - Echoyya、 - 博客园 (cnblogs.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.cnblogs.com/leegent/p/7244660.html" >前端十万个为什么(之一)：我们为什么需要npm？ - 大唐西域都护 - 博客园 (cnblogs.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://es6.ruanyifeng.com/#docs/module-loader#ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82" >Module 的加载实现 - ECMAScript 6入门 (ruanyifeng.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://segmentfault.com/a/1190000041396029" >javascript - 深入浅出 ESM 模块 和 CommonJS 模块 - 个人文章 - SegmentFault 思否 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/6844903861166014478" >commonjs 与 esm 的区别 - 掘金 (juejin.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/7098261507040870430" >CommonJS规范详解 - 掘金 (juejin.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://javascript.ruanyifeng.com/nodejs/module.html" >CommonJS规范 – JavaScript 标准参考教程（alpha） (ruanyifeng.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/25916585" >Node.js CommonJS 实现与模块的作用域 - 知乎 (zhihu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>[<a class="link"   href="https://juejin.cn/post/6844903682283143181" >译] 理解 JavaScript 中的执行上下文和执行栈 - 掘金 (juejin.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://docs.npmjs.com/cli/v9/configuring-npm/package-json?v=true#peerdependencies" >package.json | npm Docs <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.cnblogs.com/wonyun/p/9692476.html" >探讨npm依赖管理之peerDependencies - wonyun - 博客园 (cnblogs.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" >npm scripts 使用指南 - 阮一峰的网络日志 (ruanyifeng.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/7039140144250617887" >超详细 如何发布自己的 npm 包 - 掘金 (juejin.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://segmentfault.com/a/1190000040075935" >npm link 基本使用 - 个人文章 - SegmentFault 思否 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端工具链</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>包管理</tag>
        <tag>工具链</tag>
        <tag>commonjs</tag>
        <tag>esm</tag>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端工具链之包管理器 - pnpm</title>
    <url>/posts/3752592171/</url>
    <content><![CDATA[<p>pnpm（performant npm）是一个主打<strong>快速和省空间</strong>的包管理器。它使用<strong>改进的非扁平node_modules目录</strong>和<strong>硬链接和符号链接</strong>优化依赖管理过程，个人体验下来比起yarn-v2的PnP机制会遇到的兼容性问题更少，<strong>是我现阶段最喜欢的包管理器</strong>。</p>
<span id="more"></span>
<blockquote>
<p>如果对npm和yarn-v2没有了解，建议先去按顺序看对应的那两篇文章，会更好地理解这里地一些概念。</p>
</blockquote>
<p>既然自称perfomant，就需要跑分作为证据。下图为pnpm对比各包管理器（npm-v9,yarn-PnP）的性能对比图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305050100867.png"
                      alt=""
                ></p>
<ul>
<li>可以看出，pnpm采用node_modules的曲线救国方案<strong>并不是全方位领先的</strong></li>
<li>在<strong>有cache</strong>的情况下的安装，pnpm由于<strong>硬链接</strong>机制避免了I/O操作，有较大的领先幅度</li>
<li>在<strong>没有lockfile</strong>的情况下，yarn和pnpm由于都需要且依赖于lockfile，要先构建lockfile，因此速度较慢</li>
<li>在<strong>不需要node_modules</strong>的情况下，<strong>PnP在大部分情况下都遥遥领先</strong>（兼容性换的）</li>
</ul>
<blockquote>
<p>总得来说，<strong>pnpm是兼容性、性能和空间三者一个较好的平衡方案</strong>。</p>
</blockquote>
<h2 id="如何安装pnpm">如何安装pnpm</h2>
<p>根据pnpm官方的指导，和yarn2一样，都建议使用node内置的corepack工具安装pnpm。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">corepack prepare pnpm@latest --activate</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pnpm -v</span></span><br></pre></td></tr></table></figure></div>
<p>如果安装成功，可以看到pnpm版本如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230608233749.png"
                      alt=""
                ></p>
<h2 id="pnpm如何改进npm">pnpm如何改进npm</h2>
<p>首先，个人觉得pnpm走上了和yarn2不同的一条路，它们<strong>都从npm/classic-yarn出发，尝试从不同方向、用不同方案去改进依赖管理的体验和性能</strong>。最终，yarn选择了完全开辟一条新的路子（PnP），而pnpm选择了在原有架构（node_modules）上进行修补和改进，具体一点就是它们都用自己的方法解决了原有方案的问题，如<strong>幽灵依赖和依赖冲突</strong>（这两点是你可以在博客中重点体会二者解决方案差异的点）。</p>
<p>因此，这里<strong>主要讨论的是pnpm相对于npm/classic-yarn的改进，而不是和yarn2的对比</strong>。然而，PnP和pnpm的普及率似乎昭告了pnpm是暂时成功的那一个。</p>
<h3 id="pnpm安装依赖的过程">pnpm安装依赖的过程</h3>
<p>pnpm安装依赖项（以<code>pnpm install</code>为例）一般分为三步：</p>
<ol>
<li>解析（resolve&amp;fetch）：解析当前项目需要哪些依赖，应该从哪些地方获取，依赖又依赖了哪些依赖等等，如果本地缓存没有就从远程仓库下载，和其他包管理器行为一致（也会调用和生成lockfile）</li>
<li>目录结构计算：<strong>根据解析依赖的结果生成node_modules结构</strong>，具体结构如下文阐述</li>
<li>链接依赖项：将node_modules中的依赖通过<strong>硬链接</strong>的方式链接到<strong>全局缓存</strong>中，节约磁盘空间</li>
</ol>
<p>值得注意的是，在pnpm中这三个阶段是在多任务上并行的（类似于CPU的动态流水线），可以节约大量时间，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230608215546.png"
                      alt=""
                ></p>
<p>以上这三个阶段将在后文反复地被提到，请一定在脑子里有个大致的印象。</p>
<h3 id="非扁平的node-modules">非扁平的node_modules</h3>
<p>使用 npm 或 Yarn Classic 安装依赖项时，所有的包都被提升到模块目录的根目录。 这样就导致了一个问题 —— <strong>幽灵依赖</strong>，源码可以直接访问和修改依赖，而不是作为只读的项目依赖。</p>
<p>pnpm 的解决方案是<strong>使用符号链接将项目的直接依赖项添加到模块目录的根目录中</strong>。说起来有点拗口，实际上就是你的node_modules根目录中不再将所有的次级依赖平铺出来，而是只有你当前项目的<strong>直接依赖</strong>。</p>
<p>这样做的好处是显而易见的——<strong>解决了“幽灵依赖”问题</strong>。但是你先别急，pnpm和npm-v2的解决方案可不一样，它没有傻傻地嵌套安装所有所需的依赖，而是通过一些特殊的目录结构加上<strong>符号链接</strong>将嵌套的层数控制在了两层（一个可接受的范围内）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202304270054060.jpeg"
                      alt=""
                ></p>
<p>那么它链接到了哪里呢？答案是<code>node_modules/.pnpm/&lt;name&gt;@&lt;version&gt;/node_modules/&lt;name&gt;</code>，所有的包<strong>真正的存储目录是.pnpm中对应文件夹的node_modules下的对应名称文件夹</strong>（有点拗口）。</p>
<p>你或许也注意到了，包本身存放的地方并没有在<code>&lt;name&gt;@&lt;version&gt;</code>根目录下，而是在其node_modules中和其他依赖并列存放，这是为什么呢？</p>
<ul>
<li><strong>不像PnP，pnpm并没有改动node的包解析模式</strong>（依然是层层遍历目录的模式），因此依赖是在包的内部 <code>node_modules</code> 中或在任何其它在父目录 <code>node_modules</code> 中是没有区别的。</li>
<li>由于node会自动向上查询，因此包本身及其依赖的包被放置在一个文件夹下可以优化查询和解析过程（只包含它依赖的包）</li>
<li>这样的结构（名称@版本）可以兼容同一依赖的不同版本，顺带<strong>解决了依赖冲突的问题</strong></li>
</ul>
<p>pnpm在实际管理包的物理存储时仍采用了<strong>平铺管理</strong>的模式：<strong>在.pnpm中的所有包都是平铺的</strong>，但是因为外部访问不到所以没有关系。</p>
<p>但这还不是全部，因为.pnpm中仍然有链接的存在：假想我们有一个包A，它依赖了B和C，那么<strong>在<code>.pnpm/A/node_modules</code>中就也有符号链接形式的B和C，指向.pnpm目录下真正的B和C</strong>。</p>
<p>以上就是pnpm的非扁平目录的全部真相了，虽然乍一看这种嵌套的node_modules会有点奇怪，但它也有些好处：</p>
<ul>
<li>首先就是<strong>你在使用的时候其实完全不用关心它如何维护node_modules</strong></li>
<li>它解决了幽灵依赖问题，也使用软链接解决了重复安装依赖的问题</li>
<li><strong>比起PnP，它更能完美地兼容Node生态</strong>，因为node在解析包时会自动忽略符号链接，解析到真正的地址上</li>
<li>不管依赖的深度和数量如何变化，pnpm将始终维持这样至多两层的嵌套结构</li>
</ul>
<blockquote>
<p>总结：pnpm使用了<strong>表层嵌套+底层平铺</strong>的方法组织目录结构，同时用<strong>符号链接</strong>作为技术实现，这样既<strong>解决了“幽灵依赖”问题</strong>，又<strong>维持了两层嵌套结构的稳定性</strong>，是非常巧妙的设计。</p>
</blockquote>
<p>现在，我们在实践中看看pnpm的node_modules结构。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir pnpm-test</span><br><span class="line">cd pnpm-test</span><br><span class="line">pnpm init</span><br><span class="line">pnpm add express</span><br></pre></td></tr></table></figure></div>
<p>打开node_modules看看：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230608222545.png"
                      alt=""
                ></p>
<p>可以看到express确实以符号链接（在Windows中以junction的方式实现）的形式存在在根目录，且没有其他的间接依赖存在。</p>
<p>其中<code>.modules.yaml</code>里面存放着间接依赖的列表，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230608222811.png"
                      alt=""
                ></p>
<p>双击express，我们就进入了真正的存放目录（但上方的路径并没有变化），因此为了观察真正的目录结构我们需要进入.pnpm中，发现这里的包确实都是平铺的，且与<code>.modules.yaml</code>中的顺序是对应的：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230608223057.png"
                      alt=""
                ></p>
<p>我们找到express，打开其目录只有一个node_modules，进入这个node_modules，我们可以看到和前面的叙述一致：<strong>所有间接依赖以符号链接的形式放在node_modules中供调用，其本体也存储在这个node_modules/express目录中</strong>。</p>
<p>这里补充解释一下前面说的“包本身及其依赖的包被放置在一个文件夹下可以优化查询和解析过程”就是指它本体存储中其实不含有node_modules（比如这里node_modules/express中就不再有node_modules），因此根据node规则就会自动向上一级目录的node_modules中寻找依赖，这里全是它自己的依赖而不像.pnpm中有全部的依赖，就减小了查找范围，优化了性能。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230608223207.png"
                      alt=""
                ></p>
<h4 id="如何处理peerDeps">如何处理peerDeps</h4>
<p>由于非扁平结构和链接特性，pnpm 中任何一个包都拥有自己的一组确定版本的依赖项，而不会像扁平依赖中受到其他包的影响。但在处理<code>peerDependencies</code>时是一个例外：<strong>peer 依赖项（peer dependencies）会从依赖图中更高的已安装的依赖项中解析（resolve），因为它们与父级共享相同的版本</strong>。</p>
<h4 id="Windows中的符号链接">Windows中的符号链接</h4>
<p>Windows直至Vista（NT6）之前都完全不支持符号链接（symbolic link），后面的符号链接不能说不能用，只能说有问题。因此pnpm采用了junction方式（类似于快捷方式）来在Windows上实现符号链接的功能。</p>
<h3 id="硬链接">硬链接</h3>
<p>看了上面的介绍后，你内心可能还有个疑问：就这？说好的省空间呢？这只是把依赖用软链接组织起来了呀，.pnpm中该装的依赖铺平了不是一个不少吗？</p>
<p>别急别急，马上就介绍pnpm降低硬盘占用的杀手锏：<strong>硬链接机制 —— 让所有的包都只存一份</strong>！</p>
<p>实际上在上面提到的“本体”（如node_modules/express中存放的实际文件）都是<strong>硬链接（hard link）</strong>，<strong>指向根目录（Windows下就是当前盘符根目录）中的.pnpm-store</strong>这个目录。</p>
<blockquote>
<p>以Linux为例，硬链接（hard link）实际上就是指硬链接的n个文件有完全相同的inode结点；而软链接/符号链接则是指两个文件有不同的inode结点，一份为本体，一份为引用（即inode结点中存放的是指向另一份文件的指针）。</p>
</blockquote>
<p>上面的指向图中其实已经能看出硬链接的过程，但下面这张图更清晰地反映了引入硬链接后整个node_modules的实际引用箭头：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305050106556.png"
                      alt=""
                ></p>
<ul>
<li>可以看出，按照非扁平结构，node_modules中只有直接依赖，.pnpm中平铺摆放着当前项目的所有依赖，而其中每个包的node_modules存放着每个包<strong>它自身和它声明的依赖</strong></li>
<li>.pnpm中包自身的本体实际上指向了全局的（或分区的）.pnpm-store中的对应包，<strong>这才是真正存储包的地方，因此全局只会存储一份包</strong></li>
<li>由于硬链接的缘故，右键查看<code>node_modules</code>仍能看到其占用的真实容量，但实际上<strong>只占用了一份空间</strong>（也就是一个磁盘上两个位置的同一份空间）。（来源：<a class="link"   href="https://pnpm.io/zh/faq" >pnpm-FAQ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）</li>
</ul>
<h4 id="pnpm-store的结构">.pnpm-store的结构</h4>
<p>pnpm在处理全局缓存<code>~/.pnpm-store/v3/files</code>时并没有直接将整个包作为存储单位放在缓存中，而是更进一步，将其拆分为**一个个文件块（chunk）**进行存储，然后再对其进行哈希和索引操作。</p>
<p>这样做的好处就是不仅同一个版本的包可以只存储一份内容，甚至<strong>不同版本的包也可以通过diff算法实现增量更新存储</strong>。</p>
<p>直观的说就是，如果你用到了某依赖项的不同版本，只会将不同版本间有差异的文件添加到仓库。例如，如果某个包有100个文件，而它的新版本只改变了其中1个文件。那么 <code>pnpm update</code> 时只会向存储中心额外添加1个新文件，而不会因为仅仅一个文件的改变复制整新版本包的内容。</p>
<p>pnpm采用的这种组织方式叫做<strong>content-addressable（基于内容的寻址）</strong>，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230608234847.png"
                      alt=""
                ></p>
<p>这样解释可能还是不好理解，我们直接打开对应目录，随便看一个文件试试：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230608235332.png"
                      alt=""
                ></p>
<ul>
<li><code>files</code>中还是按照Hash（SHA-512）的格式进行组织和存储，前两位用于目录，后面的位用于文件名</li>
<li><strong>每个文件块实际上对应一个完整的文件</strong>，而没有使用等分法（一般是一个完整的JS模块），这也有助于增量更新</li>
<li>之所以叫“基于内容的寻址”是有别于“基于文件名寻址”，它通过计算内容的HashSum来得到内容的地址，这样就可以保证让相同的文件共享同一份硬链接</li>
</ul>
<h4 id="操作全局store">操作全局store</h4>
<p>使用<code>pnpm store &lt;cmd&gt;</code>命令可以操作全局store，这也是pnpm特有的命令。</p>
<ul>
<li><code>add</code>：直接向store全局添加一个包</li>
<li><code>prune</code>：删除没有使用的包</li>
<li><code>path</code>：返回当前Store的路径</li>
</ul>
<h2 id="monorepo支持">monorepo支持</h2>
<blockquote>
<p>这里后续补充pnpm搭配rush的monorepo体验，对比yarn+lerna的体验。</p>
</blockquote>
<h2 id="兼容性操作">兼容性操作</h2>
<ul>
<li>由于pnpm禁止了幽灵依赖，可能在已有的项目上引起依赖缺失问题，直接<code>pnpm add</code>对应的包添加即可</li>
<li>实在没有其他解决方案的情况下，在<code>.npmrc</code>配置文件中添加<code>nodeLinker=hoisted</code>将创建一个和npm类似的扁平化目录（如React Native开发或不支持符号链接的部署环境）</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a class="link"   href="https://pnpm.io/zh/motivation" >项目初衷 | pnpm <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://pnpm.io/zh/blog/2020/05/27/flat-node-modules-is-not-the-only-way" >平铺的结构不是 node_modules 的唯一实现方式 | pnpm <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://pnpm.io/zh/symlinked-node-modules-structure" >基于符号链接的 node_modules 结构 | pnpm <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/404784010" >Pnpm: 最先进的包管理工具 - 知乎 (zhihu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.51cto.com/article/702067.html" >聊聊前端包管理器对比Npm、Yarn和Pnpm-yarn和npm (51cto.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/7131903244434931748#heading-1" >精读《pnpm》 - 掘金 (juejin.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/7158631927992287263#heading-14" >pnpm 原理解析 - 掘金 (juejin.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/7053340250210795557#heading-11" >都2022年了，pnpm快到碗里来！ - 掘金 (juejin.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端工具链</category>
      </categories>
      <tags>
        <tag>包管理</tag>
        <tag>工具链</tag>
        <tag>pnpm</tag>
        <tag>硬链接</tag>
      </tags>
  </entry>
  <entry>
    <title>前端工具链之包管理器 - yarn-berry与PnP</title>
    <url>/posts/298427098/</url>
    <content><![CDATA[<p>yarn是一个Facebook出品的老牌包管理器，相对于npm要新一点，但相对于pnpm又要旧一点，也已经经过了多个<strong>大版本迭代</strong>。</p>
<h2 id="Classic-Yarn-yarn-v1">Classic Yarn (yarn-v1)</h2>
<blockquote>
<p>首先声明<strong>如果是新创建的项目，不推荐任何人使用Classic Yarn进行管理</strong>，使用npm-v8+、yarn-v2+或者pnpm都是更好的选择。（是的，新的npm确实优于Classic Yarn）</p>
</blockquote>
<p>yarn和npm-v3一样采用了<strong>扁平化依赖</strong>结构，即所有依赖平铺在根目录下，避免了重复安装依赖的问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305050105922.png"
                      alt=""
                ></p>
<p>yarn-v1和npm-v4是同期的产品，yarn相比npm-v4来说有如下优点：</p>
<ul>
<li>离线模式（offline mode）：允许完全使用本地缓存安装包，完全不请求远程仓库（如果没有对应包将报错）</li>
<li>:star: <strong>引入lock文件（yarn.lock）</strong>：使用lock文件记录安装过程、包的详细信息，让每个人安装的依赖树都是确定和一致的</li>
<li>安装过程优化：
<ul>
<li><strong>并行化</strong>多个安装过程，加快安装速度</li>
<li>下载软件包时，会进行更好的排序，避免“请求瀑布”，最大限度提高网络利用率</li>
<li>安装依赖的过程中，不会因为某个单次网络请求的失败导致整个安装挂掉</li>
</ul>
</li>
</ul>
<h2 id="yarn-v2-（Berry）">yarn-v2+（Berry）</h2>
<p>yarn的新版（Berry）和旧版（Classic）的工作方式截然不同，新版本中比较显著的新特性有：<strong>monorepo支持，PnP机制</strong>，零依赖安装等。这里将重点介绍PnP机制，monorepo相关内容请移步<a class="link"   href="https://chlorinec.top/posts/3828472050/" >这篇文章 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<h3 id="安装并启用Berry">安装并启用Berry</h3>
<p>根据<a class="link"   href="https://yarnpkg.com/getting-started/install" >官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的指引，对于node&gt;=16.10版本，推荐使用corepack进行安装，如果你对corepack还不熟悉，可以移步我关于<a href="">npm</a>的文章。这里默认你已经学会并启用了corepack。</p>
<p>在终端中运行下列指令安装最新版的yarn。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">corepack prepare yarn@stable --activate</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装完成后检查版本</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yarn -v</span></span><br></pre></td></tr></table></figure></div>
<p>如果安装成功，将会提示3.x的版本，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230608160328.png"
                      alt=""
                ></p>
<p>接下来，我们使用yarn2去管理项目和依赖：</p>
<ul>
<li>创建新项目：<code>yarn init -2</code></li>
<li>迁移现有项目：<code>yarn set version stable</code>，然后运行<code>yarn install</code>更新依赖树
<ul>
<li>在现有项目中启用PnP（这可能导致兼容性问题）
<ul>
<li>先运行<code>yarn dlx @yarnpkg/doctor</code>来检测当前已经安装的依赖是否会产生兼容性问题</li>
<li>如果没有任何问题，打开或新建<code>.yarnrc.yml</code>，设置<code>nodeLinker: &quot;pnp&quot;</code>即可启用PnP</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>需要注意的是，<strong>默认情况下<code>yarn init</code>仍是1.x的模式</strong>，除非你指定yarn版本为2（如 <code>yarn init -2</code>）才会启用Zero-Installation特性。</p>
</blockquote>
<p>这里为了演示，我们将<strong>使用yarn2创建一个新项目</strong>：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yarn init -2</span></span><br></pre></td></tr></table></figure></div>
<p>上述命令将为我们在当前目录创建<code>package.json</code>文件，并写入一些必要的信息（如项目信息、包管理器信息等），<code>-2</code>选项会为我们完成<strong>零安装</strong>的初始化工作，包括yarn注入（hydrate）和各种相关配置等，最终我们得到一个如下的目录。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230608161654.png"
                      alt=""
                ></p>
<h3 id="了解PnP机制">了解PnP机制</h3>
<p>PnP是yarn2中默认启用的新的包解析方式，我们先试着安装loadash到我们的项目（运行<code>yarn add lodash</code>），再检查目录树：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230608161938.png"
                      alt=""
                ></p>
<p>我们惊讶地发现居然<strong>没有node_modules的存在</strong>！我们明明安装了新包，但是却没有生成node_modules目录，而是在.yarn/cache中增加了一个<strong>压缩包</strong>，这就是<strong>yarn2的PnP技术</strong>。</p>
<blockquote>
<p>Plug’n’Play（即插即用）于2018年9月推出，是Node的新模块安装策略。基于其他语言的先前工作（例如 PHP 的自动加载），它以几乎完全向后兼容的方式实现了常规的 CommonJS <code>require</code> 工作流程。</p>
</blockquote>
<p>要知道为什么PnP机制比node_modules更好，我们就要知道node_modules为什么不好：</p>
<ul>
<li>node_modules是一个很“重”的目录，里面有大量的文件，<strong>寻找、生成和删除都非常花时间</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202304270103999.jpg"
                      alt=""
                ></p>
<ul>
<li>在Node中其实没有“包”（package）这个概念，它只是按照解析路径（一层层地寻找node_modules）寻找对应名称的文件，这导致了安装和调用都是I/O频繁的任务（都需要遍历目录）；也不知道这个文件应不应该被访问（幽灵依赖，即没有添加到<code>package.json</code>中的包也可能被访问并产生潜在的问题）</li>
</ul>
<p>yarn认为，造成上述问题的<strong>根本原因是node中并没有包的概念，但是包解析却交给了node而非掌握依赖树信息的包管理器</strong>（如yarn），因此<strong>yarn要代替node去做包解析的工作，直接告诉node应该调用哪个包、这个包在哪里</strong>，这就是Plug’n’Play机制的核心思想。</p>
<h4 id="PnP如何工作">PnP如何工作</h4>
<p>Plug’n’Play<strong>替Node完成了包解析的工作</strong>，它将直接告诉Node需要的包是哪个，在哪里等信息；同时它为了优化依赖构建过程，<strong>直接干掉了node_modules目录</strong>，使用了新的存储结构，加快了安装速度。</p>
<blockquote>
<p>值得注意的是，由于PnP机制完全替换了基于扁平化的node_modules结构的解析机制，因此<strong>扁平依赖的那些问题如依赖版本冲突、幽灵依赖等问题自然也就不存在了</strong>。</p>
<ul>
<li>因为PnP不再平铺所有依赖，因此也不限制一个依赖只能安装一个版本，每个包都可以安装自己需要的依赖版本（仍会尽可能避免重复，只有在不兼容的时候才会安装两个），这样就解决了依赖版本冲突的问题</li>
<li>同理，由于不再有node传统的解析方式，解析完全交给了PnP，因此幽灵依赖问题也自然消失了。</li>
</ul>
</blockquote>
<h5 id="pnp-cjs">.pnp.cjs</h5>
<p>yarn2<strong>使用<code>.pnp.cjs</code>替代node_modules来帮助node解析包</strong>：<code>.pnp.cjs</code>中包含了各种映射信息，并告诉node如何使用PnP机制去使用包</p>
<ul>
<li><code>.pnp.cjs</code>中包含了包的依赖信息
<ul>
<li>当前依赖树中包含了哪些依赖包的哪些版本</li>
<li>这些依赖包是如何互相关联的</li>
<li>这些依赖包<strong>在文件系统中的具体位置</strong></li>
</ul>
</li>
<li><code>.pnp.cjs</code>的出现替代了node_modules，使yarn只需要创建一个文本文件（而不是潜在的数万个），这优化了I/O性能，减小了路径的复杂度，加快了项目的启动（<code>.pnp.cjs</code>使node不用再使用古老的层层遍历方法去寻找包）
<ul>
<li>安装项目时，yarn不会创建node_modules，而是在<code>.pnp.cjs</code>中记录下载缓存的位置，减小了安装时的I/O开销（复制和解压）和空间占用</li>
<li>调用包时，yarn通过特殊的resolver处理<code>require</code>函数，让node直接去对应位置调用包，避免了目录遍历的I/O开销</li>
</ul>
</li>
<li>为了让node可以使用PnP，有以下途径
<ul>
<li>使用<code>package.json</code>中的<code>script</code>，其中的所有命令都会通过yarn和PnP运行</li>
<li>显式地调用<code>yarn node</code>命令</li>
<li>在JS脚本中则需要调用<code>require('./.pnp.cjs').setup();</code>来初始化PnP</li>
</ul>
</li>
</ul>
<p>这里由于代码太长就直接放截图了，放在开头的就是项目和依赖的基本信息，后面的一大串就是PnP的具体实现（大概）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230608165245.png"
                      alt=""
                ></p>
<h5 id="缓存机制">缓存机制</h5>
<p>通过刚才的例子我们可以看出，我们添加的loadash包放在了.yarn/cache中，并<strong>作为zip压缩文件存储</strong>（而不是有很多小文件的文件夹）。与之类似的，所有从远程存储库下载的包都会存储在本地缓存内（默认是.yarn/cache），下次使用同样的包时将直接使用缓存内下载的包（具体过程在<code>.pnp.cjs</code>中有提到）。</p>
<blockquote>
<p>在yarn2中，离线缓存（offiline cache）与PnP机制紧密绑定，因此无法完全禁用，但<strong>完全删除缓存是安全的</strong>，它将在下次<code>yarn install</code>时重建。除此之外，使用<code>cacheFolder</code>属性可以定义缓存位置。</p>
</blockquote>
<ul>
<li>清理缓存：yarn会自动清理不使用的包，也可以通过<code>yarn cache clean</code>手动清理；全局缓存则需要通过<code>yarn cache clean --mirror</code>来清理</li>
<li>全局缓存：yarn默认情况下不会共享全局缓存（而是将全局下载缓存复制到项目高速缓存中），如果设置<code>enableGlobalCache</code>为<code>true</code>，就会使项目共享全局缓存，即直接使用<code>~/.yarn/cache</code>作为项目的高速缓存而不再复制
<ul>
<li>使用<strong>局部缓存</strong>的好处是可以<strong>开启零安装特性</strong></li>
<li>使用<strong>全局缓存</strong>的好处是可以避免复制缓存</li>
</ul>
</li>
<li>硬链接：可以开启硬链接功能以降低磁盘空间占用
<ul>
<li><code>yarn.lock</code>中的<code>linkType: Hard</code>表示这里的包允许进行硬链接和其他操作（如unplug）；反之若为<code>Soft</code>则表示这里的包并不是原样本，只允许按原样调用该包</li>
<li><code>.yarnrc.yml</code>中的<code>nmMode: &quot;hardLinksGlobal&quot;</code>才表示开启硬链接（多份文件引用一份空间），<strong>该功能默认关闭</strong></li>
</ul>
</li>
</ul>
<h4 id="实操PnP">实操PnP</h4>
<p>下面我们将在yarn3中用Vite创建一个React应用具体来体验PnP是如何工作的，如何开启自己的PnP工作流。</p>
<p>根据Vite官方的指导（所使用的打包器Rollup已经支持PnP）：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yarn create vite <span class="comment"># 使用create模板语法</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化项目</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> yarn-vite</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yarn install</span></span><br></pre></td></tr></table></figure></div>
<p>运行过程截图如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230608192254.png"
                      alt=""
                ></p>
<p>安装完成后，我们会得到一个这样的目录：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230608192816.png"
                      alt=""
                ></p>
<p>可以看到，这里仍是有一个node_modules文件夹的，里面存放的是vite的可执行文件；同时.yarn中还有部分unplugged的包（排除在PnP压缩包之外）。这些都是<strong>PnP的兼容性措施</strong>，但是我们注意到这里并没有指定<code>.yarnrc.yml</code>，说明部分操作可能是写在包中或者<code>yarn.lock</code>/<code>.pnp.loader.mjs</code>中的。</p>
<p>具体的兼容性措施相关内容将留作后文，这里我们只需要了解一个PnP项目基础的结构即可。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yarn run dev</span></span><br></pre></td></tr></table></figure></div>
<p>运行项目检验：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230608193153.png"
                      alt=""
                ></p>
<h5 id="配置IDE">配置IDE</h5>
<p>在前面的PnP机制中我们了解到，和node_modules不同，PnP中所有的包都放在了缓存的<strong>压缩包</strong>中，因此IDE不能直接读取。</p>
<p>在VSCode中我们也确实遇到了“找不到模块”的错误，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230608200745.png"
                      alt=""
                ></p>
<p>根据官方的提示，我们按步骤运行以下操作：</p>
<ul>
<li>为VSCode安装<a class="link"   href="https://marketplace.visualstudio.com/items?itemName=arcanis.vscode-zipfs" >ZipFS <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>扩展</li>
<li>运行 <code>yarn dlx @yarnpkg/sdks vscode</code> 初始化IDE集成</li>
<li>VSCode会弹出提示：“启用工作区TypeScript版本”，选择“确定”即可</li>
</ul>
<blockquote>
<p><strong>最终我也没有解决这个报错问题</strong>，是使用<code>nodeLinker: &quot;node-modules&quot;</code>解决的。（<s>还是推荐pnpm</s>）</p>
<p>个人猜测是Vite与PnP的兼容性导致的，问题可能出在tsconfig中某一环，因为我使用之前例子中的<code>require</code>和此前在<a class="link"   href="https://chlorinec.top/posts/3828472050/" >monorepo改造 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>一文的开发过程中都并没有报错，而在Vite+pnpm的实践中也没有报错。</p>
<p><strong>如果有谁解决了这个问题不嫌麻烦可以联系我一下QaQ</strong>（kiritoclzh@gmail.com）</p>
</blockquote>
<h3 id="什么是零安装">什么是零安装</h3>
<p>有了PnP替代node_modules作为依赖解析的方案后，yarn想更进一步：<strong>既然我已经解决了node_modules太重的问题，为什么我不能直接干掉项目的安装过程（<code>install</code>过程）呢？<strong>这就是所谓的</strong>“零安装”（Zero-Installs）</strong>。</p>
<p>其实零安装的实现思路非常简单，就是<strong>把所有模块都放在存储库重一起管理</strong>，我知道这听起来很蠢，但这是因为之前的node_modules中几万个零碎的文件和目录让这几乎是不可实现的，<strong>在yarn中基于PnP的依赖解析和压缩包（zip或tar）管理的缓存让这变得可能</strong>。（至少传一个很大的JS和很多压缩包比一个几十层的目录要轻松很多）</p>
<blockquote>
<p>对于一个中到大型项目，Git不支持一个包含135k个未压缩文件的node_modules文件夹（约1.2GB），但支持包含2k个Zip文件的.yarn/cache缓存目录（约139MB）。 ——数据来自yarn官网</p>
</blockquote>
<p>零安装带来了一个显著的好处：解决了困扰前端项目许久的<strong>依赖不确定</strong>问题，我现在直接让项目带着依赖，省去了安装的过程，就能保证所有人安装的依赖都是一样的了，甚至连<code>yarn.lock</code>都不用了（因为不用安装）。</p>
<blockquote>
<p>注意：要启用零安装，PnP是必须的，且在<code>.gitignore</code>中不能包含<code>.pnp.cjs</code>和<code>.yarn</code>。但是否启用零安装，主要取决于你<strong>对依赖确定性和存储库大小的重视程度</strong>。</p>
</blockquote>
<h3 id="插件化">插件化</h3>
<p>yarn-v2在构建过程中采用了模块化的思想，使得开发者可以开发插件来调用这些模块化的API。这是一个很底层的设计，yarn团队利用插件重构了yarn-v2的大部分功能，甚至<code>yarn add</code>和<code>yarn install</code>实际上也是预装的插件。由此可见插件可以做到多少事！</p>
<p>插件可以在任意一个生命周期调取Hook来改变yarn的行为：包安装，如解析（resolve）-&gt;请求（fetch）或者命令执行。</p>
<ul>
<li>解析器（resolvers）：解析器负责将<code>package.json</code>中指定的<strong>版本范围转换成一个确定的版本</strong></li>
<li>请求器（fetcher）：请求器负责找到上一步（resolve）得到的包名和版本应该在哪里获取资源，可以是网络也可以是本地缓存</li>
<li>添加命令：每个插件都可以添加自己的命令，就像<code>yarn add</code>那样</li>
<li>注册生命周期钩子</li>
</ul>
<h4 id="插件推荐">插件推荐</h4>
<p>可以通过 <code>yarn plugin import &lt;name&gt;</code> 命令来安装插件。</p>
<p>下面是一些<strong>官方</strong>插件：</p>
<ul>
<li><a href="https://github.com/yarnpkg/berry/tree/master/packages/plugin-typescript"><strong>typescript</strong></a>：改进TypeScript体验（例如，在需要时自动添加 <code>@types</code> 包作为依赖项）【在yarn4中将默认集成】</li>
<li><a href="https://github.com/yarnpkg/berry/tree/master/packages/plugin-workspace-tools"><strong>workspace-tools</strong></a>：改进monorepo体验，添加更多<code>workspace</code>相关命令</li>
</ul>
<h3 id="解决兼容性问题">解决兼容性问题</h3>
<p>由于PnP是比较激进的机制，它完全取消了node_modules，出现一些兼容性问题在所难免（虽然它也带来了一些诱人的好处和新概念）。</p>
<h4 id="yarnrc-yml"><code>.yarnrc.yml</code></h4>
<p>好在<code>.yarnrc.yml</code>提供了丰富的配置项，可以解决大部分的兼容性问题。</p>
<p>以下是一些常用的配置项（给出的值是默认值）</p>
<ul>
<li>
<p><code>cacheFolder: &quot;./.yarn/cache&quot;</code>：指定yarn cache的目录（启用全局缓存请用<code>enableGlobalCache</code>）</p>
</li>
<li>
<p><code>defaultSemverRangePrefix: &quot;^&quot;</code>：添加包时默认记录的版本修饰符（默认为锁定Patch）</p>
</li>
<li>
<p><code>enableGlobalCache: false</code>：如为<code>true</code>将忽略缓存路径设置，将该高速缓存文件存储到共享相同配置的所有本地项目共享的文件夹中（~/.yarn/cache）</p>
</li>
<li>
<p><code>globalFolder: &quot;./.yarn/global&quot;</code>：全局文件夹位置</p>
</li>
<li>
<p><code>httpProxy: &quot;http://proxy:4040&quot;</code> &amp; <code>httpsProxy: &quot;http://proxy:4040&quot;</code>：代理设置（国内常用）</p>
</li>
<li>
<p><code>nmMode: &quot;classic&quot;</code>：控制存储项目本地缓存的方式，适用于空间敏感用户</p>
<ul>
<li><code>classic</code>：复制模式</li>
<li><code>hardlinks-global</code>：硬链接到全局缓存</li>
</ul>
</li>
<li>
<p><code>nodeLinker: &quot;pnp&quot;</code>：控制安装包的方式（所谓Linker就是将包的路径和调用连接起来的方式）</p>
<ul>
<li><code>pnp</code>：yarn2默认的机制，如上文所述</li>
<li><code>pnpm</code>：使用pnpm的硬链接方式</li>
<li><code>node_modules</code>：回退到npm/yarn-classic的方式，生成node_modules文件夹，一般是<strong>解决兼容性问题的终极杀手锏</strong>，但也放弃了很多性能优势</li>
</ul>
</li>
<li>
<p><code>npmRegistries:</code>：控制npm源</p>
</li>
<li>
<p><code>pnpMode: &quot;strict&quot;</code>：控制能否调用到没有在<code>package.json</code>中声明但在npm/yarn-classic中由于提升到顶层可以访问的包（幽灵依赖）</p>
<ul>
<li><code>strict</code>：不允许访问“幽灵依赖”</li>
<li><code>loose</code>：允许访问“幽灵依赖”，这<strong>可能是部分兼容性问题的解决方案</strong></li>
</ul>
</li>
<li>
<p><code>yarnPath: &quot;./scripts/yarn-2.0.0-rc001.js&quot;</code>：<code>yarnPath</code>是目前在项目中安装Yarn的首选方式，因为它可以确保您的整个团队将使用完全相同的Yarn版本，而无需单独更新（在<code>yarn init -2</code>时就会默认生成这个设置项）</p>
</li>
</ul>
<h4 id="unplug">unplug</h4>
<p><code>yarn unplug &lt;pkg&gt;</code>主要用于将某个包解压出来，以便修改代码。</p>
<h4 id="yarn-pnpify">@yarn/pnpify</h4>
<p>PnP的设计理论上与所有使用原生<code>require</code>API的包兼容，但有些包喜欢自己实现Node解析过程，因此它们在不做特殊适配的情况下不能与PnP兼容。<code>pnpify</code>这个包就提供了一种解决该问题的方案。</p>
<ul>
<li>当一个不兼容PnP的项目尝试访问node_modules目录时，<code>pnpify</code>会拦截该请求，并转换成对PnP API的调用，再返回一个模拟的node_modules目录</li>
<li>它并不完美，它不能提供所有的PnP功能，但可以作为兼容性方案</li>
</ul>
<p>使用<code>pnpify</code>需要以下步骤：</p>
<ol>
<li>添加依赖项：<code>yarn add @yarnpkg/pnpify</code></li>
<li>使用<code>pnpify</code>运行不兼容的工具，如：<code>yarn pnpify tsc</code></li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a class="link"   href="https://yarnpkg.com/getting-started/migration" >Migration | Yarn - Package Manager (yarnpkg.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://yarnpkg.com/features/pnp" >Plug’n’Play | Yarn - Package Manager (yarnpkg.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://loveky.github.io/2019/02/11/yarn-pnp/" >Yarn 的 Plug’n’Play 特性 (loveky.github.io) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://yarnpkg.com/features/zero-installs" >Zero-Installs | Yarn - Package Manager (yarnpkg.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://yarnpkg.com/features/offline-cache" >Offline Cache | Yarn - Package Manager (yarnpkg.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://ocavue.com/yarn-2-first-impression-zh/#plug-n-play" >Yarn 2 使用体验 | Ocavue’s Blog <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://liuwenzhuang.github.io/2020/08/07/Yarn2-install-and-usage.html" >Yarn 2的安装与使用 (liuwenzhuang.github.io) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端工具链</category>
      </categories>
      <tags>
        <tag>yarn</tag>
        <tag>包管理</tag>
        <tag>工具链</tag>
        <tag>pnp</tag>
      </tags>
  </entry>
  <entry>
    <title>深入JS - 1.浏览器事件循环</title>
    <url>/posts/2939183973/</url>
    <content><![CDATA[<p>之前在腾讯文档前端面试的时候，考官问我经典八股之一的浏览器事件循环，编程题也是与之相关的。我直接被问瓜了，深感自己在JS基础这方面的知识薄弱，虽然以后可能不做前端了，但还是来恶补一下这方面的知识为好。</p>
<h2 id="JS是如何运行的">JS是如何运行的</h2>
<p>为了理解事件循环，我们需要首先简要理解JS引擎的执行过程，具体过程详见我的后续文章 <a href="#">深入JS - 3. V8引擎</a>。</p>
<p>众所周知，Javascript是<strong>解释型的脚本语言</strong>，即运行环境在拿到它要运行的JS任务的时候得到的是一串文本，而不是编译好的二进制文件，这就要求JS解释器要立刻解析语法并生成二进制代码用于执行，以Chromium的<strong>V8引擎</strong>为例：</p>
<ul>
<li>V8引擎模拟操作系统调用，分为两个核心部分：<strong>执行栈（execution stack）和堆（heap）</strong>
<ul>
<li><strong>执行栈</strong>存放函数调用的栈帧（执行上下文，execution context）</li>
<li><strong>堆</strong>则存放本地变量的值</li>
</ul>
</li>
<li>函数在运行过程中分为<strong>创建阶段（creation phase）<strong>和</strong>执行阶段（execution phase）</strong>
<ul>
<li><strong>创建阶段</strong>会把函数的<strong>执行上下文（execution context）<strong>压入执行栈顶，<strong>执行上下文</strong>包含了</strong>函数的参数、局部变量等信息</strong></li>
<li>执行上下文入栈后将初始化执行上下文，包括<strong>VO(variables, functions and arguments)</strong>、<strong>Scope Chain(VO Chain, 调用链)<strong>和</strong><code>this</code>指针</strong></li>
<li>上下文初始化完毕后开始执行，执行完毕后上下文将从栈顶弹出</li>
</ul>
</li>
</ul>
<blockquote>
<p>上一个试图在浏览器中直接运行二进制的Flash坟头草已经三尺高了，而WebAssembly其实采取了一种折衷方案，相当于C-&gt;汇编-&gt;机器码中省去了汇编过程，但编译和链接的过程仍保留了下来</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202304262204968.gif"
                      alt=""
                ></p>
<h2 id="为什么需要事件循环（event-loop）">为什么需要事件循环（event loop）</h2>
<p>要回答这个问题，我们要先从JS语言和它的解释器本身的特性谈起：</p>
<ul>
<li>前提1：<strong>JS解释器（如V8）是单线程的</strong></li>
<li>前提2：JS解释器<strong>在接收一段代码后会一口气从头到尾完整执行</strong>，中间不能暂停或释放所有权</li>
<li>前提3：<strong>执行JS代码的和构建页面DOM的（渲染线程）是两个东西</strong>，且<strong>解释器线程和渲染线程是相互阻塞（互斥的）</strong>，这是由于JS引擎和渲染线程都可能读取和操作DOM，这导致二者处于竞争状态，所以<strong>为DOM这个临界资源上了一把互斥锁</strong>。</li>
</ul>
<blockquote>
<p><em>前提3</em>也导致了NodeJS中的事件循环和浏览器中并不一样，理论上JS解释器标准由ECMA委员会制定（只对JS语言特性负责），而浏览器事件循环标准由HTML委员会制定，因此不同Host环境下事件循环可能是不一样的，且与JS解释器彼此独立。</p>
</blockquote>
<p>从以上三个前提我们可以看出，由于JS解释器只会一根筋练死劲儿（一口气跑到底），还不管其他人的死活（渲染管线），这样的话<strong>JS执行过程中用户界面出现无响应的情况（如获取数据的过程中网页假死）</strong>，也<strong>无法实现即时事件响应（如按下按钮调用函数）</strong>，这对于响应式网页UI来说是致命的缺陷。</p>
<p>为了弥补这些缺陷，实现异步和响应的需求，我们就必须引入<strong>事件循环机制（event loop）</strong>。</p>
<h3 id="如何实现并行（非阻塞调用）">如何实现并行（非阻塞调用）</h3>
<p>为了实现我们的并行JS宏图，我们可以先参考操作系统中是如何实现并行多任务的。</p>
<p>回顾专业知识，我们可以总结现代计算机操作系统的异步实现为：<strong>宏观上并行，微观上串行</strong>。</p>
<ul>
<li>在宏观的线程层次（调度的基本单位），通过时间片划分、抢占/非抢占策略、就绪/挂起队列等一系列软件设计手段让多个任务并行</li>
<li>在微观上的指令层次，不同的指令仍是串行（这里不考虑底层的指令并行技术如多核心调度、超长指令字等），即一个时钟周期内仍只运行一条指令，通过极短的时间片划分和不断的上下文切换来让宏观层次看起来像并行</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202304262204042.webp"
                      alt=""
                ></p>
<p>然而，在前面我们提到<strong>JS是单线程的</strong>，解释器和渲染管线互斥地使用一个线程，显然不能直接套用操作系统的多线程模型来实现代码并行，但我们仍可以借鉴操作系统的<strong>线程队列思路</strong>。</p>
<p>我们可以为某些“等待态”的任务设计一个<strong>挂起队列</strong>，即在调用栈外再维护一个“任务队列”（暂且把它称为<em>callback queue</em>）用于存储<strong>可能产生阻塞但无需让程序等待</strong>的任务，在这样的任务进入调用栈后就放入挂起队列中，解释器继续运行下一行代码，这样就可以既<strong>保持JS解释器原有的特性，一次性执行完全部代码，又保持页面的响应性</strong>。</p>
<h3 id="如何唤醒沉睡的任务">如何唤醒沉睡的任务</h3>
<p>我们现在让这些任务等待了，但是又迎来了新的问题，该怎么唤醒呢？答案还是藏在我们熟悉的OS里：<strong>消息机制和事件响应</strong>。</p>
<ul>
<li>操作系统维护一个<strong>事件循环</strong>来监听事件的发生，监听到事件后（比如鼠标点击、键盘输入等）会向应用程序发送<strong>消息</strong>，存放在对应的<strong>消息队列</strong>中</li>
<li>应用程序维护一个<strong>消息循环</strong>来监听<strong>消息队列</strong>中是否有新消息到达，将消息分发给对应的事件处理函数（handler）</li>
<li>如果没有注册处理函数（在消息映射表中未找到），该消息最终会被<strong>丢弃</strong>。</li>
</ul>
<p>参考OS的设计，我们也可以在浏览器环境中加入类似<strong>消息队列和事件循环</strong>机制来处理异步式调用的请求和事件，具体来说就是<strong>在JS引擎和渲染线程外单独再开一个线程，维护事件和消息循环与队列</strong>。</p>
<h2 id="事件循环是如何实现的">事件循环是如何实现的</h2>
<p>首先，我们要明确一个概念，<strong>事件循环本质上是一个任务调度器</strong>，和操作系统的线程调度是对等的。</p>
<p>然后，要知道事件循环是什么、做了什么，我们就要首先明白浏览器在渲染和执行一个网页的时候做了什么。</p>
<p>总结上文，我们可以得到一个浏览器的结构<strong>至少</strong>需要实现<strong>三个常驻线程</strong>：</p>
<ul>
<li>JS引擎线程（JS解释器，如V8）</li>
<li>渲染线程（处理DOM，渲染页面）</li>
<li>消息线程（处理消息和事件）</li>
</ul>
<p>其中<strong>JS引擎</strong>是单线程运行JS脚本的；<strong>渲染引擎</strong>由于DOM是临界资源所以和JS引擎是互斥的；<strong>消息线程</strong>则是独立于二者存在的一个循环体，作用就是反复检查挂起队列的任务，并在JS线程空闲（执行栈为空）的时候将挂起队列中的回调函数压入执行栈。</p>
<p>可以说<strong>事件循环（event loop）<strong>就是消息线程的主要任务，它的</strong>任务就是处理这些回调函数的执行</strong>。</p>
<h3 id="运行流程">运行流程</h3>
<p>可以说<strong>事件循环就是浏览器的消息机制</strong>，因此它也有自己的消息队列数据结构，我们叫它<strong>Callback Queue</strong>（或者说Event Queue, Message Queue）都行。</p>
<p>然而JS解释器依然是单线程的，它只能通过引入一些其他线程来实现自己的异步执行，因此最后的工作流程就变成了下面这样：</p>
<ul>
<li>JS解释器照常一口气执行完所有需要执行的JS代码</li>
<li>遇到异步调用如<code>fetch</code>, <code>setTimeOut</code>时，就会把他们的执行权交给<strong>Web API</strong>（浏览器环境，这里可能不止一个线程来执行这些任务）管理（虽然JS解释器是单线程的，但我可以把它的任务交给另亿个线程啊~~，阿巴阿巴~~）</li>
<li>当Web API完成了某个异步任务（如<code>fetch</code>或<code>click</code>）时，就会把对应的回调函数放入<strong>Callback Queue</strong>中等待。</li>
<li>在执行栈为空时，<strong>事件循环</strong>把Callback Queue中的队首任务放入执行栈中，回到第一步。</li>
<li>在执行完这些命令的<strong>解释器空档期</strong>（后面会详细解释）就把DOM控制权交给<strong>渲染线程，更新UI</strong></li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202304262205452.png"
                      alt="image" style="zoom:67%;" 
                >
<p>可以在网站<a class="link"   href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" >Javascript Online Playground <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>上看到JS事件循环中各数据结构的动态过程，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202304262205148.gif"
                      alt=""
                ></p>
<h3 id="引入事件分级机制（宏任务与微任务）">引入事件分级机制（宏任务与微任务）</h3>
<p>在实际的生产应用中，对所有的异步任务都一视同仁显然是不合理的，毕竟操作系统里都有优先级队列呢，更强调响应和交互的网页理应对更重要的事件有更高的响应优先级（如IO、UI变化等），为此我们也为浏览器的消息队列（Callback Queue）引入了自己的优先级队列：<strong>宏任务（macrotask，如<code>&lt;script&gt;</code>、<code>setTimeOut</code>）和微任务（microtask，如<code>Promise</code>）</strong>。</p>
<p>二者的执行顺序如下：</p>
<ol>
<li>首先检查并执行<strong>一个宏任务</strong>（一般来说第一个宏任务是<code>&lt;script&gt;</code>标签），并按JS引擎的规矩一次性执行完毕宏任务的所有同步指令，这个过程中可能注册若干个宏任务和微任务</li>
<li>当执行栈为空且引擎空闲时（一般来说就是<strong>一个宏任务执行完毕的状态</strong>），<strong>事件循环优先检查和执行Callback Queue中的微任务</strong>，注意<strong>宏任务是一个一个地执行的</strong>，但<strong>微任务会一次性清空队列中所有的微任务</strong></li>
<li><strong>执行完一个宏任务+微任务的循环后</strong>，将DOM控制权交还给渲染线程，更新界面</li>
<li>再次检查执行队列，取出<strong>一个宏任务</strong>执行</li>
</ol>
<p>常见的**宏任务（macrotask）**有：<code>setTimeOut</code>、<code>setInterval</code>、<code>setImmediate</code>、<code>&lt;script&gt;</code>、I/O操作、UI渲染等</p>
<p>常见的**微任务（microtask）**有：<code>Promise</code>、<code>process.nextTick</code>等</p>
<h2 id="例题">例题</h2>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></div>
<p>正确答案：1 5 3 4 2</p>
<ol>
<li>首先执行宏任务，打印1 5，入列一个<code>setTimeOut</code>宏任务，一个<code>Promise</code>微任务</li>
<li>然后检查微任务，执行第一个<code>then()</code>，打印3，再入列一个<code>Promise</code>微任务</li>
<li>执行第二个<code>then()</code>，打印4</li>
<li>无微任务，执行宏任务，打印2</li>
</ol>
<blockquote>
<p>Note：</p>
<p>这个地方我犯了一个错误，在<code>Promise</code>的第一个<code>then()</code>里我认为return的值是<code>console.log</code>的回调，并没有实际执行，但实质上这里返回的是<code>console.log(3)</code>作为表达式计算后的值，如果要返回回调应该写<code>return () =&gt; console.log(3)</code>，这样3就不会被打印出来</p>
</blockquote>
<h2 id="现代浏览器模型">现代浏览器模型</h2>
<p>现代浏览器不仅是<strong>多线程</strong>（任务共享资源，拥有独立上下文，靠切换上下文实现并行）的，还是<strong>多进程</strong>（资源彼此独立）的，模型也比上面的基本模型复杂得多（Chromium的内核代码量据说和操作系统相当）。</p>
<p>在Chrome浏览器中，<strong>一个标签页就对应了一个进程，每个进程都有自己独立的线程模型</strong>：</p>
<ul>
<li>GUI 渲染线程</li>
<li>JavaScript 引擎线程</li>
<li>定时触发器线程</li>
<li>事件触发线程</li>
<li>异步 http 请求线程</li>
</ul>
<hr>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a class="link"   href="https://segmentfault.com/a/1190000021295911" >javascript - 一文看懂浏览器事件循环 - 脑洞前端 - SegmentFault 思否 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/It_sharp/article/details/86528264" >消息机制与事件处理_消息事件管理_It_sharp的博客-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/u014634338/article/details/45115661" >Linux操作系统–消息队列_zthgreat的博客-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://segmentfault.com/a/1190000017893482?utm_source=sf-similar-article" >javascript - 浏览器与Node的事件循环(Event Loop)有何区别? - Fundebug - SegmentFault 思否 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/6844903606466904078" >浏览器事件循环机制（event loop） - 掘金 (juejin.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/7024751918484291591" >浏览器事件循环看这一篇就够了 - 掘金 (juejin.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://cnodejs.org/topic/5c3d554fa4d44449266b1077" >浏览器与Node的事件循环(Event Loop)有何区别? - CNode技术社区 (cnodejs.org) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>深入JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>事件循环</tag>
        <tag>消息队列</tag>
        <tag>异步</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 React Hooks</title>
    <url>/posts/3508312236/</url>
    <content><![CDATA[<p>2019年2月，React 16.8更新了一大波重磅内容，其中就包括函数式组件（function component）和Hooks，这一象征着React未来方向的技术。没想到已经四年多过去了，我仍对Hooks的理解处于一个皮毛状态，今天我就来深入研究一下React Hooks，探索Hook机制在前端声明式渲染框架中的具体应用。</p>
<p>本文将从为什么要从类组件转向函数式组件和Hooks谈起，理解Hooks的设计原则和目的；再简单谈谈Hook的原理和实现机制来理解Hooks的规则；最后将实现几个自定义Hook加深对Hooks的理解。</p>
<span id="more"></span>
<h2 id="为什么需要Hooks">为什么需要Hooks</h2>
<p>这是一道经典的面试题，但这个问题更好、更全面的呈现方式应该是：<strong>为什么要从类组件转向函数式组件和Hooks？</strong></p>
<p>在之前的面试中，我的回答是这样的：</p>
<blockquote>
<p>函数组件比类组件更契合React声明式渲染的设计理念，使前端工程更专注于组件树和数据流本身的设计来实现逻辑，而不过分关注副作用（生命周期钩子）来实现业务逻辑，这种模式更直接、更有利于项目的健康。同时由于Hooks的存在，可以在函数式组件中获取一些额外的功能。</p>
</blockquote>
<p>其实总的来说，这个回答已经十分到位了，也是我个人的理解，然后面试官的问题通常会在这里结束，转而问你一般用过哪些Hooks，有什么应用场景这些问题。</p>
<p>但我觉得这还不够，总感觉还有一些比较隐秘的问题萦绕在我的心头，因此我们就从一些根本的概念入手，看看react的发展历史来解答困惑。</p>
<h3 id="什么是声明式渲染">什么是声明式渲染</h3>
<p>与<strong>声明式渲染</strong>相对的是<strong>命令式渲染</strong>，即你通过指令去告诉程序怎么一步步地绘制界面，注重于过程的实现；而声明式则是你去绘制一个模板，这个模板接收数据并自动绘制和更新界面，更关注原因和结果本身。整体类似于原生JS或jQuery（命令式）和React（声明式）的对比，有点像命令式编程和函数式编程的概念区别。</p>
<p>总结起来，声明式渲染就强调一个公式：<code>view = render(viewModel)</code></p>
<p>但是，前端并不是单纯的数据呈现，还需要有交互性，因此这里需要引入一个响应式更新的因素，<strong>将viewModel分为不变的props和可变的state两部分</strong>：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">view = render(props, @reactive states)</span><br></pre></td></tr></table></figure></div>
<p>就此，我们可以建立一个<strong>全局的</strong>响应式规则：<strong>无论什么原因导致state变化，自动触发局部的render函数重新执行</strong>。</p>
<h3 id="render-props和高阶组件">render props和高阶组件</h3>
<p>在函数组件和hooks出世之前，react一直没有找到好的概念和范式来反映上述声明式渲染公式，反复在OOP的框架内兜兜转转，提出了很复杂的类组件，各种生命周期函数来实现业务逻辑，却又没法很好地处理不同组件间的逻辑复用。</p>
<p>在以前的react中，如果你有两个组件都要使用同一个逻辑，如在聊天工具中，发送按钮和头像框都订阅了“用户是否在线”这个逻辑，那么要复用这个逻辑就只有两个方案：</p>
<ul>
<li>复制两份一样的代码，这肯定是下下之策</li>
<li>将共同逻辑提升到二者最近的公共父组件层，<strong>添加一层没有任何实际渲染功能的抽象层组件</strong></li>
</ul>
<p>显然，在以前的react中主流的解决方案是第二种，也就是这里说的<strong>render props和高阶组件</strong>。</p>
<p>顾名思义，<strong>render props</strong>就是<code>render()</code>函数接收的props参数，这些props由另一个组件传来（也就是说父组件把自己的state作为props传给子组件进行渲染），搭配高阶组件就可以实现抽象层组件，下层组件只负责接收抽象层的数据进行渲染。</p>
<p>下面是我从知乎抄的一段代码（因为我没怎么用过类组件嘿嘿）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// withUserStatus.jsx</span><br><span class="line">const withUserStatus = (DecoratedComponent) =&gt; &#123;</span><br><span class="line">  class WrapperComponent extends React.Component &#123;</span><br><span class="line">   state = &#123;</span><br><span class="line">      isOnline: false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleUserStatusUpdate = (isOnline) =&gt; &#123;</span><br><span class="line">      this.setState(&#123; isOnline &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      // 组件挂载的时候订阅用户的在线状态</span><br><span class="line">      userService.subscribeUserStatus(this.props.userId, this.handleUserStatusUpdate)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidUpdate(prevProps) &#123;</span><br><span class="line">      // 用户信息发生了变化</span><br><span class="line">      if (prevProps.userId != this.props.userId) &#123;</span><br><span class="line">        // 取消上一个用户的状态订阅</span><br><span class="line">        userService.unSubscribeUserStatus(this.props.userId, this.handleUserStatusUpdate)</span><br><span class="line">        // 订阅下一个用户的状态</span><br><span class="line">        userService.subscribeUserStatus(this.props.userId, this.handleUserStatusUpdate)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">      // 组件卸载的时候取消状态订阅</span><br><span class="line">      userService.unSubscribeUserStatus(this.props.userId, this.handleUserStatusUpdate)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      return &lt;DecoratedComponent</span><br><span class="line">        isOnline=&#123;this.stateIsOnline&#125;</span><br><span class="line">        &#123;...this.props&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return WrapperComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// userDetail.jsx</span><br><span class="line">import withUserStatus from &#x27;somewhere&#x27;</span><br><span class="line"></span><br><span class="line">class UserDetail &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;UserStatus isOnline=&#123;this.props.isOnline&#125;&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default withUserStatus(UserDetail)</span><br></pre></td></tr></table></figure></div>
<p>这样的形态相对于已经用惯了函数式组件的我来说显然是不健康的，凡事都提一个抽象层出来确实难顶，事实也证明，当你的项目越来越复杂，你的wrapper最终可能会变成这样：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230601110436.png"
                      alt=""
                ></p>
<p>顺带提一句，如果熟悉hooks的同学可能会觉得这和复杂项目中各种provider很像，但这里必须澄清的是：**复用状态（数据流管理）<strong>和</strong>复用逻辑（hooks）**是两个不同的概念，<strong>逻辑也需要在视图层添加额外的组件是不健康的</strong>！</p>
<h3 id="Hooks的优势">Hooks的优势</h3>
<p>首先，<strong>hooks的出现弥补了函数式组件（纯渲染组件）相对类组件的劣势</strong>：开发者偏向于使用Class Component而不是Function Component的一个主要原因是Function Component没有状态管理和生命周期函数等功能。Hook出来后这个问题就不存在了，因为开发者可以使用useState Hook来在Function Component使用state以及useEffect Hook来实现一些和生命周期函数类似的功能。</p>
<p>除此之外，React还将所有复杂的实现都封装在框架里面了，开发者无需学习函数式编程和响应式编程的概念也可以很好地使用Hook来进行开发。</p>
<p>但这些都不能算实打实的好处，hooks的出现还对开发效率有很大的提升，个人的理解有下面几点：</p>
<ul>
<li>Hooks的出现解放了函数式组件，<strong>在react中彻底干掉了this</strong>（<s>众所周知js的this设计就是XXXX</s>）</li>
<li>Hooks允许你<strong>以更方便的方式抽象和提取组件逻辑</strong>，而不再需要提取复杂的抽象高阶组件</li>
</ul>
<p>因此，在现代的react开发中，核心概念可以总结为下面一句话：</p>
<blockquote>
<p><strong>函数式组件（纯函数）负责渲染数据，Hooks负责封装和调用业务逻辑</strong>（状态管理则是数据流管理，在声明式渲染中不可避免地会留存在树形结构中）</p>
</blockquote>
<h2 id="深入理解Hooks的两条规则">深入理解Hooks的两条规则</h2>
<p>React Hooks有两条家喻户晓的规则：</p>
<blockquote>
<ol>
<li><strong>只在最顶层使用 Hook</strong></li>
<li><strong>只在 React 函数中调用 Hook</strong></li>
</ol>
</blockquote>
<p>但是，在被问到（美团面试）之前，我都对这两条规则没有深入的理解，不知道为什么要有这两条规则，现在就来从<strong>实现原理</strong>来探讨一下它们产生的原因。</p>
<h3 id="为什么只能在顶层调用">为什么只能在顶层调用</h3>
<p>为了理解hooks，我们先实现一个自己的<code>useState</code>和<code>useEffect</code>：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// useState.js</span><br><span class="line">var _state; // 把 state 存储在外面</span><br><span class="line"></span><br><span class="line">function useState(initialValue) &#123;</span><br><span class="line">  _state = _state || initialValue; // 如果没有 _state，说明是第一次执行，把 initialValue 复制给它</span><br><span class="line">  function setState(newState) &#123;</span><br><span class="line">    _state = newState;</span><br><span class="line">    render();</span><br><span class="line">  &#125;</span><br><span class="line">  return [_state, setState];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// useEffect.js</span><br><span class="line">let _deps; // _deps 记录 useEffect 上一次的 依赖</span><br><span class="line"></span><br><span class="line">function useEffect(callback, depArray) &#123;</span><br><span class="line">  const hasNoDeps = !depArray; // 如果 dependencies 不存在</span><br><span class="line">  const hasChangedDeps = _deps</span><br><span class="line">    ? !depArray.every((el, i) =&gt; el === _deps[i]) // 两次的 dependencies 是否完全相等</span><br><span class="line">    : true;</span><br><span class="line">  /* 如果 dependencies 不存在，或者 dependencies 有变化*/</span><br><span class="line">  if (hasNoDeps || hasChangedDeps) &#123;</span><br><span class="line">    callback();</span><br><span class="line">    _deps = depArray;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看到，我们使用闭包（词法作用域）实现了简单的<code>useState</code>和<code>useEffect</code>的逻辑，但他们还有一个显著的弱点：**只能调用一次，在不同的地方调用他们都会使用同一个全局变量。**那么react是如何解决这个问题的呢？答案很简单：<strong>通过有序表（数组/链表）</strong>——我们把全局变量变成一个数组，这样不就可以存储更多的值了吗？</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let memoizedState = []; // hooks 存放在这个数组</span><br><span class="line">let cursor = 0; // 当前 memoizedState 下标</span><br><span class="line"></span><br><span class="line">function useState(initialValue) &#123;</span><br><span class="line">  memoizedState[cursor] = memoizedState[cursor] || initialValue;</span><br><span class="line">  const currentCursor = cursor;</span><br><span class="line">  function setState(newState) &#123;</span><br><span class="line">    memoizedState[currentCursor] = newState;</span><br><span class="line">    render();</span><br><span class="line">  &#125;</span><br><span class="line">  return [memoizedState[cursor++], setState]; // 返回当前 state，并把 cursor 加 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function useEffect(callback, depArray) &#123;</span><br><span class="line">  const hasNoDeps = !depArray;</span><br><span class="line">  const deps = memoizedState[cursor];</span><br><span class="line">  const hasChangedDeps = deps</span><br><span class="line">    ? !depArray.every((el, i) =&gt; el === deps[i])</span><br><span class="line">    : true;</span><br><span class="line">  if (hasNoDeps || hasChangedDeps) &#123;</span><br><span class="line">    callback();</span><br><span class="line">    memoizedState[cursor] = depArray;</span><br><span class="line">  &#125;</span><br><span class="line">  cursor++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>至此，我们也获得了我们的答案，这也是为什么react官方说：<strong>只有在顶层调用我们才能确定hooks调用的顺序正确</strong>，而上面的解释也让我们理解了为什么要保证hooks的调用顺序正确——<strong>因为react在刷新时会按照初次渲染的表顺序对数组中的元素进行比对和更新，如果不在函数顶层我们就无法确认每次刷新（重新加载组件）时调用hooks的序列是完全相同的</strong>。</p>
<p>对具体过程感兴趣可以参考这篇博客：<a class="link"   href="https://github.com/brickspert/blog/issues/26" >React Hooks 原理 · Issue #26 · brickspert/blog (github.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>这里再引用一句话，它很好地从另一个角度（设计而非技术实现）概括了Hooks这条规则的本质：</p>
<blockquote>
<p>为什么Hooks需要限制只能在代码的第一层调用 Hooks，不能在循环、条件分支或者嵌套函数中调用 Hooks？</p>
<p><strong>因为本来它应该写在参数区的，只是因为语法的限制</strong>导致它没有专有的位置而已。</p>
</blockquote>
<p>我来解释一下就是Hooks作为逻辑实现，它本来不应该出现在函数组件中（就类似于直接在函数组件中定义和使用了高阶组件）。由于JSX没有语法的限制，导致它能出现在任何地方，但理论上它应该作为不变的props传入组件中（就像render props那样），所以才会对其做出这样的限制。</p>
<h3 id="为什么只能在React函数内使用Hooks">为什么只能在React函数内使用Hooks</h3>
<p>这看起来是一个比较蠢的问题，显然是因为react函数（函数组件和hook函数）提供了普通js函数没有的功能，但它是如何实现的呢？</p>
<p>这又指向了另一个问题：<strong>刚刚我们的简单hook其实也只能在一个组件中反复调用，如果有多个组件也不能成功地记忆state</strong>，那要如何才能实现真正的<code>useState</code>和<code>useEffect</code>呢？为了解释这个问题和两个问题之间的关联，我们仍需要从react的底层实现谈起。</p>
<p>首先，在react中，每次调用hook实际上会生成一个Hook的数据结构，并以<strong>单链表</strong>（而非数组的形式）组织起来：</p>
<div class="highlight-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Hook</span> = &#123;|</span><br><span class="line">  <span class="attr">memoizedState</span>: <span class="built_in">any</span>,</span><br><span class="line">  <span class="attr">baseState</span>: <span class="built_in">any</span>,</span><br><span class="line">  <span class="attr">baseQueue</span>: <span class="title class_">Update</span>&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt; | <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">queue</span>: <span class="title class_">UpdateQueue</span>&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt; | <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">Hook</span> | <span class="literal">null</span>,</span><br><span class="line">|&#125;;</span><br></pre></td></tr></table></figure></div>
<p>而在fiber架构中，组件树中所有节点构成了一个单链表，每个节点对应一个组件，<strong>hooks 的数据就作为组件的一个信息，存储在这些节点上，伴随组件一起出生，一起死亡</strong>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/12526493/56090149-7e7f6f00-5ed0-11e9-81e4-3a053d7e8d6d.png"
                      alt=""
                ></p>
<p>说到这里，你是不是想到了这两个问题其实指向了一个共同的回答：<strong>react函数提供了一个普通js函数没有的作用域（上下文），而这也是通过js的词法作用域（闭包）实现的！</strong></p>
<p>那么，我们的声明式渲染式公式也可以随之进一步完善一下，加入一个隐式的<code>context</code>元素用于实现hooks，现在函数式组件可以通过<strong>闭包</strong>机制来灵活地切换上下文，实现每个组件都有自己的hook序列：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">view = render(props, @reactive state, @implicit context)</span><br></pre></td></tr></table></figure></div>
<p>那么，在react中实际上的调用过程是怎么样的呢？我们以<code>useState</code>为例看看：</p>
<ol>
<li><code>useState</code>内部会调用<code>ReactCurrentDispatcher.current.useState</code></li>
<li>由于hook一定只会在另一个hook或函数组件中调用（也就是说外面一定包着一个函数组件），而只有在函数组件执行前才会将<code>ReactCurrentDispatcher.current</code>设置为<code>HooksDispatcherOnMount或HooksDispatcherOnUpdate</code></li>
<li>当函数组件执行完后<code>ReactCurrentDispatcher.current</code>马上被设置为<code>ContextOnlyDispatcher</code></li>
<li>所以在 React 函数外使用<code>useState</code>时，<code>useState</code>内部会调用<code>ContextOnlyDispatcher.useState</code>，该函数是会报错的。其他 hooks 同理。</li>
</ol>
<p>因此，react实际上是通过<strong>闭包</strong>机制去<strong>设置全局变量</strong>实现了每个函数组件有自己的<strong>hook上下文</strong>，这也让自定义hook执行起来就像直接把hook内容宏替换到指定位置再运行一样（因为与执行环境上下文是统一的）。</p>
<h2 id="实现自己的Hooks">实现自己的Hooks</h2>
<p>秉承着<strong>hooks是对业务逻辑的抽象与封装</strong>（对render props和高阶组件的替换），我们就开始着手将组件中涉及副作用的逻辑抽象成自定义hooks方便复用。</p>
<h3 id="useAsync的实现"><code>useAsync</code>的实现</h3>
<blockquote>
<p>“如何使用自定义Hook实现每次访问这个Hook都访问的是同一个对象？”</p>
<p>—— MHY一面</p>
</blockquote>
<p>上面这道题在问我的时候我其实并没有真正答出来，但其实是我当时的理解有误：我认为是想让不同的组件访问该Hook都拿到同一个值。所以我当时提出的方案是在另一个地方存储这个数据，如：服务器、localStorage或闭包（全局变量），并提出了我的质疑——我认为Hook只应该对逻辑进行封装，不应该直接对状态进行管理（应该结合Context来实现）。</p>
<p>但是现在换一个思路，如果是说<strong>让Hook能记忆住某个状态，并在调用时可以想起这个状态，使其返回同一个实例</strong>（即只调用一次，有点像单例模式），那么这个Hook的实现就是有意义的，而调用异步资源的Hook：<code>useAsync</code>则正是这样一个Hook。</p>
<h4 id="构建简单环境">构建简单环境</h4>
<p>首先我们先用koa后端+react前端搭建一个简单的环境（包管理器我使用pnpm，使用其他包管理器不影响操作），以便进行实践：</p>
<blockquote>
<p>pnpm+vite+swc的组合真的充满了现代气息，相比守旧派的cra（npm+webpack+babel）真的快了不止半点。</p>
</blockquote>
<ol>
<li>首先初始化简单的后端环境</li>
</ol>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> server-test</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> server-test</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pnpm init</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pnpm add koa</span></span><br></pre></td></tr></table></figure></div>
<ol start="2">
<li>修改后端环境代码（来自koa官方的hello world用例），这回创建一个始终返回Hello Koa（不管什么url、什么方法）的socket。</li>
</ol>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// response</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.<span class="property">body</span> = <span class="string">&#x27;Hello Koa&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></div>
<ol start="3">
<li>修改启动代码，在<code>package.json</code>中修改启动脚本：<code>&quot;start&quot;: &quot;node index.js&quot;</code></li>
<li>启动后端服务，在postman中测试如下图所示表示成功：</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230601122255.png"
                      alt=""
                ></p>
<ol start="5">
<li>初始化前端项目，这里使用vite和axios</li>
</ol>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pnpm create vite</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建完成后切换到项目目录</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pnpm install</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pnpm add axios</span></span><br></pre></td></tr></table></figure></div>
<p>注意这一步中的提示命令如下图所示，注意选择react+typescript+swc：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230601122512.png"
                      alt=""
                ></p>
<ol start="6">
<li>配置vite代理，具体代码如下：</li>
</ol>
<div class="highlight-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vite.config.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> react <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-react-swc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://vitejs.dev/config/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="title function_">react</span>()],</span><br><span class="line">  <span class="attr">server</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<ol start="7">
<li>修改./src/App.tsx代码，配置基本的异步fetch</li>
</ol>
<div class="highlight-container" data-rel="Tsx"><figure class="iseeu highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.tsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reactLogo <span class="keyword">from</span> <span class="string">&#x27;./assets/react.svg&#x27;</span></span><br><span class="line"><span class="keyword">import</span> viteLogo <span class="keyword">from</span> <span class="string">&#x27;/vite.svg&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./App.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> [resp, setResp] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="title function_">axios</span>(<span class="string">&#x27;/api&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> res.<span class="property">data</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123; <span class="title function_">setResp</span>(data) &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(err) &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://vitejs.dev&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;viteLogo&#125;</span> <span class="attr">className</span>=<span class="string">&quot;logo&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Vite logo&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://react.dev&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;reactLogo&#125;</span> <span class="attr">className</span>=<span class="string">&quot;logo react&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;React logo&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Vite + React<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount((count) =&gt; count + 1)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">          count is &#123;count&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          Edit <span class="tag">&lt;<span class="name">code</span>&gt;</span>src/App.tsx<span class="tag">&lt;/<span class="name">code</span>&gt;</span> and save to test HMR</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;read-the-docs&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Click on the Vite and React logos to learn more</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;resp&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>如果所有步骤都成功了，运行<code>pnpm run dev</code>可以看到如下的结果（注意后端不要停），看到Hello Koa就算成功了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230601122803.png"
                      alt=""
                ></p>
<h4 id="useRef的本质"><code>useRef</code>的本质</h4>
<blockquote>
<p><code>useRef</code> 是一个 React Hook，它能让你引用一个不需要渲染的值</p>
</blockquote>
<p>此前对<code>useRef</code>的理解也仅限于官方文档中推荐的为DOM绑定ref来实现一些对dom的直接操作，一直没有深入地了解。</p>
<p>之前对ref的理解就只有以下两点，都是不求甚解的阶段（不知道为什么，但是直到怎么用）：</p>
<ol>
<li>在JS中声明ref只需要 <code>const el = useRef()</code> 即可，但在TS中则需要（以Input为例）<code>const el = useRef&lt;HTMLInputElement&gt;(null)</code>。需要注意的是，<strong>这个<code>null</code>很重要，没有null就会报错！</strong></li>
<li><strong>在不同组件中传递ref时需要使用forwardRef而不能直接传递ref</strong>，即用<code>forwardRef(renderer)</code>把组件包裹起来，子组件中可以直接获取ref</li>
</ol>
<p>正如官网介绍所说，<code>useRef</code>可以创建一个<strong>无需渲染的值</strong>的引用，返回一个只有<code>current</code>属性的对象，<strong>将ref传给DOM只是ref的一种用法（react自动给current赋值）</strong>，你也可以将ref用于存储一些其他与渲染无关的值。</p>
<ul>
<li><strong>“无需渲染”<strong>意味着 ref 只是一个</strong>普通</strong>的 JavaScript 对象，<strong>改变它的值不会引发重新渲染</strong>。</li>
<li>但是ref和真正普通的JS对象也不同：普通JS对象每次重新渲染都会重置，而ref永远只会初始化一次，因此ref可以用于存储一些需要<strong>在渲染之间保持的值</strong></li>
<li>ref和state/memo是两种不同的存值方案，ref主要用于不需要呈现在ui上的值</li>
</ul>
<p>但react<strong>不建议</strong>（但不阻止）在渲染期间（包括return中和前面的逻辑部分）手动改变ref的值（托管给dom的除外），因为根据声明式渲染的原则，<strong>你的props+state+context一致时，返回的view就应该是一致的</strong>，而在<strong>渲染期间修改了非响应式的变量导致渲染结果发生改变显示是非期望</strong>的行为。</p>
<p>总的来说，ref就是一个游离于响应式的存储方案，在某些场景如存储内部id（计时器、调用等），操作dom API等很有用，也是我们实现单例调用的基石。</p>
<h4 id="实现简单的useAsync">实现简单的<code>useAsync</code></h4>
<p>当年看别人写的<code>useAsync</code>就觉得很神奇，怎么做到把Promise抽出来做成一个state的，年少的我百思不得其解，现在理解了hooks后发现不过是把loading和state绑定的逻辑封装了起来（就是把<code>Promise.then</code>中的<code>setState</code>封装了起来），但需要注意的是：<strong>不应该重复请求资源，在组件释放后不应该继续更新状态</strong>，这些功能都要结合其他hooks实现。</p>
<p>第一个功能可以靠<code>useMemo</code>和<code>useCallback</code>进行缓存；第二个功能则可以靠<code>useRef</code>和<code>useEffect</code>去记录当前组件是否还被加载。</p>
<p>下面的代码将实现一个简单的<code>useAsync</code>，通过输入Promise注册，直接在返回的state中显示状态、错误和数据：</p>
<div class="highlight-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useRef, useEffect, useCallback &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Status</span> = <span class="string">&#x27;idle&#x27;</span> | <span class="string">&#x27;pending&#x27;</span> | <span class="string">&#x27;resolved&#x27;</span> | <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IRequestState</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">status</span>: <span class="title class_">Status</span>;</span><br><span class="line">  <span class="attr">data</span>: T | <span class="title class_">Error</span> | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useMountedRef</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> mountedRef = <span class="title function_">useRef</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    mountedRef.<span class="property">current</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      mountedRef.<span class="property">current</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> mountedRef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> useAsync&lt;</span><br><span class="line">  T = <span class="built_in">unknown</span>,</span><br><span class="line">  <span class="title class_">Args</span> <span class="keyword">extends</span> <span class="built_in">unknown</span>[] = <span class="built_in">unknown</span>[]</span><br><span class="line">&gt;(<span class="attr">fn</span>: <span class="function">(<span class="params">...args: Args</span>) =&gt;</span> <span class="title class_">Promise</span>&lt;T&gt;) &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState&lt;<span class="title class_">IRequestState</span>&lt;T&gt;&gt;(&#123;</span><br><span class="line">    <span class="attr">status</span>: <span class="string">&#x27;idle&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> mounted = <span class="title function_">useMountedRef</span>();</span><br><span class="line">  <span class="keyword">const</span> setData = <span class="title function_">useCallback</span>(</span><br><span class="line">    <span class="function">(<span class="params">data: T</span>) =&gt;</span> <span class="title function_">setState</span>(&#123; <span class="attr">status</span>: <span class="string">&#x27;resolved&#x27;</span>, data &#125;),</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> setError = <span class="title function_">useCallback</span>(</span><br><span class="line">    <span class="function">(<span class="params">error: <span class="built_in">Error</span></span>) =&gt;</span> <span class="title function_">setState</span>(&#123; <span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>, <span class="attr">data</span>: error &#125;),</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> updateData = <span class="title function_">useCallback</span>(</span><br><span class="line">    <span class="keyword">async</span> (...<span class="attr">args</span>: <span class="title class_">Args</span>) =&gt; &#123;</span><br><span class="line">      <span class="title function_">setState</span>(&#123; <span class="attr">status</span>: <span class="string">&#x27;pending&#x27;</span>, <span class="attr">data</span>: <span class="literal">null</span> &#125;);</span><br><span class="line">      <span class="keyword">if</span> (mounted.<span class="property">current</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> ans = (<span class="keyword">await</span> <span class="title function_">fn</span>(...args));</span><br><span class="line">          <span class="title function_">setData</span>(ans);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="title function_">setError</span>(error <span class="keyword">as</span> <span class="title class_">Error</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    [fn, mounted, setData, setError]</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> [state, updateData] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>在这个示例中，我们封装了一个async逻辑，获得一个回调函数，返回它的状态和更新handler。</p>
<p>在调用端我们做以下调整，这样就会在第一次加载页面时加载数据（mount周期而不是update周期），更进一步地我们可以把对axios的封装和首次加载页面获取数据也抽象成hook，这里就不再赘述：</p>
<div class="highlight-container" data-rel="Tsx"><figure class="iseeu highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">tryFetch</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> resp = <span class="keyword">await</span> <span class="title function_">axios</span>(<span class="string">&#x27;/api&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> resp.<span class="property">data</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> [&#123; data, status &#125;, update] = <span class="title function_">useAsync</span>(tryFetch);</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">update</span>();</span><br><span class="line">&#125;, [update]);</span><br></pre></td></tr></table></figure></div>
<h3 id="使用别人的轮子">使用别人的轮子</h3>
<p>在自定义hooks方面，除了官方提供的hooks是必须了解的，其实已经有很多成熟的第三方库提供了很多实用的hooks。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/64800798" >从React Hooks看React的本质 - 知乎 (zhihu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/347136271" >前端进阶系列——理解 React Hooks - 知乎 (zhihu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/137183261" >React为什么需要Hook - 知乎 (zhihu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/7020811068955951135#heading-0" >为什么React Hooks会有两条使用规则 - 掘金 (juejin.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://github.com/brickspert/blog/issues/26" >React Hooks 原理 · Issue #26 · brickspert/blog (github.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/7027486366254497799" >为什么React要用函数式组件？ - 掘金 (juejin.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.zhihu.com/question/68121329" >怎么理解“声明式渲染”？ - 知乎 (zhihu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/115407249" >React设计模式-Render Props - 知乎 (zhihu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://zh-hans.legacy.reactjs.org/docs/hooks-rules.html" >Hook 规则 – React (reactjs.org) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://zh-hans.react.dev/reference/react/useRef" >useRef – React <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://zh-hans.react.dev/learn/referencing-values-with-refs#differences-between-refs-and-state" >使用 ref 引用值 – React <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/nxcniuxiangchen/article/details/124847401" >React自定义hook之useAsync处理异步请求并实现自动执行回调函数_无响应乱码元素的博客-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>深入React</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>hook</tag>
      </tags>
  </entry>
  <entry>
    <title>从设计模式看 react-redux 的工作原理</title>
    <url>/posts/2764449389/</url>
    <content><![CDATA[<p>在研究原生的<code>useContext</code> 和<code>useReducer</code> 方案时我就感到非常疑惑，数据对象更新导致的组件刷新是由react控制的，这导致了在状态增多后会产生意外刷新的问题。</p>
<p>但是redux明明采用了相近的思路，是<strong>如何避免整个对象刷新带来的意外组件更新</strong>的呢？</p>
<h2 id="发布-订阅模式">发布-订阅模式</h2>
<p>redux的核心就是<strong>发布-订阅模式</strong>，我们回忆一下redux的基本结构和流程：</p>
<ul>
<li>有且仅有一个全局状态store，维护着所有states</li>
<li>所有组件从store中获取状态，并通过dispatch action来更新状态</li>
<li><strong>当状态更新时，所有订阅了该状态的组件发生刷新</strong></li>
</ul>
<p>可以看见，问题的关键就在于订阅了状态的组件按需刷新这一点，前两点通过原生的<code>useContext</code> + <code>useReducer</code> 其实都可以实现，但只有redux能实现按需刷新，不会刷新无关组件。</p>
<p>那这是怎么做到的呢？我们先从发布-订阅模式入手，看看redux是如何实现该模式的。</p>
<h3 id="基本概念">基本概念</h3>
<p>发布-订阅模式天然具有两个对象：<strong>发布者</strong>和<strong>订阅者</strong>，比如在视频网站中，up主就是发布者，关注了up的用户就是订阅者，up主发布视频后关注了该up的所有人都会收到推送。</p>
<ul>
<li>发布者（publisher）：该类型实例可以发布某一类型的消息，并通知所有所有订阅了该消息的订阅者</li>
<li>订阅者（subscriber）：该类型实例可以订阅和退订某些消息源，并在收到消息时可选地做出反应</li>
</ul>
<p>利用OOP，我们可以定义以下两个接口来表示发布者和订阅者需要实现的基础能力。</p>
<div class="highlight-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 订阅者</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ISubscribe</span> &#123;</span><br><span class="line">  <span class="comment">// 注册对IPublish实例的监听，并添加事件处理函数</span></span><br><span class="line">  <span class="attr">subscribe</span>: <span class="function">(<span class="params">publisher: IPublish, callback: (payload: ...<span class="built_in">any</span>) =&gt; <span class="built_in">void</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">// 取消对IPublish实力的监听</span></span><br><span class="line">  <span class="attr">cancel</span>: <span class="function">(<span class="params">publisher: IPublish</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布者</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPublish</span> &#123;</span><br><span class="line">  <span class="comment">// 通知所有订阅了该发布者的订阅者实例</span></span><br><span class="line">  <span class="attr">notify</span>: <span class="function">(<span class="params">message: ...<span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在具体实现方面，订阅者比较简单，只需要向发布者注册和注销监听即可；发布者一方可以<strong>维护一个线性表来保存所有订阅了该消息的订阅者实例</strong>。具体实现上可以参考下面的（伪）代码：</p>
<div class="highlight-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Publisher</span> <span class="keyword">implements</span> <span class="title class_">IPublish</span> &#123;</span><br><span class="line">  <span class="attr">subscribers</span>: <span class="title class_">Map</span>&lt;<span class="title class_">ISubscribe</span>, <span class="function">(<span class="params">...<span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">void</span>&gt; = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  <span class="title function_">addListener</span>(<span class="params">subscriber: ISubscribe, callback?: (...<span class="built_in">any</span>) =&gt; <span class="built_in">void</span></span>) &#123;</span><br><span class="line">    subsicribers[subscriber] = callback; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">removeListener</span>(<span class="params">subscriber: ISubscriber</span>) &#123;</span><br><span class="line">    <span class="comment">// remove</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">notify</span>(<span class="params">...message: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    subscribers.<span class="property">values</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>(message));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上面的代码中我们创建了一个哈希表来存储订阅者，主要是为了方便管理订阅者（添加和删除），在发送消息时直接调用表中存储的回调来通知订阅者，实现了一个最基础的发布-订阅模式。</p>
<h3 id="与观察者模式的对比">与观察者模式的对比</h3>
<p>上面的实现看起来一眼观察者模式对吧，我们的Publisher就是Subject（被观察者），Subscriber就是Observer（观察者），Publisher状态变化时就会去主动通知Subscriber，就像下面这样。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/08/20230814004718.png"
                      alt=""
                ></p>
<p>但真正的发布-订阅模式不是这样的，与观察者模式直接相连的方式不同，发布-订阅模式最直观的区别就是<strong>发布者和订阅者之间维护了一层类似消息队列的东西，负责分发消息</strong>，像下面这样。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/08/20230814004720.png"
                      alt=""
                ></p>
<p>还是拿刚刚B站视频订阅举例子，在up更新视频后给观众推送订阅消息时，并不是up自己主动地给每个关注了自己的人发消息，而是告诉了一个中间人（broker）“我更新了视频”，然后这个中间人再向订阅了这个消息的人推送这条消息“xx up更新了视频，快来看吧”。</p>
<p>虽然它们的结果是相同的，但他们中间的实现过程有着最本质的区别：<strong>发布者和订阅者之间完全不需要有直接联系，是完全解耦的</strong>，而不像观察者模式一样是松耦合的（基于接口抽象）。</p>
<p>因此我们上面的例子可以说完全不是发布-订阅模式，只是观察者模式；而接口描述只是描述了这个模型的能力，而二者又是几乎相同的。</p>
<p>在应用场景上，二者虽然结果相同，但面向的应用场景和规模是不同的：</p>
<ul>
<li>观察者模式多用于单个应用内部</li>
<li>发布-订阅模式多用于跨应用的消息中间件，如操作系统的消息队列</li>
</ul>
<p>在redux中，我们把<strong>整个更新机制看作发布-订阅模式的实现，其中dispatch action的一方看作发布者，mapState使用状态的一方看作订阅者。</strong> 二者是完全解耦的，符合定义要求。</p>
<ul>
<li>dispatch action的一方并不知道它的修改会影响哪些组件，它只管负责通知“中间人”store它做出了什么修改</li>
<li>“中间人”store负责对修改做出响应，并通知受到影响的组件更新</li>
</ul>
<h3 id="redux中的实现">redux中的实现</h3>
<p>在redux中，观察和订阅的实现要稍微复杂一点。准确地说，redux中的<code>Subscription</code> 实例既可以发布，也可以订阅。</p>
<ul>
<li>它可以订阅父级的<code>Subscription</code> ，并<strong>在它们更新时得到通知</strong></li>
<li>它也可以被子组件订阅，并<strong>在自己更新时通知它们</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/08/20230814004729.png"
                      alt=""
                ></p>
<p>在上面的流程图中有一个小细节需要注意，那就是<code>Subscription</code>的来源：</p>
<ul>
<li>在生成<code>Provider</code> 组件的Context时会自动生成一个<code>Subscription</code> 实例，它包含了我们的store，并使用redux store的<code>subscribe(callback)</code>订阅了最顶层的消息，即<strong>在整个store发生更新时得到通知</strong>，其逻辑和其他层级的<code>subscribe</code> 是一致的</li>
<li>在使用<code>connect()</code> 包裹组件时，它除了生成一个HOC外还会生成一个<code>Subscription</code> 实例，它<strong>将订阅当前Context中的<code>Subscription</code>对象，并更新当前Context的​<code>Subscription</code>对象为自己</strong></li>
<li>根据Context的就近原则，<strong>实际调用store中的对象时会使用的是组件树中最近的Context Value</strong></li>
</ul>
<blockquote>
<p>为什么要选择嵌套的Provider结构？确保树中较低层的连接组件只有在最近的连接祖先被更新后才会收到 store 更新通知来避免一些过长更新链带来的“边缘情况”。<br>
参考链接：<a class="link"   href="https://cn.react-redux.js.org/api/hooks#stale-props-%E5%92%8C-zombie-children"  title="https://cn.react-redux.js.org/api/hooks#stale-props-和-zombie-children">https://cn.react-redux.js.org/api/hooks#stale-props-和-zombie-children <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p>以下是简化后的subscription实现代码：</p>
<div class="highlight-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Subscriotion.js</span></span><br><span class="line"><span class="keyword">const</span> nullListeners = &#123; <span class="title function_">notify</span>(<span class="params"></span>) &#123;&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听集合是一个双向链表</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createListenerCollection</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 也就是React里的unstable_batchedUpdates</span></span><br><span class="line">  <span class="comment">// 来自司徒正美微博：unstable_batchedUpdates会把子组件的forceUpdate干掉，防止组件在一个批量更新中重新渲染两次</span></span><br><span class="line">  <span class="keyword">const</span> batch = <span class="title function_">getBatch</span>();</span><br><span class="line">  <span class="keyword">let</span> first = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> last = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">      first = <span class="literal">null</span>;</span><br><span class="line">      last = <span class="literal">null</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知订阅者更新</span></span><br><span class="line">    <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">batch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> listener = first;</span><br><span class="line">        <span class="keyword">while</span> (listener) &#123;</span><br><span class="line">          <span class="comment">// 这个callback的本质就是让组件本身forceUpdate</span></span><br><span class="line">          listener.<span class="title function_">callback</span>();</span><br><span class="line">          listener = listener.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅</span></span><br><span class="line">    <span class="title function_">subscribe</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> isSubscribed = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 把last赋值为新的</span></span><br><span class="line">      <span class="keyword">let</span> listener = (last = &#123;</span><br><span class="line">        callback,</span><br><span class="line">        <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">prev</span>: last</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果存在前一个，就把前一个的next指向当前（最后一个）</span></span><br><span class="line">      <span class="keyword">if</span> (listener.<span class="property">prev</span>) &#123;</span><br><span class="line">        listener.<span class="property">prev</span>.<span class="property">next</span> = listener;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则它就是第一个</span></span><br><span class="line">        first = listener;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 返回退订函数</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">unsubscribe</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// ...退订逻辑</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Subscription</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">store, parentSub</span>) &#123;</span><br><span class="line">    <span class="comment">// redux store</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">store</span> = store;</span><br><span class="line">    <span class="comment">// 父级的Subscription实例</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parentSub</span> = parentSub;</span><br><span class="line">    <span class="comment">// 退订函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">unsubscribe</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 监听者</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">listeners</span> = nullListeners;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleChangeWrapper</span> = <span class="variable language_">this</span>.<span class="property">handleChangeWrapper</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加嵌套的订阅者</span></span><br><span class="line">  <span class="title function_">addNestedSub</span>(<span class="params">listener</span>) &#123;</span><br><span class="line">    <span class="comment">// 首先先将当前的Subscription实例绑定到父级</span></span><br><span class="line">    <span class="comment">// 绑定的同时会初始化listeners</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">trySubscribe</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">listeners</span>.<span class="title function_">subscribe</span>(listener);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知子级</span></span><br><span class="line">  <span class="title function_">notifyNestedSubs</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">listeners</span>.<span class="title function_">notify</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当父级Subscription的listeners通知时调用</span></span><br><span class="line">  <span class="title function_">handleChangeWrapper</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 这个是new出实例的时候加上的，感觉有点秀</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">onStateChange</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">onStateChange</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">trySubscribe</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 不会重复绑定</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">unsubscribe</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">unsubscribe</span> = <span class="variable language_">this</span>.<span class="property">parentSub</span></span><br><span class="line">        ? <span class="variable language_">this</span>.<span class="property">parentSub</span>.<span class="title function_">addNestedSub</span>(<span class="variable language_">this</span>.<span class="property">handleChangeWrapper</span>)</span><br><span class="line">        : <span class="comment">// subscribe是redux里的方法，在redux state改变的时候会调用</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">store</span>.<span class="title function_">subscribe</span>(<span class="variable language_">this</span>.<span class="property">handleChangeWrapper</span>);</span><br><span class="line">      <span class="comment">// 创建新的listeners，每个connect的组件都会有listeners</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">listeners</span> = <span class="title function_">createListenerCollection</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 退订</span></span><br><span class="line">  <span class="title function_">tryUnsubscribe</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">unsubscribe</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">unsubscribe</span>();</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">unsubscribe</span> = <span class="literal">null</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">listeners</span>.<span class="title function_">clear</span>();</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">listeners</span> = nullListeners;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="API实现">API实现</h2>
<h3 id="Provider-组件"><code>&lt;Provider&gt;</code> 组件</h3>
<p>Provider只实现了两个简单的功能：</p>
<ul>
<li>创建根层级的<code>Subscription</code> 实例，订阅redux store的消息事件</li>
<li>创建包含<code>Subscription</code> 实例和store的Context，供其包裹的组件使用状态</li>
</ul>
<p>其简单的代码实现如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// components/Provider.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Provider</span>(<span class="params">&#123; store, context, children &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// useMemo仅在store变化时再重新返回</span></span><br><span class="line">  <span class="keyword">const</span> contextValue = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> subscription = <span class="keyword">new</span> <span class="title class_">Subscription</span>(store);</span><br><span class="line">    <span class="comment">// 通知订阅这个subscription的子级刷新</span></span><br><span class="line">    subscription.<span class="property">onStateChange</span> = subscription.<span class="property">notifyNestedSubs</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      store,</span><br><span class="line">      <span class="comment">// 将此subscription传入context方便子级订阅</span></span><br><span class="line">      subscription</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [store]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存上次的state</span></span><br><span class="line">  <span class="keyword">const</span> previousState = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> store.<span class="title function_">getState</span>(), [store]);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; subscription &#125; = contextValue;</span><br><span class="line">    <span class="comment">// 在这里是订阅的reudx store的subscribe事件</span></span><br><span class="line">    subscription.<span class="title function_">trySubscribe</span>();</span><br><span class="line">    <span class="keyword">if</span> (previousState !== store.<span class="title function_">getState</span>()) &#123;</span><br><span class="line">      subscription.<span class="title function_">notifyNestedSubs</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      subscription.<span class="title function_">tryUnsubscribe</span>();</span><br><span class="line">      subscription.<span class="property">onStateChange</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [contextValue, previousState, store]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 传入的context或者react-redux自带的</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Context</span> = context || <span class="title class_">ReactReduxContext</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Context.Provider</span> <span class="attr">value</span>=<span class="string">&#123;contextValue&#125;</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">Context.Provider</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>我们关注到以下细节：</p>
<ul>
<li><code>ContextValue</code> 其实包含了<code>store</code> 和Subscription实例，而Subscription实例内部的store只是用于订阅store的改变事件</li>
<li>在redux核心概念中我们知道，store的本质就是一个reducer，可以看成state+dispatch两部分构成，state会不断改变，但dispatch应是不会改变的（只要传入Provider的store不变）</li>
</ul>
<h3 id="connect-API"><code>connect</code> API</h3>
<p>虽然在现代的redux中<code>connect</code> API几乎已经被废弃了，官方也推荐使用Hook API替代。但<code>connect</code> API仍然是可用的，而且理解它对理解Hooks的原理也是有帮助的。</p>
<blockquote>
<p>代码太多了不想逐行分析了，这里就大概说下我对流程的理解。</p>
</blockquote>
<p><code>connect()</code> 函数的作用就是生成一个高阶组件（HOC）来包裹要调用store的组件，这个HOC主要负责以下工作：</p>
<ul>
<li>创建自己的Subscription Context
<ul>
<li>订阅来自上层的变化</li>
<li>通知下层自身的变化</li>
</ul>
</li>
<li>将state和dispatch写入被包裹组件的props中，以便组件调用
<ul>
<li><code>mapStateToProps</code></li>
<li><code>mapDispatchToProps</code></li>
</ul>
</li>
<li><strong>将store更新和视图更新解耦，判断当前组件是否需要刷新，避免不需要的刷新</strong>
<ul>
<li>某个Subscription触发更新后，会通过<code>notify</code>通知所有订阅了它的Subscription实例，并触发<code>onStateChange</code> 回调</li>
<li>Connect组件中<code>checkForUpdates</code> 用于处理<code>onStateChange</code> 回调事件，它负责处理数据的刷新，判断当前组件是否需要刷新
<ul>
<li>通过检查当前mappedStates（当前组件调用的状态对象）是否更新来判断是否刷新</li>
<li>不论mappedStates是否更新，都需要通知子组件检查更新</li>
<li>采用记忆化（memo）、Ref和强等于来进行优化和判断</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Hook-API">Hook API</h3>
<h4 id="useSelector"><code>useSelector</code></h4>
<div class="highlight-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">result</span>: <span class="built_in">any</span> = <span class="title function_">useSelector</span>(<span class="attr">selector</span>: <span class="title class_">Function</span>, equalityFn?: <span class="title class_">Function</span>)</span><br></pre></td></tr></table></figure></div>
<p>selector Hook在概念上与connect中的<code>mapStateToProps</code> 类似，都是按需获取store中的部分状态。</p>
<ul>
<li>和<code>mapStateToProps</code> 一样，<code>useSelector</code> 会在store更新后触发运行，但在订阅的数据没有更新时不会触发组件刷新，而是使用缓存值</li>
<li>由于<code>useSelector</code> 是一个Hook，它也具有一些<code>mapState</code> 不具备的特性
<ul>
<li>和其他Hook一样，在组件刷新时会运行Selector（除非组件被memo导致地址没有发生变化）</li>
<li>通过闭包或柯里化来引入props</li>
<li>selector函数的返回值可以是任何值而不只是对象，值得注意的是由于<code>useSelector</code> 采用严格引用相等来判断更新，因此建议对每一个原子状态单独设置selector而不是合成在一个对象中，在react-redux v7中使用react批量更新会将这些Selector放在一起执行（只会执行一次）</li>
</ul>
</li>
</ul>
<h4 id="useDispatch"><code>useDispatch</code></h4>
<div class="highlight-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dispatch = <span class="title function_">useDispatch</span>()</span><br></pre></td></tr></table></figure></div>
<p><code>useDispatch</code> 相对于<code>useSelector</code>更加简单，它只是返回<code>store.dispatch</code>。</p>
<p>只要传入Provider的store没有改变，dispatch的函数引用地址就应该是稳定不变的，但<code>useMemo</code> 和<code>useCallback</code> 这样的记忆化Hook还是会要求把<code>dispatch</code> 放进deps数组中。</p>
<h4 id="useStore"><code>useStore</code> </h4>
<blockquote>
<p>⚠️在任何时候都应该尽量避免使用这个Hook来获取状态</p>
</blockquote>
<div class="highlight-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br></pre></td></tr></table></figure></div>
<p>这个 hook 返回一个 Redux store 引用，该 store 与传递给 <code>&lt;Provider&gt;</code> 组件的 store 相同。</p>
<p>不应该频繁使用这个 hook。宁愿将 <code>useSelector()</code> 作为主要选择。然而，对于少量需要访问 store 的场景而言，例如替换 reducer，这个 hook 很有用。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>状态管理</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>状态管理</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title>抓包工具与移动端H5开发</title>
    <url>/posts/1411383268/</url>
    <content><![CDATA[<p>之前一直做的是PC端的Web页面开发，很少触及移动端页面，最多也就是做一做响应式的适配，完全没有涉及过mobile-first页面的开发。站在初次涉及这个领域的立场上，我认为与普通的响应式页面相比主要的区别点有两点：</p>
<ul>
<li>WebView环境不同，移动端页面的运行环境受到系统（iOS/Android）和App（各大App都有自己的WebView，特别是微信）的影响，各个WebView提供不同的能力，需要单独适配</li>
<li>因为WebView环境不同，因此也不能直接在PC端使用浏览器仿真直接调试，而是需要真机调试，这就需要使用一些特殊工具来让真机的App环境能连上开发页面（抓包劫持）</li>
</ul>
<p>本文主要讨论后者，学习抓包和反向代理工具的实践和使用。</p>
<h2 id="抓包工具概览">抓包工具概览</h2>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/08/20230806200846.png"
                      alt="" title="我正在使用的抓包工具Bifrost"
                ></p>
<p>可以看到，抓包工具截获了所有网络请求包，并将这些Session展示了出来以供修改，我们可以通过设置规则来拦截和转发这些包，来达到开发和调试的目的。</p>
<p>相信各位前端的同学或多或少都使用过Node http-server的Proxy功能，它的功能主要就是反向代理，将某个URL的流量通过规则Rewrite后转发到另一个URL，一般用于解决前后端的HTTP请求跨域问题。</p>
<p>但其实在最开始的时候我还使用过另一套方案，就是上面说的抓包工具转发，它通过规则去匹配指定URL来转发，一样可以达到同样的效果。</p>
<p>因此，我们可以简单地理解这个抓包工具在调试过程中的作用就是全局的反向代理，拦截原来的请求，将一个URL的流量重写后转发给指定的URL。</p>
<h3 id="为什么需要它">为什么需要它</h3>
<p>上面我们已经大致了解了抓包工具的作用，那么它在移动端调试上有什么作用呢？</p>
<p>因为移动端Web开发依赖于Webview的特性，我们需要在真机环境里进行测试，那如何在真机环境的Webview中进入对应页面就是一个问题，很多时候我们都不能控制我们的内置浏览器的URL。</p>
<p>因此我们想出了一个办法：<strong>我们直接访问一个现存的URL，然后利用抓包工具反向代理到本地的开发页面不就可以实现调试了吗</strong>。</p>
<p>大概的流程如下图所示，抓包工具将自己设置成反向代理服务器，从手机→服务器的连接变成了手机→电脑（代理服务器）→服务器的过程。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/08/20230806200849.png"
                      alt=""
                ></p>
<h3 id="代理与反向代理">代理与反向代理</h3>
<p>所谓代理（Proxy）就是中间人，在计算机网络中就是一个端侧设备，它接收请求，并根据规则转发到对应的实际端侧目标，在整个访问过程中客户端并没有和服务端真正通信，而是通过代理这个中间人进行沟通。</p>
<p>代理又分为正向代理和反向代理两种：</p>
<ul>
<li>正向代理：在客户端发送请求时<strong>不直接请求服务端，而是请求代理</strong>，通过代理间接请求服务端，这样就<strong>向服务端隐藏了真实的客户端</strong>，如通过VPN科学上网就属于正向代理。</li>
<li>反向代理：在服务端处理请求时先通过一个类似“中枢”的代理环节，对外请求都汇总到中枢，中枢再具体决定将请求转发到哪个物理机进行响应，<strong>向客户端隐藏了真实的服务端</strong>，如使用nginx负载均衡和在http-server中代理后端地址等过程都是反向代理。</li>
</ul>
<p>抓包工具的代理显然是<strong>反向代理</strong>，但其在手机端的连接需要建立一个VPN，这个过程又属于正向代理。</p>
<h3 id="常见的抓包工具">常见的抓包工具</h3>
<p>下面列举一些常见的抓包工具：</p>
<ul>
<li><code>whistle</code> : 最负盛名的基于Node实现的跨平台web调试代理工具
<ul>
<li>主要用于查看、修改HTTP和HTTPS包</li>
<li>也可以作为HTTP代理服务器使用<br>
下面这个熟悉的界面就是whistle啦<br>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/08/20230806200857.png"
                      alt=""
                ></li>
</ul>
</li>
<li><code>Fiddler</code> ：Windows平台为主的网络调试代理工具，后来也支持mac和Linux</li>
<li><code>Charles</code> : mac平台的网络代理调试工具</li>
<li><code>Bifrost</code> : 字节跳动出品的抓包代理工具，也是我正在使用的（虽然不确定外网能不能搜到hhh）
<ul>
<li>Electron前端，全平台支持</li>
<li>简单易用的GUI</li>
</ul>
</li>
</ul>
<h2 id="Bifrost使用">Bifrost使用</h2>
<h3 id="安装与连接">安装与连接</h3>
<p>在官网下载安装PC/mac客户端<a class="link"   href="https://bifrost.bytedance.net/"  title="Bifrost (bytedance.net)">Bifrost (bytedance.net) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，手机端同时安装。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/08/20230806200901.png"
                      alt=""
                ></p>
<p>点击顶部的手机图标，手机扫码连接（同一Wi-Fi下），后面会在手机端建立一个VPN连接，随后电脑端就可以收到手机端的请求包信息。</p>
<blockquote>
<p>手机端可以设置应用白名单，避免全局代理产生问题</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>webview</tag>
        <tag>代理</tag>
        <tag>h5</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
</search>
