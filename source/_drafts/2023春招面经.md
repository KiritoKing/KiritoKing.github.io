---
title: 2023 前端春招面试 - JS 基础部分
tags: 
---

y

- webpack和其他打包工具（esbuild, bun, vite, turbopack）
- 现代状态管理
- 浏览器缓存与网络（http2.0和https）
- react-fiber机制
- state刷新机制
- git
- vue2&3和react16+&18的区别

## 原型与原型链继承

![原型链.png](./2023春招面经.assets/1460000021232137-1684132167207-6.png)

JavaScript 是基于**原型**的而不是基于类的，面向对象**用原型链实现继承而不是类的派生**。

### 基本概念

JavaScript 对象是动态的属性“包”（指其自己的属性），对象又分为**普通对象**和**函数对象**两种。

- **每个对象**都有 `__proto__` 属性，它指向这个对象的**原型对象（prototype）**
- 只有**函数对象**有 `prototype`（原型对象）属性，它有**默认**拥有两个属性：`constructor` 和 `__proto__`（默认表示在 `log` 时不会显示出来）
  - `constructor` 属性用于记录实例是由哪个**构造函数**创建，函数对象的 `prototype` 的 `constructor` 默认是它自己，普通对象则是它的构造函数。
  - `__proto__` 属性指向对象的父类（对象）的原型对象（prototype），直到 `Object` 的 `prototype` 属性为 `null`，原型链结束
- **任何函数都可以作为构造函数**，但是并不能将任意函数叫做构造函数，**只有当一个函数通过 `new` 关键字调用的时候才可以成为构造函数**。
- 当试图访问一个对象的属性时，它**不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索**，直到找到一个名字匹配的属性或到达原型链的末尾。
- 需要注意的是，**当继承的函数被调用时，this 指向的是当前继承的对象，而不是继承的函数所在的原型对象。**
- 要检查对象是否具有自己定义的属性（即这个属性在 `this` 里而不是 `__proto__` 中），而不是其原型链上的某个属性，则必须使用所有对象从 `Object.prototype` 继承的 `hasOwnProperty` 方法。

> 在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要。另外，试图访问不存在的属性时会遍历整个原型链。

#### Fun Facts

以下事实均可以在浏览器环境或Node环境中验证。

- 由于 JS 会递归地查询原型链上的属性，因此在对象中可以直接访问直接父类的 `constructor` 属性，其他顶层的未被遮蔽的父类属性也可以被直接访问，但修改会直接赋值到 `this` 中，并掩蔽 `prototype` 中的属性
- 如果你使用普通对象作为 `prototype` 赋值给 `__proto__` 时，它寻找 `constructor` 时会调用它的 `__proto__.constructor`，实际上就是 `Object`（因为普通对象的`__proto__`属性就是`Object`，根据规则，函数对象的`prototype.constructor`就是它本身）。
- 修改构造函数的 `prototype` 和修改实例的 `__proto__` 在行为上是等价的（**同一构造函数的所有实例的`__proto__`都指向同一个对象**，即构造函数的 `prototype`）

### Javascript 如何实现继承

明白了原型（`__proto__` 和 `prototype`）的概念和原型链的原理后，我们应该如何编写代码来实现继承呢？

#### 直接继承

- 使用 `Object.create(obj)` 创建对象，允许你指定一个将**被用作新对象原型的对象**，即将 `obj` 赋值给 `__proto__`
- 使用**构造函数**，通过 `new` 关键字指定对象的 `__proto__` 属性为对应函数的 `prototype` 属性
  - `new` 首先会创建一个新的空对象
  - 它将新生成的对象的 `__proto__` 属性赋值为构造函数的 `prototype` 属性，使得通过构造函数创建的所有对象可以共享相同的原型
  - 使用 `constructor.apply(obj, args)` 运行构造函数，并使其绑定到创建的对象中
- 直接修改 `__proto__` 属性或者使用 `Object.setPrototypeOf(obj, prototype)`
- 也可以直接给 `__proto__` 或者 `prototype` 属性赋值来增加原型上的属性

> 注意：原生原型**不应该**被扩展，除非它是为了与新的 JavaScript 特性兼容。

#### 继承链

上面这些方法都只能执行**一层的继承**，如果我想像其他OOP语言一样拥有很长的继承链要怎么办呢？

> 最好的办法是使用ES6+提供的 `class` 语法糖，这里仅作为原型链的训练使用。

比如说我们有三个类，继承关系是：`PrimaryStudent`->`Student`->`Person`。

首先想到的方法如下：

```javascript
function Person(name, age, gender) {
  this.name = name;
  this.age = age;
  this.gender = gender;
}

function Student(name, age, gender, score) {
  Person.call(this, name, age, gender);
  this.score = score;
}

function PrimaryStudent(grade, ...props) {
  Student.apply(this, props);
  this.grade = grade;
}

var xiaoming = new PrimaryStudent(2, '小明', 9, '男', 92);
console.log(xiaoming);
```

但我们需要注意一点：**调用了`Student`构造函数不等于继承了`Student`**，而只是在 `PrimaryStudent` 中运行构造函数添加了对应的属性。

现在创建的对象的原型链是：`this` -> `PrimaryStudent.prototype` -> `Object.prototype` -> `null`。

而我们想要的原型链是：`this` -> `PrimaryStudent.prototype` -> `Student.prototype` -> `Person.prototype` -> `Object.prototype` -> `null`。

是的，想必你也想到了，我们可以直接修改 `prototype` 属性来得到正确的原型链，只是我们必须**借助中间对象来实现正确的原型链**。

我们将这个过程包装在一个函数中：

```javascript
function inherits(Child, Parent) {
  var F = function() {};
  F.prototype = Parent.prototype;
  Child.prototype = new F();
  Child.prototype.constructor = Child;
}
```

这样就可以用下面的代码还原正确的原型链：

```javascript
inherits(Student, Person);
inherits(PrimaryStudent, Student);
```



## this 指针

`this` 是 JS 的关键字之一，是 `object` 类型自动生成的一个内部对象，**只能在内部使用**，虽然大体上指的是本身及其所处环境，但**根据调用的位置不同实际指向的地方是不同的**。

众所周知 `function` 也是一个特殊的对象，而 `this` 其实也主要用于函数内部。

### 绑定规则

在看下面这些例子的时候很难不想到上面原型链中的`this`指向哪里，等看完了自然就有了答案。

#### 默认绑定

```javascript
function doSomething() {
  this.a = 20
  console.log(this.a)
}
a = 10
console.log(a) // 10
doSomething() // 20
console.log(a) // 20
```

若函数调用的位置直接位于顶级作用域，就像“光杆司令”，就只能执行**默认绑定，绑定到全局环境中**（在浏览器中是`window`，Node环境中则是`global`，严格模式中则是`undefined`）

#### 隐式绑定

```javascript
function doSomething() {
  console.log(this.a)
}
var obj = {
  a: 2,
  doSomething: doSomething
}
a = 10
doSomething() // 10
obj.doSomething() // 2
```

函数调用的位置**在对象内部**时，函数就有了**上下文对象**，此时 `this` 就指向了上下文对象。需要注意的是，这里的上下文指的是**直接上下文**。

我们回忆使用 `new` 创建实例的原理，实际上也是 `new` 内部新建了对象，并把这个对象作为上下文对象调用构造函数，也就是说构造函数中的 `this` 指向我们创建的对象。

需要注意的，**`this` 指向的上下文和词法作用域产生的闭包是两个不同的概念**。

#### 显式绑定

显式绑定可以通过一些方法强制给函数设置 `this` 指向的对象，这些方法定义在 `Function` 这个构造函数的**原型**中。

- `Function.call(this, thisArg, ...args)`
  - 定义在原型中的函数的 `this` 参数会在实例调用该方法时自动填入
  - `thisArg` 用于指定函数的 `this` 指针
  - `...args` 为变长参数列表
- `Function.applay(this, thisArg, argArray)`
  - 与 `call` 的区别是参数列表是数组形式
- `Function.bind(this, thisArg, ...args)`
  - 与 `call` 的区别是它会**返回一个函数**以供调用，而不是直接执行

#### 箭头函数（Lambda 表达式）

ES6中引入的 `=>` 函数不受上述规则影响，而是**完全由外部环境决定 `this` 的指向**，且**不能被手动修改**（即对箭头函数使用`call`、`bind` 和 `apply` 是**无效**的）。但是它的**外部环境（父作用域）仍受制于上述的 `this` 规则**。





## 闭包与词法作用域

