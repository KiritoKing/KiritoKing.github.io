---
title: 2023 前端工具链大族谱
tags:
  - 前端
  - 工具链
  - 包管理
  - 打包器
  - JS引擎
categories:
  - 前端
abbrlink: 2480212683
date: 2023-04-18 00:00:00
---

q前端工具

## JavaScript 引擎

- nodejs
  - nvm：管理node版本

- deno
- bun
- v8
- quickjs

## 包管理

众所周知，~~node_modules是世界上最重的东西~~管理好依赖项对于任何工程项目来说都是至关重要的，某些层次上这可能是在前端项目中最影响开发体验的环节之一（~~特别是对于中国开发者~~还有一个环节个人认为是打包）。

<img src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202304270103999.jpg" alt="19b3ff266bc8f328a8f61732d15c6a0" style="zoom: 50%;" />

因此，这一part讨论主要的Node包管理器及其特性。

由于在node v16.13+版本支持了`corepack`特性，这是一个实验性工具，可以**指定项目使用的包管理器以及版本**，具体情况会放在本版块第一部分叙述。

### corepack 工具

> 官方介绍来自：[nodejs/corepack (github.com)](https://github.com/nodejs/corepack)
>
> Corepack is a zero-runtime-dependency Node.js script that acts as a bridge between Node.js projects and the package managers they are intended to be used with during development. In practical terms, **Corepack will let you use Yarn and pnpm without having to install them** - just like what currently happens with npm, which is shipped by Node.js by default.

Corepack是一个**实验性工具**，在 Node.js v16.13 版本中引入，它可以指定项目使用的包管理器以及版本。

简单来说，Corepack 会成为 Node.js 官方的内置 CLI，用来管理『包管理工具（yarn、pnpm）』，在管理 Packges 时会直接调用 Corepack 进行管理，Corepack 再根据用户配置决定使用哪个包管理器来实施操作，即『**包管理器的管理器**』。

新版的 pnpm 和 yarn 文档中，都推荐使用 corepack 来安装和管理包管理器，而非全局方式。

需要注意的是：**corepack 目前仅支持yarn和pnpm，并不支持cnpm**

#### 安装并启用 corepack

由于 Corepack 是实验性工具，它并不是默认启动的，需要手动开启，开启后全局有效

- 对于16.13+版本：直接运行`corepack enable`（需要管理员/root权限）
- 对于更低版本：需要手动安装
  - 首先，需要**卸载已经全局安装的yarn和pnpm**
  - 然后，**全局安装 corepack**：`npm i -g corepack`

#### 使用 corepack

- 可以直接使用`yarn`、`pnpm`来进行安装而无需任何配置
  - 若指令与项目指定的包管理器符合，`corepack`会静默下载对应的包管理器并执行你的指令
  - 若指令与项目指定的包管理器不一致，`corepack`会拒绝你的指令
  - 若本地未配置包管理器，`corepack`会下载对应的 *good-release* 版本的包管理器并执行你的指令
- 可以在`package.json`中指定 `packageManager` 字段来指定包管理器，值按`packageManager@x.y.z`格式编排，后面**可选**地附加一个Hash值来确认安全下载，下面的代码就指定了Yarn 3.2.3版本作为包管理器：

```json
{
  "packageManager": "yarn@3.2.3+sha224.953c8233f7a92884eee2de69a1b92d1f2ec1655e66d08071ba9a02fa"
}
```

- 可以使用 `corepack prepare packageManager@x.y.z` 来下载某个版本的包管理器，也可以直接使用`latest`下载最新版



### npm

npm 想必各位前端er已经很熟悉了，这里就不再介绍模块化JS的重要性，也不在讨论CJS和ECMA Module语法的问题，直接说说 npm 在生产环境中的应用、规则和best-practices。

### cnpm

### pnpm

> *pnpm* is a **fast, disk space efficient package manager**

上述是[pnpm官网](https://pnpm.io/)对自己的定位和介绍，可以看出其是一款对标npm和yarn的包管理器，主打一个**快速和省空间**，这里就主要介绍它对npm的区别和优势。

在传统的npm中，如果你有 100 个项目，并且所有项目都有一个相同的依赖包，那么， 你在硬盘上就需要保存 100 份该相同依赖包的副本来保证不同项目之间的版本独立。~~都什么年代还在用传统npm~~

那么，*pnpm* 是如何做到提高安装速度、节省硬盘空间的呢？

#### 包共享机制

![img](https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202304270045517.jpeg)

上面这张图在网上广为流传，是pnpm对工作原理的自述：

- pnpm 会将包存放在一个统一的位置（类似于yarn的全局缓存），当安装软件包时， 其包含的**所有文件都会硬链接自此位置，而不会占用 额外的硬盘空间**。这让你可以在项目之间方便地共享相同版本的 依赖包。
- 对于不同项目的不同版本依赖，项目本地只会**存储版本之间不同的文件**（类似git记录），而不会因为一个文件的修改而保存依赖包的 所有文件。

#### 非扁平 node_modules 目录

npm和yarn采用拍扁 node_modules（所有软件包都将被提升到 node_modules 的 根目录下）的方案，这会导致**源码可以访问 本不属于当前项目所设定的依赖包**，导致可能某些包依赖的同一个库版本冲突。

但这也是不得已而为的解决方案，因为其非硬链接的存储方式导致如果给每个包都单独列出依赖会导致 node_modules 本就臃肿的体积无限膨胀。

在 pnpm 中，它会**创建非扁平的 node_modules 目录**，默认情况下，pnpm 则是通过使用符号链接的方式仅将项目的直接依赖项添加到 node_modules 的根目录下。

![img](https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202304270054060.jpeg)

**相关阅读：**

- [Flat node_modules is not the only way | pnpm中文文档 | pnpm中文网](https://www.pnpm.cn/blog/2020/05/27/flat-node-modules-is-not-the-only-way)
- [Symlinked `node_modules` structure | pnpm中文文档 | pnpm中文网](https://www.pnpm.cn/symlinked-node-modules-structure)

### Yarn 2

package.json和package-lock.json

还有各种dependency的区别

## 打包器

- webpack
- vercel
- vite
- turbopack
- esbuild