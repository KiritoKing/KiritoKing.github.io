---
title: 2023 前端工具链大族谱
tags:
  - 前端
  - 工具链
  - 包管理
  - 打包器
  - JS引擎
categories:
  - 前端
abbrlink: 2480212683
date: 2023-04-18 00:00:00
---

q前端工具

> **观前警告**：这是一篇很长的文章，你可能需要看很久很久，我也写了很久很久。
>
> 如果你只是想获取某个工具在2023年的消息，直接跳到对应的章节阅读即可。
>
> 如果你想系统地了解整个前端项目的开发环境系统，可以收藏起来，在~~拉屎~~吃饭的时候慢慢看。

## JavaScript 运行时

JS环境不仅提供JS解释器，还要提供一系列的API和周边配置。

### Node.JS

Node.JS是最知名，也是最广泛使用的本地JS环境。

#### `nvm` (Node Version Manager)

`nvm` 是一个多版本Node管理工具，可以方便地切换当前系统变量中的Node版本。

因为不同操作系统的特性（Windows的环境变量管理和Shell和Unix系有很大不同），`nvm`在Github上也有两个“分支版本”：

- [nvm-sh/nvm](https://github.com/nvm-sh/nvm) for **Unix/Linux**
- [coreybutler/nvm-windows](https://github.com/coreybutler/nvm-windows) for **Windows**

二者虽然都是`nvm`，但其底层原理实现上有很大不同，`nvm-sh`完全靠`.sh`脚本控制系统变量来实现版本切换，而`nvm-windows`则是靠更复杂的Windows API实现版本切换。



### Deno

### Chromium

### Bun

## JavaScript 引擎（解释器）

- v8引擎
- quick-js

## 包管理

众所周知，~~node_modules是世界上最重的东西~~管理好依赖项对于任何工程项目来说都是至关重要的，某些层次上这可能是在前端项目中最影响开发体验的环节之一（~~特别是对于中国开发者~~还有一个环节个人认为是打包）。

<img src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202304270103999.jpg" alt="19b3ff266bc8f328a8f61732d15c6a0" style="zoom: 50%;" />

**包管理**这部分主要讨论*Node Packages*的管理工具，即**如何快速、高效地在自己的项目中引用别人编写好的库或功能**。随着包管理器的发展，从最初的npm-v1开始，到npm-v3和yarn1，再到yarn2和pnpm，包管理器不断快速迭代以满足前端不断膨胀的开发需求，包管理器也从最初的依赖管理变成了**前端项目管理器**，包含各种附加功能（`script`, `test`等），*mono-repo*管理等，依赖管理这个最基础功能也在随着新技术的出现（如Rust的流行）不断改进，变得**更快、更省空间和易于管理**。

接下来的叙述除了`corepack`作为基于Node.JS的现代包管理基础方案放在最开头介绍，后面将按照历史发展顺序依次介绍npm（含cnpm）,yarn（含v1和v2）以及pnpm（performant npm）。个人**最推荐使用pnpm作为现代包管理工具**，其次使用yarn2+来管理前端项目，非老项目兼容性问题则不再推荐npm（对mono-repo支持不佳）；而*Bun*作为一套独立的工具链解决方案（运行时+包管理+打包器）则不在本篇的讨论范围内。

> 由于在node v16.13+版本支持了`corepack`特性，这是一个实验性工具，可以**指定项目使用的包管理器以及版本**，即官方内置了一个**包管理器的管理器**，可以视为一种现代的包管理器方案，因此会放在第一部分进行叙述。

### corepack 工具

> 官方介绍来自：[nodejs/corepack (github.com)](https://github.com/nodejs/corepack)
>
> Corepack is a zero-runtime-dependency Node.js script that acts as a bridge between Node.js projects and the package managers they are intended to be used with during development. In practical terms, **Corepack will let you use Yarn and pnpm without having to install them** - just like what currently happens with npm, which is shipped by Node.js by default.

Corepack是一个**实验性工具**，在 Node.js v16.13 版本中引入，它可以指定项目使用的包管理器以及版本。

简单来说，Corepack 会成为 Node.js 官方的内置 CLI，用来管理『包管理工具（yarn、pnpm）』，在管理 Packges 时会直接调用 Corepack 进行管理，Corepack 再根据用户配置决定使用哪个包管理器来实施操作，即『**包管理器的管理器**』。

新版的 pnpm 和 yarn 文档中，都推荐使用 corepack 来安装和管理包管理器，而非全局方式。

需要注意的是：**corepack 目前仅支持yarn和pnpm，并不支持cnpm**

#### 安装并启用 corepack

由于 Corepack 是实验性工具，它并不是默认启动的，需要手动开启，开启后全局有效

- 对于16.13+版本：直接运行`corepack enable`（需要管理员/root权限）
- 对于更低版本：需要手动安装
  - 首先，需要**卸载已经全局安装的yarn和pnpm**
  - 然后，**全局安装 corepack**：`npm i -g corepack`

#### 使用 corepack

- 可以直接使用`yarn`、`pnpm`来进行安装而无需任何配置
  - 若指令与项目指定的包管理器符合，`corepack`会静默下载对应的包管理器并执行你的指令
  - 若指令与项目指定的包管理器不一致，`corepack`会拒绝你的指令
  - 若本地未配置包管理器，`corepack`会下载对应的 *good-release* 版本的包管理器并执行你的指令
- 可以在`package.json`中指定 `packageManager` 字段来指定包管理器，值按`packageManager@x.y.z`格式编排，后面**可选**地附加一个Hash值来确认安全下载，下面的代码就指定了Yarn 3.2.3版本作为包管理器：

```json
{
  "packageManager": "yarn@3.2.3+sha224.953c8233f7a92884eee2de69a1b92d1f2ec1655e66d08071ba9a02fa"
}
```

- 可以使用 `corepack prepare packageManager@x.y.z` 来下载某个版本的包管理器，也可以直接使用`latest`下载最新版；增加 `--activate` 选项可以将当前下载的版本作为 corepack 的 best-release 版本。

### npm

> *npm*(Node Package Manager) 不仅是一个包管理器，更是**前端的项目管理器**，它除了管理依赖，还定义了项目的信息、脚本和行为，这些信息都被*npm*存储在`package.json`中。
>
> 可以说*npm*是一切前端项目，包括其他包管理器的基础，其他包管理器均必须实现npm的基础功能，**你可以没有其他包管理器，但你必须有且理解npm**。
>
> 注：如果想要了解前端领域为什么需要npm，可以看[这篇文章](https://zhuanlan.zhihu.com/p/28058762)，它很好地讲述了npm和前端包管理的历史。

npm 想必各位前端er已经很熟悉了，这里就不再介绍模块化JS的重要性，也不在讨论CJS（CommonJS）和ECMA Module语法的问题。

我们要了解为什么需要改进npm，需要其他包管理器，首先就要了解npm，它在前端项目管理中**扮演了什么角色，以及它是如何实现这些功能的**，再此基础之上再讨论 npm 在生产环境中的**最佳实践原则**。

#### npm 如何管理 `node_modules`

众所周知，npm本质上是一个包管理器，管理包（依赖就是它的本职工作），它要干的事情无非只有两件：**把需要的包放进`node_modules`**和**在调用时找到对应的package**。

解析放进`node_modules`中的包比较简单，按照名称在路径中寻找目录，找到对应的`package.json`并按照里面的`main`属性访问读取对应文件，最后返回给调用者即可。但安装package的过程和组织目录就相对更加复杂。

##### `node_modules`的历史

我们现在使用的npm（我使用的是v8）都是**扁平化的目录结构**，即所有依赖（直接和间接）都放在顶级目录中，所有package共用。但是最开始其实不是这样的，而是嵌套结构，即每个包有自己的 node_modules，也没有`package-lock.json`描述间接依赖关系，那是npm是如何一步步发展到这样的呢？

- **npm1和npm2**会**嵌套地**安装每一个包所依赖的所有依赖项，这自然是很省事和直接的做法。但当项目依赖变得复杂时，可能产生很多问题：

  <img src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305050105265.jpg" alt="img" style="zoom: 50%;" />

  - 如果B和C都依赖了D，那么就会各自安装并保存一份D的副本到自己的node_modules中，更糟的是，它们的间接依赖也会发生一样的事，这产生了大量冗余
  - Windows系统中有很多程序无法处理超过260个字符的文件路径名，而这样嵌套的方案会产生很深的依赖路径，可能大于260个字符

- **npm3**采用了**扁平依赖关系树**来解决上面的问题，即将所有依赖平铺在顶级目录下，即使A和B都依赖了C，但C在顶层目录只有一份，因此避免了冗余。但这种方法仍有一些缺点：

  ![img](https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305050105809.png)

  - **扁平化的目录不能正确反映包之间的依赖关系**。因此npm必须首先遍历所有的项目依赖关系**生成依赖树**，再决定如何生成扁平的node_modules目录结构（即在install安装时，会不停的往上级node_modules中寻找，如果找到同样的包，就不再重复安装），而这个**依赖分析是一个很耗时的操作**，也是[npm安装速度慢的一个很重要的原因](https://github.com/npm/npm/issues/8826)。
  - **依赖结构是不确定的**。当两个包依赖了同一个包的不同版本，这在依赖解析时的行为就是无法确定的。如`B`依赖了`F@1.0.0`，而`C`依赖了`F@2.0.0`，若在`package.json`中B在C前面就会采取B的依赖（即`F@1.0.0`），否则就会采取C的依赖。（这个问题被[lock文件](#lock 文件)部分解决了）
  - 由于间接依赖也会放在顶级目录中，因此**项目中可以非法访问没有在`package.json`中声明过依赖的包**

- **npm5**中引入了`package-lock.json`（yarn在npm3时就引入了`yarn.lock`）来**描述和固定项目的依赖树**，包括但不限于项目直接依赖的所有间接依赖信息，这部分解决了npm3中的依赖结构不确定问题，保证了不同地方依赖的一致性、加快了安装速度

  - `package-lock.json`和之前就有的`npm-shrinkwrap.json`是几乎完全相同的，但`npm-shrinkwrap.json`不会自动生成，`package-lock.json`不能用于发布；如果二者同时存在，`npm-shrinkwrap.json`的优先级更高


##### 全局缓存

一些不了解包管理的同学可能觉得npm会每次从网络上下载，只有yarn/pnpm才会用缓存。其实不然，**npm从很早期的版本就有全局下载缓存**（但和yarn的offline mode不是一个东西）。

在npm5中，npm引入了新的cache机制：cacache来管理缓存，这里**仅讨论cacache**。

npm从registry下载任何package时，都会存储到本地的缓存目录：`~/.npm/cacache`里，里面又有三个文件夹：

- content-v2
- index-v5
- tmp

npm在安装依赖的时候，根据`package-lock`中具体包的version, name和integrity信息（没有lock只能去请求registry了），用`pacote:range-manifest:{url}:{integrity}`生成唯一key，通过SHA256得到的hash，去`_cacache/index-v5`里找对应的文件，就能拿到基本的meta信息缓存了。

如果缓存命中，就会向远程仓库确认是否过期（304检查）检查，如果均通过，就会直接使用缓存；否则就会向registry请求包，并更新缓存。

值得注意的是，**npm5中也引入了yarn中的`offline-mode`特性**，在此之前是不支持离线安装的

- 使用`--prefer-offline`后将**优先**使用本地缓存
- 使用`--offiline`后将**强制**使用本地缓存，若本地缓存中没有请求的包将会报错

##### `npm link`是什么

`npm link`的本质是创建一个软链接，用于将本地的包添加到另一个项目中，多用于开发中的包的调试。

工作原理是：将其链接到全局node模块安装路径中。为目标npm模块的可执行bin文件创建软连接，将其连接到全局node命令安装路径中 

#### `package.json`的正确使用姿势

一般来说，每个项目都应该指定的属性有下，一般分为**描述信息**（如`name`、`version`这些，用于描述Git仓库和npm发布信息）和**运行信息**（如`main`、`scripts`等，用于描述npm应该怎么运行这个项目）两部分：

- `name`是项目的名称
- `version`是当前项目的版本号，在发布npm包时非常重要
- `description`是描述信息，很多时候是作为项目的基本描述
- `keyword`是项目关键字，这些描述信息随便打开一个npm包的主页就能知道其作用
- `author`是作者相关的信息（发布时用到）
- `license`是开源协议（发布时用到）
- `main`是作为包被调用时寻找的入口文件
- ~~`test`是测试脚本入口~~
- `scripts`是定义使用`node run <cmd>`指令时可以调用的脚本
  - `start`/`dev`一般代表运行开发环境
  - `build`/`package`/`release`一般代表打包成发布环境

##### 如何正确管理依赖（dependencies）

在`package.json`中，依赖被划分为以下几类，它们都直接在根层级（第一层）平行排布：

- `dependencies`：无论开发环境还是生成环境都需要依赖的包，通常是一些库模块（如`axios`,`dayjs`等），可以使用`npm i <pkg> --save`在安装包时就记录下来（实际上安装任何包时都会默认记录到`dependencies`中）
- `devDependencies`：在开发时需要，生产环境中需要的包，通常是一些打包器（如`webpack`）和转译器（如`ts-node`），可以使用`npm i <pkg> --save-dev`来保存到这个part中

以下两种依赖类型可能没有那么常用，但你仍可能在某些工程中看到：

- `optionalDependencies`：表示只有在运行时需要使用某些功能时才会引入，这个比较少见，可以使用`--save-optional`或`-O`来添加
- `peerDependencies`:表示工程需要和这个依赖配套使用，**一般用于插件开发**而非项目开发，是为了解决本项目依赖和作为插件被引入的时候与主项目依赖版本冲突的问题（如`vuex@4.1.0`表明了自己需要`vue@^3.2.0`配套使用），但**这个选项对于解决某些插件兼容性问题出奇的好用**（算某些奇技淫巧吧），可以使用`-D`选项来添加。
- `bundledDependencies`：表示工程在发布时会携带这些modules，而不是每次使用插件时都需要重新使用`npm install`下载一遍，可以使用`--save-bundled`或`-B`来添加

##### 包版本管理

不管是开发自己的包还是使用别人的包，版本管理都是非常重要的。npm社区倡导 **semver** (semantic versioning，语义化版本规范) 版本命名规范，具体如下图所示，正确的版本命名如：`2.1.0`,`3.1.4-beta.2`等

<img src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305031454335.jpg" alt="DCD572D8419EB1437770110DE077EBDC" style="zoom:50%;" />

- 当发生了无法向下兼容的API修改时（如弃用或修改某些API的用法），更新`major`位
- 当新增了向下兼容的功能时，更新`minor`位
- 当做了向下兼容的问题修复时，更新`patch`位
- 对于某些先行版本（pre-release），可以使用可选的`tags`标签

在使用他人的包时，我们也可以使用`~, >, <, =, >=, <=, -, ||, x, X, *`等符号来锁定和描述版本，以下是常用符号说明。

- `^`是缺省时的默认情况，表示只锁定`major`，`minor`和`patch`取最新版本
- `~`表示锁定`major`和`minor`，`patch`取最新版本
- `=`表示锁定全部版本
- `>=`表示指定一个最低版本，尽可能取最新版本
- `x, X, *`表示通配符，如`3.4.*`

##### lock 文件

像`package-lock.json`、`yarn.lock`这样的文件就是lock文件，刚刚开始接触前端开发的人一定或多或少像我一样被lock文件折磨过。

在自己`npm install`后突然多出了一个`package-lock.json`，然后一提交突然就多了几万行代码。这还不是最糟的，过一会儿和你协作的人也 clone 了这个仓库（且没有 clone 你的 lock 文件），然后TA也上传了一份自己的 lock 文件。

当你再次安装的时候，boom~，意外发生了，lock文件和你的`package.json`发生了冲突，不能正常工作了。你百思不得其解，看到报错指示，你决定删除lock文件，然后一切照旧，不断地重蹈覆辙，最终愤怒地将lock文件添加到 gitignore 中。

你逐渐开始怀疑人生：**为什么有lock文件这种只产生麻烦而毫无作用的东西呢？**



然而lock文件真的毫无作用吗？要明白为什么需要lock文件，我们就需要弄懂使用`npm install`一键安装依赖时经历了哪些步骤和过程。

<img src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305031454782.png" alt="4fbdd537f1ff6950b7c16e122ba37047" style="zoom:80%;" />

一般来讲，`npm install`按照上图工作，大致可以分为5个流程：

1. 若**未找到`package-lock.json`**，就向registry（所谓的线上源）查询包信息
2. 下载依赖包，存放在cache目录（这也是其他包管理器如yarn等优化最多的地方）
3. 解压下载的压缩包到`node_modules`目录
4. 将所有**已安装的包信息存放到`package-lock.json`中，以供下次安装使用**
5. 递归地处理依赖的依赖，直至所有依赖都完成安装

从上面的流程中我们不难看出，lock文件描述的是**npm应该从哪里找到、怎么构建依赖的行为集合**，如果有lock文件作为指导npm就不用挨个查询，而是一步到位节省很多时间。但是，如果lock文件和`package.json`产生了冲突，安装过程就无法顺利进行，这也是众多前端er痛苦面具的重要来源之一。



下面这个lock文件截取了header部分和一个`dependencies`的结构，以此为例我们来看看`package-lock.json`是如何工作的：
```json
{
  "name": "hr-manage-system",
  "version": "1.0.0",
  "lockfileVersion": 2,
  "requires": true,
  "packages": {
    "": {
      "name": "hr-manage-system",
      "version": "1.0.0",
      "license": "ISC",
      "dependencies": {
          ...
      },
      "devDependencies": {
          ...
      }
    },
    "node_modules/@ampproject/remapping": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.2.0.tgz",
      "integrity": "sha512-qRmjj8nj9qmLTQXXmaR1cck3UXSRMPrbsLJAasZpF+t3riI71BXed5ebIOYwQntykeZuhjsdweEc9BxH5Jc26w==",
      "dev": true,
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.1.0",
        "@jridgewell/trace-mapping": "^0.3.9"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    }
  }
}
```

可以看出，lock文件里的依赖信息显然比`package.json`更丰富，如**指定了明确的版本号、下载地址等信息**，最重要的是**指定了依赖项的依赖项**（这避免了反复查询，节省了大量时间）。

简单地说，如果抛开节约查询时间不谈，lock文件最大作用就是**锁定安装时的包的版本号**，以保证其他人在`npm install`时大家的依赖能保证一致（前提是大家都使用了同一份lock文件）。

> 小结：
>
> - lock 文件可以指定依赖的版本号、下载地址和依赖情况，保证其他人在`npm install`时大家的依赖能保证一致并节约安装时间
> - 需要保证所有人使用同一份lock文件才能提高效率，避免冲突
> - **每次添加新包需要运行一次`npm install`才能更新lock文件**，这点非常关键

#### npm-CLI

这里列举一些常用的npm命令行指令：

- `npm install`：安装所有依赖
- `npm install <pkg>`/`npm i <pkg>`：安装指定包
- `npm uninstall <pkg>`：删除包
- `npm run <script>`：运行指定指令（`npm start`和`npm test`不需要`run`）
- `npm rebuild`：删除现有依赖，重新安装
- `npm cache clean`：清除下载缓存

##### 项目初始化

使用`npm init`可以按照默认引导初始化项目并创建`package.json`；`npm init -y`则表示全部使用默认配置，跳过引导。

当然，我们一般不会从零开始创建项目，而是从一些脚手架开始创建项目，可以使用开源的脚手架（如`create-react-app`等），在有自己的项目流程之后也可以**定义自己的脚手架**。

创建自己的脚手架时，可以使用git仓库，也可以打包成npm包上直接使用`npx`提供的CLI功能用类似`npm init`的流程创建。

##### npx 指令

设想一个场景，比如你要使用 webpack 来打包，你一般有两个选择：

- 全局安装 webpack，直接使用命令行 `webpack` 直接调用，但这样需要手动更新版本，且不同项目使用同一个版本可能出现冲突和兼容性问题
- 使用本地 webpack，就需要 `./node_modules/@webpack-cli/xxx` 这样的格式，很是麻烦

npx 想要解决的主要问题，就是**调用项目内部安装的模块**，**避免全局安装模块**。

使用 npx 后，再调用 webpack 就可以使用下面的格式 

```shell
npx webpack run
```

npx 的原理很简单，就是运行的时候，会到`node_modules/.bin`路径和环境变量`$PATH`里面，检查命令是否存在。

由于 npx 会检查环境变量`$PATH`，所以系统命令也可以调用。

#### cnpm 与镜像源管理

相对于其他两位来说，cnpm作为一个**内置中国镜像源（一般为淘宝源）的npm**，对npm的机制并没有做出改变，**实在不值得单独列为一个包管理器**。

个人评价的话，cnpm只是特殊情况下的特殊产物，或者说“阶段性过渡解决方案”，因此在这里**不推荐任何人使用**, it's out of date!

> 这里也插播几句题外话，如果大家看过油管的前端教程（像那种讲座、Hands-On或者新技术Preview之类的），你会发现他们花在安装依赖（`xxx install`）上的时间真的很少。相比之下，我们花在各种奇怪的网络问题上的时间明显是他们的好几倍，什么npm、pip，通通Time Exceeded或者Connection Closed，这也是cnpm能在国内的前端前期发展中能快速占领市场的重要原因。

最近个人并没有使用cnpm，但根据个人之前的使用体验，镜像源（含cnpm）最大问题是**依赖版本滞后**，导致你安装的版本可能和其他人不同，而且对于所有代理源你都不能期待其与npm官方仓库完全保持同步。（企业自建仓库除外，那包含了企业自己的版本需求）

因此，个人对于网络问题更推荐使用**7890方案**~~（如果你并不明白什么是7890也可以用你的1080方案，如果1080方案都不知道还是remake吧）~~，其次才是寻找代理源。如果你一定要寻找一个代理源，可以在原生npm下考虑以下方案：

- [nrm]() 代理源（repogistry）管理器
- [nvm]() Node版本管理器提供的附加功能
- 如果你不想装任何额外工具，**npm自带的配置也支持你配置仓库源和代理**

### Yarn

Yarn是一个Facebook出品的老牌包管理器，相对于npm要新一点，但相对于pnpm又要旧一点，也已经经过了多个**大版本迭代**。

#### yarn-v1

~~已经成为时代的眼泪啦~~yarn与npm-v3同期发布，他们都带来了**扁平依赖项**的特性。

![img](https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305050105922.png)

但Yarn作为~~新生的~~包管理器自然应该有一些额外的优点，其主打的特性有（这些特性大都被npm5所采用）：

- 默认创建`yarn.lock`文件，描述清晰的依赖树（早期的npm并不会默认在install时生成`package-lock.json`）
- 支持离线模式，完全/优先使用本地缓存安装（**但注意npm也有本地缓存机制**）
- 将多个安装操作**并行**进行（这也是它快的主要原因）

#### yarn-v2+

Modern Yarn和Classic Yarn的工作方式截然不同，可以说这里才是Yarn的正文部分。

> 需要注意的是，默认情况下yarn仍是1.x的模式，除非你指定yarn版本为2

##### mono-repo开发模式



### pnpm

> *pnpm* (performant npm) is a **fast, disk space efficient package manager**

上面是[pnpm官网](https://pnpm.io/)对自己的定位和介绍，可以看出其主要特性是**快速和省空间**，还打出了**performant**（良好性能）的旗号。

事实上它也不仅拥有npm和yarn的大部分特性（如lock-file固定化依赖、全局下载缓存、并行计算等），还拥有一些独特的优势，如**硬链接共享依赖、更好支持mono-repo**等。

那么它有多performant呢？请看下图，可以看出它在速度上面对yarn、npm都几乎不落下风，更重要的是它支持**共享依赖**特性！

<img src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305050100867.png" alt="image-20230505010021849" style="zoom:80%;" />

#### pnpm如何改进`node_modules`

在传统的npm中，如果你有 100 个项目，并且所有项目都有一个相同的依赖包，那么，你在硬盘上就需要保存 100 份该相同依赖包的副本来保证不同项目之间的版本独立。~~都什么年代还在用传统npm~~

那么，pnpm是如何做到提高安装速度、节省硬盘空间的呢？答案是**硬链接**和**非扁平（也非嵌套）目录**。

在pnpm中一个典型的node_modules目录是这样的，可以看到充满了各种链接和两个独特的目录：`.pnpm`和`.pnpm-store`

![img](https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305050106556.png)

要理解上述机制是如何工作的，我们首先要理解pnpm安装依赖时是怎么做的：

1. 

#### 包共享机制（硬链接）



- pnpm 会将包存放在一个统一的位置（类似于全局下载缓存，但**yarn/npm只在安装时使用，pnpm会在解析依赖时也会使用**），当安装软件包时，其包含的**所有文件都会硬链接自此位置，而不会占用额外的硬盘空间**。这让你可以在项目之间方便地共享相同版本的依赖包。
- 对于不同项目的不同版本依赖，项目本地只会**存储版本之间不同的文件**（类似git记录），而不会因为一个文件的修改而保存依赖包的所有文件。

> 注意：
>
> pnpm由于创建的是**硬链接**，因此右键查看`node_modules`仍能看到其占用的真实容量，但实际上**只占用了一份空间**（也就是一个磁盘上两个位置的同一份空间）。（来源：[pnpm-FAQ](https://pnpm.io/zh/faq)）

#### 非扁平 node_modules 目录

npm和yarn采用拍扁 node_modules（所有软件包都将被提升到 node_modules 的 根目录下）的方案，这会导致**源码可以访问本不属于当前项目所设定的依赖包**，导致可能某些包依赖的同一个库版本冲突。

但这也是不得已而为的解决方案，因为其非硬链接的存储方式导致如果给每个包都单独列出依赖会导致 node_modules 本就臃肿的体积无限膨胀，也会导致很长很长的路径，在Windows下出现解析问题。

在 pnpm 中，它会**创建非扁平的 node_modules 目录**，默认情况下，pnpm 则是通过使用符号链接的方式仅将项目的直接依赖项添加到 node_modules 的根目录下。

![img](https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202304270054060.jpeg)

安装依赖（比如安装一个`bar@1.0.0`的依赖，它依赖`foo@^1.0.0`）的具体步骤如下：

1. 安装依赖：直接把`foo`和`bar`（即所有用到的包）都放进`.pnpm`中，而不必计算扁平化依赖
2. 处理间接依赖：处理`bar`对`foo`的依赖
   1. 项目的直接依赖`bar@1.0.0`会在`node_modules`根目录下创建一个目录，这个目录实际上软链接到`.pnpm`中的对应包
   2. 在`.pnpm/bar@1.0.0/node_modules`中有`foo@1.0.0`和**`bar@1.0.0`**（是的，**pnpm允许包引用自身**，这也是把包和其依赖在内部展平，避免循环依赖链的方法）
3. 处理直接依赖：`.pnpm/bar@1.0.0/node_modules/foo@1.0.0`实际指向与`bar`同级的`.pnpm/foo@1.0.0`
4. 硬链接：所有包都通过硬链接连接到同一盘符下的`.pnpm_store`中（也就是说该盘符下所有的项目都可以共用一份依赖）

**相关阅读：**

- [Flat node_modules is not the only way | pnpm中文文档 | pnpm中文网](https://www.pnpm.cn/blog/2020/05/27/flat-node-modules-is-not-the-only-way)
- [Symlinked `node_modules` structure | pnpm中文文档 | pnpm中文网](https://www.pnpm.cn/symlinked-node-modules-structure)
- [聊聊前端包管理器对比Npm、Yarn和Pnpm-yarn和npm (51cto.com)](https://www.51cto.com/article/702067.html)
- [常见问题 | pnpm](https://pnpm.io/zh/faq)
- [Pnpm: 最先进的包管理工具 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/404784010)
- [动机 | pnpm中文文档 | pnpm中文网](https://www.pnpm.cn/motivation)

#### 使用pnpm开发mono-repo项目



#### pnpm 常用命令

除了常用的`pnpm add`、`pnpm install`、`pnpm uninstall`等npm迁移指令，pnpm还有一系列自身特性的产生的特有指令。

- `pnpm rebuild/rb`：用于mono-repo的功能
- `pnpm env <cmd>`：用于管理Node版本，这里更推荐使用[nvm](#`nvm` (Node Version Manager))
- `pnpm store <cmd>`：管理磁盘共享缓存
  - `add`：只添加到缓存，而不添加到任何项目
  - `prune`：移除未引用的包
  - `path`：返回活跃的存储目录的路径

## 打包器

- webpack
- vercel
- vite
- turbopack
- esbuild

## 测试工具

- jest
- vitest

## 跨平台工具

- dotenv
- concurrent/npm-run-all
- crossenv