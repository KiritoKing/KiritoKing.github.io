---
title: 2023 前端工具链大族谱
tags:
  - 前端
  - 工具链
  - 包管理
  - 打包器
  - JS引擎
categories:
  - 前端
abbrlink: 2480212683
date: 2023-04-18 00:00:00
---

q前端工具

## JavaScript 引擎

- nodejs
  - nvm：管理node版本
  - npx
  
- deno
- bun
- v8
- quickjs

## 包管理

众所周知，~~node_modules是世界上最重的东西~~管理好依赖项对于任何工程项目来说都是至关重要的，某些层次上这可能是在前端项目中最影响开发体验的环节之一（~~特别是对于中国开发者~~还有一个环节个人认为是打包）。

<img src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202304270103999.jpg" alt="19b3ff266bc8f328a8f61732d15c6a0" style="zoom: 50%;" />

因此，这一part讨论主要的Node包管理器及其特性。

由于在node v16.13+版本支持了`corepack`特性，这是一个实验性工具，可以**指定项目使用的包管理器以及版本**，具体情况会放在本版块第一部分叙述。

### corepack 工具

> 官方介绍来自：[nodejs/corepack (github.com)](https://github.com/nodejs/corepack)
>
> Corepack is a zero-runtime-dependency Node.js script that acts as a bridge between Node.js projects and the package managers they are intended to be used with during development. In practical terms, **Corepack will let you use Yarn and pnpm without having to install them** - just like what currently happens with npm, which is shipped by Node.js by default.

Corepack是一个**实验性工具**，在 Node.js v16.13 版本中引入，它可以指定项目使用的包管理器以及版本。

简单来说，Corepack 会成为 Node.js 官方的内置 CLI，用来管理『包管理工具（yarn、pnpm）』，在管理 Packges 时会直接调用 Corepack 进行管理，Corepack 再根据用户配置决定使用哪个包管理器来实施操作，即『**包管理器的管理器**』。

新版的 pnpm 和 yarn 文档中，都推荐使用 corepack 来安装和管理包管理器，而非全局方式。

需要注意的是：**corepack 目前仅支持yarn和pnpm，并不支持cnpm**

#### 安装并启用 corepack

由于 Corepack 是实验性工具，它并不是默认启动的，需要手动开启，开启后全局有效

- 对于16.13+版本：直接运行`corepack enable`（需要管理员/root权限）
- 对于更低版本：需要手动安装
  - 首先，需要**卸载已经全局安装的yarn和pnpm**
  - 然后，**全局安装 corepack**：`npm i -g corepack`

#### 使用 corepack

- 可以直接使用`yarn`、`pnpm`来进行安装而无需任何配置
  - 若指令与项目指定的包管理器符合，`corepack`会静默下载对应的包管理器并执行你的指令
  - 若指令与项目指定的包管理器不一致，`corepack`会拒绝你的指令
  - 若本地未配置包管理器，`corepack`会下载对应的 *good-release* 版本的包管理器并执行你的指令
- 可以在`package.json`中指定 `packageManager` 字段来指定包管理器，值按`packageManager@x.y.z`格式编排，后面**可选**地附加一个Hash值来确认安全下载，下面的代码就指定了Yarn 3.2.3版本作为包管理器：

```json
{
  "packageManager": "yarn@3.2.3+sha224.953c8233f7a92884eee2de69a1b92d1f2ec1655e66d08071ba9a02fa"
}
```

- 可以使用 `corepack prepare packageManager@x.y.z` 来下载某个版本的包管理器，也可以直接使用`latest`下载最新版；增加 `--activate` 选项可以将当前下载的版本作为 corepack 的 best-release 版本。



### npm

> *npm*不仅是一个包管理器，更是**前端的项目管理器**，它除了管理依赖，还定义了项目的信息、脚本和行为，这些信息都被*npm*存储在`package.json`中。

npm 想必各位前端er已经很熟悉了，这里就不再介绍模块化JS的重要性，也不在讨论CJS（CommonJS）和ECMA Module语法的问题，直接说说 npm 在生产环境中的**应用、规则和best-practices**。

如果想要了解前端领域为什么需要npm，可以看[这篇文章](https://zhuanlan.zhihu.com/p/28058762)，它很好地讲述了npm和前端包管理的历史。

#### 项目初始化

使用`npm init`可以按照默认引导初始化项目并创建`package.json`；`npm init -y`则表示全部使用默认配置，跳过引导。

当然，我们一般不会从零开始创建项目，而是从一些脚手架开始创建项目，可以使用开源的脚手架（如`create-react-app`等），在有自己的项目流程之后也可以**定义自己的脚手架**。

创建自己的脚手架时，可以使用git仓库，也可以打包成npm包上直接使用`npx`提供的CLI功能用类似`npm init`的流程创建。

#### npm-CLI

这里列举一些常用的npm命令行指令：

- `npm install`：安装所有依赖
- `npm install <pkg>`/`npm i <pkg>`：安装指定包
- `npm uninstall <pkg>`：删除包
- `npm run <script>`：运行指定指令
- `npm rebuild`：删除现有依赖，重新安装
- `npm cache clean`：清除下载缓存

##### npx 指令

设想一个场景，比如你要使用 webpack 来打包，你一般有两个选择：

- 全局安装 webpack，直接使用命令行 `webpack` 直接调用，但这样需要手动更新版本，且不同项目使用同一个版本可能出现冲突和兼容性问题
- 使用本地 webpack，就需要 `./node_modules/@webpack-cli/xxx` 这样的格式，很是麻烦

npx 想要解决的主要问题，就是**调用项目内部安装的模块**，**避免全局安装模块**。

使用 npx 后，再调用 webpack 就可以使用下面的格式 

```shell
npx webpack run
```

npx 的原理很简单，就是运行的时候，会到`node_modules/.bin`路径和环境变量`$PATH`里面，检查命令是否存在。

由于 npx 会检查环境变量`$PATH`，所以系统命令也可以调用。

#### `package.json`的正确使用姿势

一般来说，每个项目都应该指定的属性有下，一般分为**描述信息**（如`name`、`version`这些，用于描述Git仓库和npm发布信息）和**运行信息**（如`main`、`scripts`等，用于描述npm应该怎么运行这个项目）两部分：

- `name`是项目的名称
- `version`是当前项目的版本号，在发布npm包时非常重要
- `description`是描述信息，很多时候是作为项目的基本描述
- `keyword`是项目关键字，这些描述信息随便打开一个npm包的主页就能知道其作用
- `author`是作者相关的信息（发布时用到）
- `license`是开源协议（发布时用到）
- `main`是作为包被调用时寻找的入口文件
- ~~`test`是测试脚本入口~~
- `scripts`是定义使用`node run <cmd>`指令时可以调用的脚本
  - `start`/`dev`一般代表运行开发环境
  - `build`/`package`/`release`一般代表打包成发布环境

##### 如何正确管理依赖（dependencies）

在`package.json`中，依赖被划分为以下几类，它们都直接在根层级（第一层）平行排布：

- `dependencies`：无论开发环境还是生成环境都需要依赖的包，通常是一些库模块（如`axios`,`dayjs`等），可以使用`npm i <pkg> --save`在安装包时就记录下来（实际上安装任何包时都会默认记录到`dependencies`中）
- `devDependencies`：在开发时需要，生产环境中需要的包，通常是一些打包器（如`webpack`）和转译器（如`ts-node`），可以使用`npm i <pkg> --save-dev`来保存到这个part中

以下两种依赖类型可能没有那么常用，但你仍可能在某些工程中看到：

- `optionalDependencies`：表示只有在运行时需要使用某些功能时才会引入，这个比较少见，可以使用`--save-optional`或`-O`来添加
- `peerDependencies`:表示工程需要和这个依赖配套使用，**一般用于插件开发**而非项目开发，是为了解决本项目依赖和作为插件被引入的时候与主项目依赖版本冲突的问题（如`vuex@4.1.0`表明了自己需要`vue@^3.2.0`配套使用），但**这个选项对于解决某些插件兼容性问题出奇的好用**（算某些奇技淫巧吧），可以使用`-D`选项来添加。
- `bundledDependencies`：表示工程在发布时会携带这些modules，而不是每次使用插件时都需要重新使用`npm install`下载一遍，可以使用`--save-bundled`或`-B`来添加

##### 包版本管理

不管是开发自己的包还是使用别人的包，版本管理都是非常重要的。npm社区倡导 **semver** (semantic versioning，语义化版本规范) 版本命名规范，具体如下图所示，正确的版本命名如：`2.1.0`,`3.1.4-beta.2`等

<img src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305031454335.jpg" alt="DCD572D8419EB1437770110DE077EBDC" style="zoom:50%;" />

- 当发生了无法向下兼容的API修改时（如弃用或修改某些API的用法），更新`major`位
- 当新增了向下兼容的功能时，更新`minor`位
- 当做了向下兼容的问题修复时，更新`patch`位
- 对于某些先行版本（pre-release），可以使用可选的`tags`标签

在使用他人的包时，我们也可以使用`~, >, <, =, >=, <=, -, ||, x, X, *`等符号来锁定和描述版本，以下是常用符号说明。

- `^`是缺省时的默认情况，表示只锁定`major`，`minor`和`patch`取最新版本
- `~`表示锁定`major`和`minor`，`patch`取最新版本
- `=`表示锁定全部版本
- `>=`表示指定一个最低版本，尽可能取最新版本
- `x, X, *`表示通配符，如`3.4.*`

##### lock 文件

像`package-lock.json`、`yarn.lock`这样的文件就是lock文件，刚刚开始接触前端开发的人一定或多或少像我一样被lock文件折磨过。

在自己`npm install`后突然多出了一个`package-lock.json`，然后一提交突然就多了几万行代码。这还不是最糟的，过一会儿和你协作的人也 clone 了这个仓库（且没有 clone 你的 lock 文件），然后TA也上传了一份自己的 lock 文件。

当你再次安装的时候，boom~，意外发生了，lock文件和你的`package.json`发生了冲突，不能正常工作了。你百思不得其解，看到报错指示，你决定删除lock文件，然后一切照旧，不断地重蹈覆辙，最终愤怒地将lock文件添加到 gitignore 中。

你逐渐开始怀疑人生：**为什么有lock文件这种只产生麻烦而毫无作用的东西呢？**



然而lock文件真的毫无作用吗？要明白为什么需要lock文件，我们就需要弄懂使用`npm install`一键安装依赖时经历了哪些步骤和过程。

<img src="https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202305031454782.png" alt="4fbdd537f1ff6950b7c16e122ba37047" style="zoom:80%;" />

一般来讲，`npm install`按照上图工作，大致可以分为5个流程：

1. 若**未找到`package-lock.json`**，就向registry（所谓的线上源）查询包信息
2. 下载依赖包，存放在cache目录（这也是其他包管理器如yarn等优化最多的地方）
3. 解压下载的压缩包到`node_modules`目录
4. 将所有**已安装的包信息存放到`package-lock.json`中，以供下次安装使用**
5. 递归地处理依赖的依赖，直至所有依赖都完成安装

从上面的流程中我们不难看出，lock文件描述的是**npm应该从哪里找到、怎么构建依赖的行为集合**，如果有lock文件作为指导npm就不用挨个查询，而是一步到位节省很多时间。但是，如果lock文件和`package.json`产生了冲突，安装过程就无法顺利进行，这也是众多前端er痛苦面具的重要来源之一。



下面这个lock文件截取了header部分和一个`dependencies`的结构，以此为例我们来看看`package-lock.json`是如何工作的：
```json
{
  "name": "hr-manage-system",
  "version": "1.0.0",
  "lockfileVersion": 2,
  "requires": true,
  "packages": {
    "": {
      "name": "hr-manage-system",
      "version": "1.0.0",
      "license": "ISC",
      "dependencies": {
        "@faker-js/faker": "^7.6.0",
        "@reduxjs/toolkit": "^1.9.0",
        "antd": "^4.24.2",
        "axios": "^1.1.3",
        "koa": "^2.13.4",
        "koa-body": "^6.0.1",
        "koa-cookie": "^1.0.0",
        "koa-router": "^12.0.0",
        "koa-static": "^5.0.0",
        "localforage": "^1.10.0",
        "match-sorter": "^6.3.1",
        "react": "^18.2.0",
        "react-dom": "^18.2.0",
        "react-redux": "^8.0.5",
        "react-router-dom": "^6.4.2",
        "react-use-cookie": "^1.4.0",
        "sort-by": "^1.2.0"
      },
      "devDependencies": {
        "@babel/core": "^7.19.3",
        "@babel/preset-env": "^7.19.3",
        "@babel/preset-react": "^7.18.6",
        "@babel/preset-typescript": "^7.18.6",
        "@emotion/react": "^11.10.4",
        "@emotion/styled": "^11.10.4",
        "@types/react": "^18.0.21",
        "@types/react-dom": "^18.0.6",
        "@typescript-eslint/eslint-plugin": "^5.41.0",
        "babel-loader": "^8.2.5",
        "classnames": "^2.3.2",
        "clean-webpack-plugin": "^4.0.0",
        "css-loader": "^6.7.1",
        "eslint": "^8.26.0",
        "eslint-config-prettier": "^8.5.0",
        "eslint-config-standard-with-typescript": "^23.0.0",
        "eslint-plugin-import": "^2.26.0",
        "eslint-plugin-n": "^15.3.0",
        "eslint-plugin-promise": "^6.1.1",
        "eslint-plugin-react": "^7.31.10",
        "html-webpack-plugin": "^5.5.0",
        "mini-css-extract-plugin": "^2.6.1",
        "nodemon": "^2.0.20",
        "npm-run-all": "^4.1.5",
        "style-loader": "^3.3.1",
        "typescript": "^4.8.4",
        "typescript-plugin-css-modules": "^3.4.0",
        "webpack": "^5.74.0",
        "webpack-cli": "^4.10.0",
        "webpack-dev-server": "^4.11.1",
        "webpack-merge": "^5.8.0"
      }
    },
    "node_modules/@ampproject/remapping": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.2.0.tgz",
      "integrity": "sha512-qRmjj8nj9qmLTQXXmaR1cck3UXSRMPrbsLJAasZpF+t3riI71BXed5ebIOYwQntykeZuhjsdweEc9BxH5Jc26w==",
      "dev": true,
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.1.0",
        "@jridgewell/trace-mapping": "^0.3.9"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    }
  }
}
```

可以看出，lock文件里的依赖信息显然比`package.json`更丰富，如**指定了明确的版本号、下载地址等信息**，最重要的是**指定了依赖项的依赖项**（这避免了反复查询，节省了大量时间）。

简单地说，如果抛开节约查询时间不谈，lock文件最大作用就是**锁定安装时的包的版本号**，以保证其他人在`npm install`时大家的依赖能保证一致（前提是大家都使用了同一份lock文件）。

> 小总结：
>
> - lock 文件可以指定依赖的版本号、下载地址和依赖情况，保证其他人在`npm install`时大家的依赖能保证一致并节约安装时间
> - 需要保证所有人使用同一份lock文件才能提高效率，避免冲突
> - **每次添加新包需要运行一次`npm install`才能更新lock文件**，这点非常关键



### cnpm

### pnpm

> *pnpm* is a **fast, disk space efficient package manager**

上述是[pnpm官网](https://pnpm.io/)对自己的定位和介绍，可以看出其是一款对标npm和yarn的包管理器，主打一个**快速和省空间**，这里就主要介绍它对npm的区别和优势。

在传统的npm中，如果你有 100 个项目，并且所有项目都有一个相同的依赖包，那么， 你在硬盘上就需要保存 100 份该相同依赖包的副本来保证不同项目之间的版本独立。~~都什么年代还在用传统npm~~

那么，*pnpm* 是如何做到提高安装速度、节省硬盘空间的呢？

#### 包共享机制

![img](https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202304270045517.jpeg)

上面这张图在网上广为流传，是pnpm对工作原理的自述：

- pnpm 会将包存放在一个统一的位置（类似于yarn的全局缓存），当安装软件包时， 其包含的**所有文件都会硬链接自此位置，而不会占用 额外的硬盘空间**。这让你可以在项目之间方便地共享相同版本的 依赖包。
- 对于不同项目的不同版本依赖，项目本地只会**存储版本之间不同的文件**（类似git记录），而不会因为一个文件的修改而保存依赖包的 所有文件。

#### 非扁平 node_modules 目录

npm和yarn采用拍扁 node_modules（所有软件包都将被提升到 node_modules 的 根目录下）的方案，这会导致**源码可以访问 本不属于当前项目所设定的依赖包**，导致可能某些包依赖的同一个库版本冲突。

但这也是不得已而为的解决方案，因为其非硬链接的存储方式导致如果给每个包都单独列出依赖会导致 node_modules 本就臃肿的体积无限膨胀。

在 pnpm 中，它会**创建非扁平的 node_modules 目录**，默认情况下，pnpm 则是通过使用符号链接的方式仅将项目的直接依赖项添加到 node_modules 的根目录下。

![img](https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202304270054060.jpeg)

**相关阅读：**

- [Flat node_modules is not the only way | pnpm中文文档 | pnpm中文网](https://www.pnpm.cn/blog/2020/05/27/flat-node-modules-is-not-the-only-way)
- [Symlinked `node_modules` structure | pnpm中文文档 | pnpm中文网](https://www.pnpm.cn/symlinked-node-modules-structure)

### Yarn 2

package.json和package-lock.json

还有各种dependency的区别

## 打包器

- webpack
- vercel
- vite
- turbopack
- esbuild