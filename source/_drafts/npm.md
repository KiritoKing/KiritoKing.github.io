---
title: 前端工具链之包管理器 - 过去与未来的npm
tags:
  - 工具链
  - 包管理器
  - npm
---

本篇文章是前端工具链系列文章的开篇之作，本来是打算写一篇很长很长的文章，来详尽阐述2023年的前端工具链的全貌的。但奈何篇幅实在太长，不便发布和阅读，而且有些部分完成度已经较高，但由于其他部分的完成度几乎为0导致这些内容不能发布出来~~（可以预见的由于工作原因另一部分可能拖更较久）~~ 。

最终选择了分段分章节的形式，将每个部分单独提出来说，最终在一个目录中汇总，这样阅读体验更好，每个部分也能说得更详细一点。

本篇主要讲述npm的发展历史（历史渊源和各个版本的改动），组织node_modules方式的变动以及`package.json`的详细介绍（并发布一个自己的npm包）；除此之外，还会介绍node官方提出的现代包管理器愿景，并介绍**corepack**工具（包管理器的管理器）。

<!-- more -->

## npm 的历史发展

> *npm*(Node Package Manager) 不仅是一个包管理器，更是**前端的项目管理器**，它除了**管理依赖**，还定义了项目的信息、脚本和行为，这些信息都被*npm*存储在`package.json`中。
>
> 可以说*npm*是一切前端项目，包括其他包管理器的基础，其他包管理器均必须实现npm的基础功能，**你可以没有其他包管理器，但你必须有且理解npm**。

上面一段是我在*《前端工具链》*草稿中写的原文，虽然这一段在新的组织形式下已经不再合适作为部分总结，但仍很好地概括npm的地位——理解了npm你才能理解其他包管理器（或者说为什么需要更现代的解决方案），也是为什么我们已经有yarn和pnpm等更现代的解决方案，连node官方都打算不再完整内置npm的今天我们仍需要学习npm的原因，而不仅仅是出于一些兼容性的原因才学习和使用npm（当然学习了npm的机制也能更好地解决出现在其他包管理器中出现的兼容性问题）。

### npm-v1与我们为什么需要npm

如果你用过C++，也用过Python或者Rust，那你在 **如何快速地调用他人写好的代码** 这件事上，对二者的效率有深刻的认识。是的，Python/Rust有自己的**包管理器**（pip/cargo），但C++却没有一个统一的包管理器方案（vcpkg或许是一个选择），这导致你调用别人代码的门槛显著提高，也不利于库作者的版本管理。

程序员群体从最初开始就强调一个社区文化、开源精神~~（Bill Gates除外）~~ ，复用别人的代码和让别人能复用自己的代码自然也是社区的头号需求，在现代前端开发中node环境已经普及的今天（或者说昨天），一个对应node环境的包管理器自然会产生，是的，这就是npm。

> 拿Python作对比的话：JavaScript是语言本身，类似于python；node是语言运行环境，类似于cpython；npm是包管理器机制，类似于pip（和PyPi）。
>
> 其实在项目管理这一点上，node.js和npm更像Rust于Cargo的关系 ~~但是说爸爸像儿子总是不合适的~~

#### 前npm时代如何共享代码

毕竟JS和Web的历史远比Node和npm更悠久，那么在更为原始的web开发年代，大家是如何共享代码的呢？

对于直接使用代码来说，有两种方法：

- 直接共享代码：在Github上共享代码库，直接下载源码，也就是最直接的使用方式
- 使用CDN分发：现在的网页开发中仍存在这种方法，即用`<script src="xxx"/>`直接引用线上的JS资源

#### JS模块化

如果我们采用上面提到的两种方法对他人的代码进行复用，在项目规模不断扩大后，新的问题就出现了：**全局变量污染**。

假如说我们用`<script>`引入了`a.js`和`b.js`两个JS脚本，但两个脚本中都定义了一个名称相同的全局变量，或者都使用了隐式的全局`this`指针去给同一个属性赋值，这时的变量行为就不再可控了，彼此覆盖的顺序通常由`<script>`的执行顺序决定，这可能会给整个页面的效果造成毁灭性的破坏。

一个比较简单粗暴的解决方案是给每个全局变量都加上模块名前缀，并禁止使用全局`this`，但这显然是一个治标不治本的方法，只有从根本上解决全局作用域的问题才能维持项目的健康，这里就需要引入“**模块化**”的概念。

> **模块化**：把复杂的系统分解到多个模块以方便编码
>
> 在**模块化编程**中，开发者将程序分解成离散功能块（discrete chunks of functionality），并称之为**模块**。
>
> - 将一个复杂的程序依据一定的规则（规范）封装成几个块（文件），并进行组合在一起
> - 块的内部数据相对而言是私有的，只是向外部暴露一些接口与外部其他模块通信
>
> 每个模块具有比完整程序更小的接触面，使得校验、调试、测试轻而易举。 精心编写的*模块*提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。

JS的所谓模块化就是**包装一个模块内部的所有代码，使其标识符不向外暴露，而仅仅暴露声明（导出）的标识符，以避免全局污染**。为了实现模块化的这些功能，Web界提出了不同的解决方案：

- 原始的`<script>`方案 + 开发规范：这种方案并不能称得上严格意义的模块化，仅仅是引用了不同的JS文件，并遵守了一定规范
  - 仍可能**污染全局作用域**，script会直接存在在根DOM下，全局有效
  - 仅适用于Web页面开发，在node环境中无效
  - 在大型项目中各种资源难以管理依赖、版本和加载顺序
- **CommonJS**系列方案：Node的主流方案，使用**模块作用域**来解决全局污染，都使用`require`来引用模块
- **ECM**方案

##### CommonJS 家族

CommonJS方案有CJS、AMD和CMD三个分支方案，**这里推荐只了解CJS方案即可**。

- **CommonJS（CJS）方案**：这是在ECMA Module（ECM）方案出来前最流行的方案，**现在NodeJS仍采用这种方案作为主流**（ECM仅仅是实验性）
  - CJS目前最主流的平台实现是NodeJS，因此大部分特性将依照Node的实现机制进行理解
  - CJS是一种**同步加载**方案，模块的加载顺序，按照其在代码中出现的顺序进行加载
  - CJS添加了一种**模块作用域**（类似于C语言中的单文件作用域），每个文件就是一个模块，所有代码运行在模块作用域中，不会污染全局作用域
    - 通常情况下模块内声明的变量不会污染全局作用域，除非意外声明了全局变量（没有用`var`, `let`, `const`关键字而直接声明）
    - `"use strict"`模式可以避免上述情况，但可以通过`global.XXX`显式地声明全局变量
    - Node中**使用包装函数为每个文件提供了一个独立的函数作用域**，以此来实现了模块作用域，详见[这篇文章](https://zhuanlan.zhihu.com/p/25916585)
  - 使用`require(package)`加载模块（即被依赖模块的`module.exports`对象）
    - 通过按顺序查找PATH去加载模块
    - 模块可以加载多次，第一次加载时会运行模块，**模块输出结果会被缓存，再次加载时，会从缓存结果中读取输出模块**
  - 使用`module.exports`对象暴露当前模块对外的接口（是的，`module.exports`是一个对象）
    - 直接将一个对象赋值给`module.exports`，`require`时就可以直接获取这个对象
    - 也可以给`module.exports`添加属性或方法，如`module.exports.foo = 'foo'`
    - 为了方便，Node为每个模块提供一个`exports`变量，即在开头隐式地提供了`exports=module.exports`这样一句话
  - 每个模块内部都包含一个`Module`对象（自动生成）
    - `id`：模块的标识符
    - `filename`：模块的文件名，带有绝对路径
    - `loaded`：表示模块是否已经完成加载，用于缓存加载
    - `parent`：一个数组，表示调用该模块的模块
    - `children`：一个数组，表示该模块要用到的其他模块
    - `exports`：一个对象，表示模块对外输出的值
  - **由于CJS需要Node的支持，在浏览器端需要转译为`<script>`标签才能使用，但其模块作用域将得到保留，全局污染的问题得到了解决**
- **AMD（Asynchronous Module Definition）**方案：一种已经过时的方案，主流实现是*require.js*，曾主要用于浏览器端的模块化，推崇**依赖前置** （所有依赖加载完毕后再执行依赖他们的代码）
  - 采用**异步方式**加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行
  - AMD 也采用 `require`语句加载模块，但是不同于 CommonJS，它要求两个参数：`require([module], callback)`
  - 模块必须采用``define([deps], module)`函数来定义
- **CMD（Common Module Definition）**方案：一种已经过时的方案，具体规则与AMD类似，主流实现是*sea.js*，对依赖模块的执行时机不同，推崇**就近依赖**

在本地跑了一个demo，一个空文件的**CJS Module**变量如下：

![image-20230602172111346](https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-core/2023/06/20230602172113.png)

##### ECM 模块

在CommonJS家族中：**CJS是同步加载**，主要用于**服务器端（Node）**的模块化实现；**AMD、CMD是异步加载**，二者处理依赖的方式不同，主要用于**浏览器端**的模块化实现。但他们都有一个**共同的缺点：只能动态地加载依赖，而不能静态解析依赖**。

为了解决静态依赖解析的问题，ECMA出手了，**在ES6标准中提出了ECM模块规范**。

要理解为什么需要ECM模块，我们就要知道ECM和CJS的区别（**后面两条都由最根本的第一条决定**：No Magic，Just Object）：

- **CJS标准尽管被Node采纳，但并不是ECMA标准的一部分（也就是说并非JS语言标准）**，因此`module`和`exports`并非JS关键字，而仅仅是对象或函数；而**ECM则是ECMA指定的模块化标准**，是JS语言关键字，可以在编译期直接输出模块接口。因此说**CJS是动态的，而ECM可以是静态的**。
- CJS是同步加载；ECM是异步加载，有一个独立的模块依赖的解析阶段
- CJS的`require`返回的是值的**拷贝**（直接将值赋给`exports`对象）；ECM的`import`返回的是值的**引用**

如何理解CJS的`require`返回的是值的拷贝，请参考下面的代码——由于拷贝了值，无论如何`setVal`始终都不能改变`val`的值（这里请理解一下堆栈模型与值类型）：

```javascript
// a.js
let val = 1;
const setVal = (newVal) => {
  val = newVal
}
module.exports = {
  val,
  setVal
}

// b.js
const { val, setVal } = require('./a.js')
console.log(val); // 1
setVal(101);
console.log(val); // 1
```





## 参考资料

- [JS全局变量污染和模块化 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/25489604)
- [一文彻底搞懂JS前端5大模块化规范及其区别 - Echoyya、 - 博客园 (cnblogs.com)](https://www.cnblogs.com/echoyya/p/14577243.html)
- [前端十万个为什么(之一)：我们为什么需要npm？ - 大唐西域都护 - 博客园 (cnblogs.com)](https://www.cnblogs.com/leegent/p/7244660.html)
- [Module 的加载实现 - ECMAScript 6入门 (ruanyifeng.com)](https://es6.ruanyifeng.com/#docs/module-loader#ES6-模块与-CommonJS-模块的差异)
- [javascript - 深入浅出 ESM 模块 和 CommonJS 模块 - 个人文章 - SegmentFault 思否](https://segmentfault.com/a/1190000041396029)
- [commonjs 与 esm 的区别 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903861166014478)
- [CommonJS规范详解 - 掘金 (juejin.cn)](https://juejin.cn/post/7098261507040870430)
- [CommonJS规范 -- JavaScript 标准参考教程（alpha） (ruanyifeng.com)](https://javascript.ruanyifeng.com/nodejs/module.html)
- [Node.js CommonJS 实现与模块的作用域 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/25916585)