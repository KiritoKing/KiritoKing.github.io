---
title: 前端工具链之包管理器 - 过去与未来的npm
tags:
  - 工具链
  - 包管理器
  - npm
---

本篇文章是前端工具链系列文章的开篇之作，本来是打算写一篇很长很长的文章，来详尽阐述2023年的前端工具链的全貌的。但奈何篇幅实在太长，不便发布和阅读，而且有些部分完成度已经较高，但由于其他部分的完成度几乎为0导致这些内容不能发布出来~~（可以预见的由于工作原因另一部分可能拖更较久）~~ 。

最终选择了分段分章节的形式，将每个部分单独提出来说，最终在一个目录中汇总，这样阅读体验更好，每个部分也能说得更详细一点。

本篇主要讲述npm的发展历史（历史渊源和各个版本的改动），组织node_modules方式的变动以及`package.json`的详细介绍（并发布一个自己的npm包）；除此之外，还会介绍node官方提出的现代包管理器愿景，并介绍**corepack**工具（包管理器的管理器）。

<!-- more -->

## npm 的历史发展

> *npm*(Node Package Manager) 不仅是一个包管理器，更是**前端的项目管理器**，它除了**管理依赖**，还定义了项目的信息、脚本和行为，这些信息都被*npm*存储在`package.json`中。
>
> 可以说*npm*是一切前端项目，包括其他包管理器的基础，其他包管理器均必须实现npm的基础功能，**你可以没有其他包管理器，但你必须有且理解npm**。

上面一段是我在*《前端工具链》*写的原文，虽然这一段在新的组织形式下已经不再合适作为部分总结，但仍很好地概括npm的地位——理解了npm你才能理解其他包管理器（或者说为什么需要更现代的解决方案），也是为什么我们已经有yarn和pnpm等更现代的解决方案，连node官方都打算不再完整内置npm的今天我们仍需要学习npm的原因，而不仅仅是出于一些兼容性的原因才学习和使用npm（当然学习了npm的机制也能更好地解决出现在其他包管理器中出现的兼容性问题）。

### npm-v1与我们为什么需要npm

如果你用过C++，也用过Python或者Rust，那你在 **如何快速地调用他人写好的代码** 这件事上，对二者的效率有深刻的认识。是的，Python/Rust有自己的**包管理器**（pip/cargo），但C++却没有一个统一的包管理器方案（vcpkg或许是一个选择），这导致你调用别人代码的门槛显著提高，也不利于库作者的版本管理。

程序员群体从最初开始就强调一个社区文化、开源精神~~（Bill Gates除外）~~ ，复用别人的代码和让别人能复用自己的代码自然也是社区的头号需求，在现代前端开发中node环境已经普及的今天（或者说昨天），一个对应node环境的包管理器自然会产生，是的，这就是npm。

> 拿Python作对比的话：JavaScript是语言本身，类似于python；node是语言运行环境，类似于cpython；npm是包管理器机制，类似于pip（和PyPi）。
>
> 其实在项目管理这一点上，node.js和npm更像Rust于Cargo的关系 ~~但是说爸爸像儿子总是不合适的~~

#### 前npm时代如何共享代码

毕竟JS和Web的历史远比Node和npm更悠久，那么在更为原始的web开发年代，大家是如何共享代码的呢？

对于直接使用代码来说，有两种方法：

- 直接共享代码：在Github上共享代码库，直接下载源码，也就是最直接的使用方式
- 使用CDN分发：现在的网页开发中仍存在这种方法，即用`<script src="xxx"/>`直接引用线上的JS资源

在有了Node以后，JS的魔爪伸向了Web以外，JS的**模块化**也出现了一些方案：

> **模块化**：把复杂的系统分解到多个模块以方便编码
>
> 在**模块化编程**中，开发者将程序分解成离散功能块（discrete chunks of functionality），并称之为**模块**。
>
> - 将一个复杂的程序依据一定的规则（规范）封装成几个块（文件），并进行组合在一起
> - 块的内部数据相对而言是私有的，只是向外部暴露一些接口与外部其他模块通信
>
> 每个模块具有比完整程序更小的接触面，使得校验、调试、测试轻而易举。 精心编写的*模块*提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。

- 原始的`<script>`方案：这种方案并不能称得上严格意义的模块化，仅仅是引用了不同的JS文件
  - 污染全局作用域，script会直接存在在根DOM下，全局有效
  - 仅适用于Web页面开发，在node环境中无效
  - 在大型项目中各种资源难以管理依赖、版本和加载顺序
- **CommonJS方案**：这是在ECMA Module方案出来前最流行的方案，**现在NodeJS仍采用这种方案作为主流**（ECMA方案仅仅是实验性）