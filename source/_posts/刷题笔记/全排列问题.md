---
title: 全排列问题
date: 2023-04-19
---

排列 (Permutation) 是将相异对象或符号根据确定的顺序重排。每个顺序都称作一个排列。

从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个**排列**。当m=n时所有的排列情况叫**全排列**。

全排列问题常出现在**串（string）**相关的问题中。

例题：[46. 全排列](https://leetcode.cn/problems/permutations/)

<!-- more -->

### 递归法

长度为n的串的全排列问题可以分为以下的子问题结构：

- a = 长度为n-1的串有多少种排列
- b = 插入的元素有多少种可能

最后的结果显然为 a+b

按照上述的最佳子结构关系，以串 `1234` 为例构建递归如下图所示，边界情况为**子串长度=1**：

![这里写图片描述](https://picgo-1308055782.cos.ap-chengdu.myqcloud.com/picgo-new/202304191331027.jpeg)

**注意这种解法只适用于无重复元素的集合。**

C# 题解如下：

```csharp
public class Permutation
  {
    static public List<string> Result = new List<string>();
    static T[] Swap<T>(T[] source, int i1, int i2)
    {
      var t = source[i2];
      source[i2] = source[i1];
      source[i1] = t;
      return source;
    }
    static public string[] Recursively(string str)
    {
      var candidate = str.ToCharArray();
      Recursively(candidate, 0);
      var res = Result.ToArray();
      Result.Clear();
      return res;
    }
    static void Recursively(char[] charSet, int start)
    {
      if (start == charSet.Length - 1)
      {
        var str = new String(charSet);
        Console.WriteLine(str);
        Result.Add(str);
      }
      for (int i = start; i < charSet.Length; i++)
      {
        if (i == start || charSet[i] != charSet[start])
        {
          Swap(charSet, start, i);
          Recursively(charSet, start + 1);
          Swap(charSet, start, i); // 还原变化
        }
      }
    }
  }
```

### 字典排序

设最初的串的元素字典顺序为 {1, 2, 3, 4}，每次排序都找到一个**更大**的字典排序（最大排列的下一个是最小排列）。

1. 先输出初始序列：1234
2. **从右向左**找到第一个**非递增**的数（比前一个数小的数）：3
3. 交换这个数与前一个数，并一路移动到右边序列末尾，输出序列：1243  （[31. 下一个全排列数 ](https://leetcode.cn/problems/next-permutation/)）
4. 循环直到找不到更大的排列数